import "block.lumina"
import "type.lumina"
import "lexer.lumina"
import "statement.lumina"
import "operation.lumina"


type Parser {
	BlockList blocks;
	Lexer lexer;
	Token current;
}

func createParser(str fileName) -> Parser {
	var parser = (Parser)malloc(sizeof(Parser));

	parser.blocks = createBlockList();
	parser.lexer = createLexer(fileName);
	parser.current = nextToken(parser.lexer);

	return parser;
}

func next(Parser parser) {
	parser.current = nextToken(parser.lexer);

	if (isComment(parser.current)) {
		next(parser);
	}
}

func consumeOperator(Parser parser, str operator, bool ignoreError) -> Operator {
	if (isOperator(parser.current.operator, operator)) {
		var value = parser.current.operator;
		next(parser);
		return value;
	}

	if (ignoreError != (bool)1) {
		printPosition(createPositionFromLexer(parser.lexer));
		print("did not find operator: '");
		print(operator);
		print("'\n");
	}

	return (Operator)0;
}

func consumeKeyword(Parser parser, int keyword) -> Name {
	if (isKeyword(parser.current.name, keyword)) {
		var value = parser.current.name;
		next(parser);
		return value;
	}

	printPosition(createPositionFromLexer(parser.lexer));
	print("did not find keyword: '");
	printi(keyword);
	print("'\n");

	return (Name)0;
}

func consumeIdentifier(Parser parser) -> Name {
	if (isIdentifier(parser.current.name)) {
		var value = parser.current.name;
		next(parser);
		return value;
	}

	printPosition(createPositionFromLexer(parser.lexer));
	print("did not find identifier\n");

	return (Name)0;
}

func consumeString(Parser parser) -> String {
	if (isString(parser.current)) {
		var value = parser.current.string;
		next(parser);
		return value;
	}

	printPosition(createPositionFromLexer(parser.lexer));
	print("did not find string\n");
	
	return (String)0;
}

func parseType(Parser parser, bool ignoreErrors) -> Type {
	var name = consumeIdentifier(parser);

	var brackets = createOperatorList();
	while (isOperator(parser.current.operator, "[")) {
		addOperator(brackets, parser.current.operator);

		next(parser);
		if (isOperator(parser.current.operator, "]") != (bool)1) {
			print("expected ']' after '[' in list definition\n");
		}
		var lbracket = consumeOperator(parser, "]", ignoreErrors);
		addOperator(brackets, lbracket);
	}

	return createType(name, brackets);
}

func parseProperty(Parser parser) -> Property {
	var propertyType = parseType(parser, (bool)0);

	var propertyName = parser.current.name;

	next(parser);
	var semicolon = parser.current.operator;
	
	next(parser);

	return createProperty(propertyType, propertyName, semicolon);
}

func parseTypeDefinition(Parser parser) -> TypeDefinition {
	var keyword = parser.current.name;

	next(parser);
	var typeName = parser.current.name;

	next(parser);
	var lbrace = parser.current.operator;

	var properties = createPropertyList();
	next(parser);
	while (isOperator(parser.current.operator, "}") != (bool)1) {
		var property = parseProperty(parser);
		addProperty(properties, property);
	}

	var rbrace = parser.current.operator;

	next(parser);

	return createTypeDefinition(keyword, typeName, lbrace, properties, rbrace);
}

func parseExpression(Parser parser, int precedence) -> Operation {
	func parseUnary(Parser parser) -> Operation {
		func parseGroup(Parser parser) -> Operation {
			var lparen = consumeOperator(parser, "(", (bool)0);

			if (isIdentifier(parser.current.name)) {
				var typeObj = parseType(parser, (bool)1);
				var rparen = consumeOperator(parser, ")", (bool)0);

				var operation = parseExpression(parser, PREC_index);
				return createTypeCast(lparen, typeObj, rparen, operation);
			}

			var operation = parseExpression(parser, PREC_expression);
			var rparen = consumeOperator(parser, ")", (bool)0);

			var group = createUnaryOperation(lparen, operation, rparen);
			return group;
		}

		func parseNegative(Parser parser) -> Operation {
			var operator = consumeOperator(parser, "-", (bool)0);

			var operation = parseUnary(parser);
			return createUnaryOperation(operator, operation, (Operator)0);
		}

		func parseSizeof(Parser parser) -> Operation {
			var keyword = consumeKeyword(parser, KEYWORD_sizeof);
			var lparen = consumeOperator(parser, "(", (bool)0);
			var typeObj = parseType(parser, (bool)0);
			var rparen = consumeOperator(parser, ")", (bool)0);

			var sizeOf = createSizeOf(keyword, lparen, typeObj, rparen);
			return createOperationFromSizeOf(sizeOf);
		}

		var value = (Value)0;

		if (isNumber(parser.current)) {
			value = createValueFromNumber(parser.current.number);
		} else if (isCharacter(parser.current)) {
			value = createValueFromCharacter(parser.current.character);
		} else if (isString(parser.current)) {
			value = createValueFromString(parser.current.string);
		} else if (isIdentifier(parser.current.name)) {
			value = createValueFromIdentifier(parser.current.name);
		}

		if (value != (Value)0) {
			next(parser);
			return createOperationFromValue(value);
		}

		if (isKeyword(parser.current.name, KEYWORD_sizeof)) {
			return parseSizeof(parser);
		}

		if (isOperator(parser.current.operator, "-")) {
			return parseNegative(parser);
		}

		if (isOperator(parser.current.operator, "(")) {
			return parseGroup(parser);
		}

		if (parser.current.operator == (Operator)0) {
			printPosition(createPositionFromLexer(parser.lexer));
			print("operator is null\n");
		} else {
			printPosition(parser.current.operator.position);
			print(" '");
			print(parser.current.operator.name);
			print("', ");
		}

		print("do not recognise as unary\n");

		next(parser);
		return (Operation)0;
	}

	func parseIndex(Parser parser, Operation left) -> Operation {
		var lbracket = consumeOperator(parser, "[", (bool)0);
		var index = parseExpression(parser, PREC_expression);
		var rbracket = consumeOperator(parser, "]", (bool)0);

		return createOperation(left, lbracket, index, rbracket);
	}

	func parseCall(Parser parser, Operation left) -> Operation {
		var lparen = consumeOperator(parser, "(", (bool)0);

		if (isOperator(parser.current.operator, ")")) {
			var rparen = consumeOperator(parser, ")", (bool)0);
			return createOperation(left, lparen, (Operation)0, rparen);
		}
		
		var args = parseExpression(parser, PREC_expression);

		while (isOperator(parser.current.operator, ",")) {
			var comma = consumeOperator(parser, ",", (bool)0);

			var right = parseExpression(parser, PREC_expression);

			args = createOperation(args, comma, right, (Operator)0);
		}

		var rparen = consumeOperator(parser, ")", (bool)0);

		return createOperation(left, lparen, args, rparen);
	}

	var operation = parseUnary(parser);

	if (operation == (Operation)0) {
		print("left hand side is null\n");
		return (Operation)0;
	}

	var operator = parser.current.operator;

	while (operator != (Operator)0 && operator.precedence >= precedence) {
		if (isOperator(operator, "[")) {
			operation = parseIndex(parser, operation);
		} else if (isOperator(operator, "(")) {
			operation = parseCall(parser, operation);
		} else {
			next(parser);

			var right = parseExpression(parser, precedence + 1);

			if (right == (Operation)0) {
				print("right hand side is null\n");
				return (Operation)0;
			}

			operation = createOperation(operation, operator, right, (Operator)0);
		}

		operator = parser.current.operator;
	}

	return operation;
}

func parseImport(Parser parser) -> Import {
	var keyword = consumeKeyword(parser, KEYWORD_import);

	var fileName = consumeString(parser);

	return createImport(keyword, fileName);
}

func parseVariableDefinition(Parser parser) -> VariableDefinition {
	var keyword = parser.current.name;
	next(parser);

	var name = consumeIdentifier(parser);
	var equalSign = consumeOperator(parser, "=", (bool)0);
	var value = parseExpression(parser, PREC_expression);
	var semicolon = consumeOperator(parser, ";", (bool)0);

	return createVariableDefinition(keyword, name, equalSign, value, semicolon);
}

func parseParameterList(Parser parser) -> ParameterList {
	var list = createParameterList();

	if (isOperator(parser.current.operator, ")")) {
		return list;
	}

	var parameterType = parseType(parser, (bool)0);
	var name = consumeIdentifier(parser);

	while (isOperator(parser.current.operator, ",")) {
		var comma = consumeOperator(parser, ",", (bool)0);

		var parameter = createParameter(parameterType, name, comma);
		addParameter(list, parameter);

		parameterType = parseType(parser, (bool)0);
		name = consumeIdentifier(parser);
	}

	var parameter = createParameter(parameterType, name, (Operator)0);
	addParameter(list, parameter);

	return list;
}

func parseReturnType(Parser parser) -> ReturnType {
	var rarrow = consumeOperator(parser, "->", (bool)0);
	var typeObj = parseType(parser, (bool)0);

	return createReturnType(rarrow, typeObj);
}

func parseStatement(Parser parser) -> Statement {
	func parseBlock(Parser parser) -> int {
		var lbrace = consumeOperator(parser, "{", (bool)0);

		var list = createStatementList();

		while (isOperator(parser.current.operator, "}") != (bool)1 || parser.current.isEOF) {
			var statement = parseStatement(parser);
			addStatement(list, statement);
		}

		var rbrace = consumeOperator(parser, "}", (bool)0);
		var block = createBlock(lbrace, list, rbrace);
		addBlock(parser.blocks, block);

		return parser.blocks.size - 1;
	}

	func parseElseIf(Parser parser, ElseIfList list, Name elseKeyword) {
		var ifKeyword = consumeKeyword(parser, KEYWORD_if);
		var lparen = consumeOperator(parser, "(", (bool)0);
		var condition = parseExpression(parser, PREC_expression);
		var rparen = consumeOperator(parser, ")", (bool)0);
		var block = parseBlock(parser);
		var endPosition = parser.blocks.list[block].region.end;

		var elseIf = createElseIf(elseKeyword, ifKeyword, lparen, condition, rparen, block, endPosition);
		addElseIf(list, elseIf);
	}

	func parseElse(Parser parser, Name keyword) -> Else {
		var block = parseBlock(parser);
		var endPosition = parser.blocks.list[block].region.end;

		return createElse(keyword, block, endPosition);
	}

	func parseIf(Parser parser) -> If {
		var ifKeyword = consumeKeyword(parser, KEYWORD_if);

		var lparen = consumeOperator(parser, "(", (bool)0);
		var condition = parseExpression(parser, PREC_expression);
		var rparen = consumeOperator(parser, ")", (bool)0);
		
		var block = -1;
		var endPosition = (Position)0;

		if (isOperator(parser.current.operator, "{")) {
			block = parseBlock(parser);
			endPosition = parser.blocks.list[block].region.end;
		} else {
			print("expected block after 'if'\n");
		}

		var elseIfs = createElseIfList();

		while (isKeyword(parser.current.name, KEYWORD_else)) {
			var elseKeyword = consumeKeyword(parser, KEYWORD_else);

			if (isKeyword(parser.current.name, KEYWORD_if)) {
				parseElseIf(parser, elseIfs, elseKeyword);
			} else {
				var elseObj = parseElse(parser, elseKeyword);
				return createIf(ifKeyword, lparen, condition, rparen, block, elseIfs, elseObj, endPosition);
			}
		}

		return createIf(ifKeyword, lparen, condition, rparen, block, elseIfs, (Else)0, endPosition);
	}

	func parseWhile(Parser parser) -> While {
		var keyword = consumeKeyword(parser, KEYWORD_while);

		var lparen = consumeOperator(parser, "(", (bool)0);
		var condition = parseExpression(parser, PREC_expression);
		var rparen = consumeOperator(parser, ")", (bool)0);

		var block = -1;
		var endPosition = (Position)0;

		if (isOperator(parser.current.operator, "{")) {
			block = parseBlock(parser);
			endPosition = parser.blocks.list[block].region.end;
		} else  {
			print("expected block after while\n");
		}

		return createWhile(keyword, lparen, condition, rparen, block, endPosition);
	}

	func parseFunctionDefinition(Parser parser) -> FunctionDefinition {
		var keyword = consumeKeyword(parser, KEYWORD_func);
		var name = consumeIdentifier(parser);

		var lparen = consumeOperator(parser, "(", (bool)0);
		var parameters = parseParameterList(parser);
		var rparen = consumeOperator(parser, ")", (bool)0);

		var returnType = (ReturnType)0;
		if (isOperator(parser.current.operator, "->")) {
			returnType = parseReturnType(parser);
		}

		var block = parseBlock(parser);
		var endPosition = parser.blocks.list[block].region.end;

		return createFunctionDefinition(keyword, name, lparen, parameters, rparen, returnType, block, endPosition);
	}

	func parseReturn(Parser parser) -> Return {
		var keyword = consumeKeyword(parser, KEYWORD_return);

		if (isOperator(parser.current.operator, ";")) {
			var semicolon = consumeOperator(parser, ";", (bool)0);

			return createReturn(keyword, (Operation)0, semicolon);
		}

		var expression = parseExpression(parser, PREC_expression);
		var semicolon = consumeOperator(parser, ";", (bool)0);

		return createReturn(keyword, expression, semicolon);
	}

	if (isKeyword(parser.current.name, KEYWORD_var) ||
		isKeyword(parser.current.name, KEYWORD_const)) {
		var variable = parseVariableDefinition(parser);

		return createVariableStatement(variable);
	} else if (isKeyword(parser.current.name, KEYWORD_func)) {
		var function = parseFunctionDefinition(parser);

		return createFunctionStatement(function);
	} else if (isKeyword(parser.current.name, KEYWORD_if)) {
		var ifStatement = parseIf(parser);

		return createIfStatement(ifStatement);
	} else if (isKeyword(parser.current.name, KEYWORD_while)) {
		var whileStatement = parseWhile(parser);

		return createWhileStatement(whileStatement);
	} else if (isKeyword(parser.current.name, KEYWORD_type)) {
		parseTypeDefinition(parser);
		return (Statement)0;
	} else if (isKeyword(parser.current.name, KEYWORD_import)) {
		var importStatement = parseImport(parser);

		return createImportStatement(importStatement);
	} else if (isKeyword(parser.current.name, KEYWORD_return)) {
		var returnStatement = parseReturn(parser);

		return createReturnStatement(returnStatement);
	} else if (isOperator(parser.current.operator, "{")) {
		parseBlock(parser);
		return (Statement)0;
	}

	var operation = parseExpression(parser, PREC_assignment);
	var semicolon = consumeOperator(parser, ";", (bool)0);
	var expression = createExpression(operation, semicolon);

	return createExpressionStatement(expression);
}

func parse(Parser parser) {
	while (parser.current.isEOF != (bool)1) {
		parseStatement(parser);
	}
}
