import "../std/path.lumina"
import "../std/io.lumina"
import "../std/string.lumina"
import "../std/memory.lumina"

import "block.lumina"
import "type.lumina"
import "function.lumina"
import "variable.lumina"
import "expression.lumina"
import "lexer.lumina"
import "statement.lumina"
import "operation.lumina"
import "operator.lumina"
import "value.lumina"
import "immediate.lumina"
import "if.lumina"
import "while.lumina"
import "name.lumina"
import "position.lumina"
import "import.lumina"


type SyntaxTree {
	str fileName;
	Lexer lexer;
	BlockList blocks;
	StatementList statements;
	TypeList types;
	FunctionList functions;
	VariableList variables;
	ImportList imports;

	SyntaxTree[] importTrees;
}

type SyntaxTreeList {
	int size;
	int maxSize;
	SyntaxTree[] list;
}

type Parser {
	SyntaxTreeList files;

	TypeList types;
	TypeDefinition int;
	TypeDefinition char;
	TypeDefinition str;
	TypeDefinition bool;
	TypeDefinition any;
	TypeDefinition ptr;
	TypeDefinition null;

	FunctionList functions;
	FunctionDefinition syscall;

	VariableList variables;
	VariableDefinition argc;
	VariableDefinition argv;

	int numIfs;
	int numWhiles;
	int numAnds;
	int numOrs;

	StringList strings;
}

func createSyntaxTree(str fileName, int numAnds, int numOrs) -> SyntaxTree {
	var tree = (SyntaxTree)malloc(sizeof(SyntaxTree));

	tree.fileName = fileName;
	tree.blocks = createBlockList();
	tree.lexer = createLexer(fileName);
	next(tree.lexer);

	tree.statements = createStatementList();
	tree.types = createTypeList();
	tree.functions = createFunctionList();
	tree.variables = createVariableList();
	tree.imports = createImportList();

	tree.importTrees = (SyntaxTree[])0;
	
	return tree;
}

func createSyntaxTreeList() -> SyntaxTreeList {
	var list = (SyntaxTreeList)malloc(sizeof(SyntaxTreeList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (SyntaxTree[])malloc(8 * 8);

	return list;
}

func addSyntaxTree(SyntaxTreeList list, SyntaxTree tree) {
	list.list[list.size] = tree;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (SyntaxTree[])realloc((ptr)list.list, 8 * list.maxSize, list.maxSize * 8 * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func findSyntaxTree(SyntaxTreeList list, str fileName) -> SyntaxTree {
    var i = 0;
    while (i < list.size) {
	if (streq(list.list[i].fileName, fileName)) {
	    return list.list[i];
	}
	i = i + 1;
    }
    return (SyntaxTree)0;
}

func createParser() -> Parser {
	var parser = (Parser)malloc(sizeof(Parser));

	parser.files = createSyntaxTreeList();

	parser.types = createTypeList();
	parser.int = createTypeFromString("int", 8);
	parser.char = createTypeFromString("char", 1);
	parser.str = createArrayFrom("str", parser.char);
	parser.bool = createTypeFromString("bool", 1);
	parser.any = createTypeFromString("any", 8);
	parser.ptr = createTypeFromString("ptr", 8);
	parser.null = createTypeFromString("null", 8);
	addType(parser.types, parser.int);
	addType(parser.types, parser.char);
	addType(parser.types, parser.str);
	addType(parser.types, parser.bool);
	addType(parser.types, parser.any);
	addType(parser.types, parser.ptr);
	addType(parser.types, parser.null);

	parser.functions = createFunctionList();
	var syscallParameters = createParameterList();

	var i = 0;
	while (i < 7) {
	    addParameter(syscallParameters, createParameterFromString("any", (str)0));
	    i = i + 1;
	}

	var syscallReturnType = createReturnTypeFromString("any");

	parser.syscall = createFunctionFromString("syscall", syscallParameters, syscallReturnType);
	addFunction(parser.functions, parser.syscall);

	parser.variables = createVariableList();
	parser.argv = createVariableFromString("argv", 0, 1, createArrayFrom((str)0, parser.str));
	parser.argc = createVariableFromString("argc", 0, 2, parser.int);
	addVariable(parser.variables, parser.argv);
	addVariable(parser.variables, parser.argc);

	parser.numIfs = 0;
	parser.numWhiles = 0;
	parser.numAnds = 0;
	parser.numOrs = 0;

	parser.strings = createStringList();

	return parser;
}

func consumeOperator(Parser parser, SyntaxTree tree, str operator, bool ignoreError) -> Operator {
	if (isOperator(tree.lexer.current.operator, operator)) {
		var value = tree.lexer.current.operator;
		next(tree.lexer);

		return value;
	}

	if (ignoreError != (bool)1) {
		printPosition(createPositionFromLexer(tree.lexer));
		print("did not find operator: '");
		print(operator);
		print("'\n");
	}

	return (Operator)0;
}

func consumeKeyword(Parser parser, SyntaxTree tree, int keyword) -> Name {
	if (isKeyword(tree.lexer.current.name, keyword)) {
		var value = tree.lexer.current.name;
		next(tree.lexer);
		return value;
	}

	printPosition(createPositionFromLexer(tree.lexer));
	print("did not find keyword: '");
	printi(keyword);
	print("'\n");

	return (Name)0;
}

func consumeIdentifier(Parser parser, SyntaxTree tree) -> Name {
	if (isIdentifier(tree.lexer.current.name)) {
		var value = tree.lexer.current.name;
		next(tree.lexer);
		return value;
	}

	printPosition(createPositionFromLexer(tree.lexer));
	print("did not find identifier\n");

	return (Name)0;
}

func consumeString(Parser parser, SyntaxTree tree) -> String {
	if (isString(tree.lexer.current)) {
		var value = tree.lexer.current.string;
		next(tree.lexer);
		return value;
	}

	printPosition(createPositionFromLexer(tree.lexer));
	print("did not find string\n");
	
	return (String)0;
}

func parseType(Parser parser, SyntaxTree tree, bool ignoreErrors) -> Type {
	var name = consumeIdentifier(parser, tree);

	var brackets = createOperatorList();
	while (isOperator(tree.lexer.current.operator, "[")) {
		addOperator(brackets, tree.lexer.current.operator);

		next(tree.lexer);
		if (isOperator(tree.lexer.current.operator, "]") != (bool)1) {
			print("expected ']' after '[' in list definition\n");
		}
		var lbracket = consumeOperator(parser, tree, "]", ignoreErrors);
		addOperator(brackets, lbracket);
	}

	return createType(name, brackets);
}

func parseProperty(Parser parser, SyntaxTree tree) -> Property {
	var propertyType = parseType(parser, tree, (bool)0);

	var propertyName = tree.lexer.current.name;

	next(tree.lexer);
	var semicolon = tree.lexer.current.operator;
	
	next(tree.lexer);

	return createProperty(propertyType, propertyName, semicolon);
}

func parseTypeDefinition(Parser parser, SyntaxTree tree) -> TypeDefinition {
	var keyword = tree.lexer.current.name;

	next(tree.lexer);
	var typeName = tree.lexer.current.name;

	next(tree.lexer);
	var lbrace = tree.lexer.current.operator;

	var properties = createPropertyList();
	next(tree.lexer);
	while (isOperator(tree.lexer.current.operator, "}") != (bool)1) {
		var property = parseProperty(parser, tree);
		addProperty(properties, property);
	}

	var rbrace = tree.lexer.current.operator;

	next(tree.lexer);

	return createTypeDefinition(keyword, typeName, lbrace, properties, rbrace);
}

func parseExpression(Parser parser, SyntaxTree tree, int precedence) -> Operation {
	func parseUnary(Parser parser, SyntaxTree tree) -> Operation {
		func parseGroup(Parser parser, SyntaxTree tree) -> Operation {
			var lparen = consumeOperator(parser, tree, "(", (bool)0);

			if (isIdentifier(tree.lexer.current.name)) {
				var typeObj = parseType(parser, tree, (bool)1);
				var rparen = consumeOperator(parser, tree, ")", (bool)0);

				var operation = parseExpression(parser, tree, PREC_index);
				return createTypeCast(lparen, typeObj, rparen, operation);
			}

			var operation = parseExpression(parser, tree, PREC_expression);
			var rparen = consumeOperator(parser, tree, ")", (bool)0);

			var group = createUnaryOperation(lparen, operation, rparen);
			return group;
		}

		func parseNegative(Parser parser, SyntaxTree tree) -> Operation {
			var operator = consumeOperator(parser, tree, "-", (bool)0);

			var operation = parseUnary(parser, tree);
			return createUnaryOperation(operator, operation, (Operator)0);
		}

		func parseSizeof(Parser parser, SyntaxTree tree) -> Operation {
			var keyword = consumeKeyword(parser, tree, KEYWORD_sizeof);
			var lparen = consumeOperator(parser, tree, "(", (bool)0);
			var typeObj = parseType(parser, tree, (bool)0);
			var rparen = consumeOperator(parser, tree, ")", (bool)0);

			var sizeOf = createSizeOf(keyword, lparen, typeObj, rparen);
			return createOperationFromSizeOf(sizeOf);
		}

		var value = (Value)0;

		if (isNumber(tree.lexer.current)) {
			value = createValueFromNumber(tree.lexer.current.number);
		} else if (isCharacter(tree.lexer.current)) {
			value = createValueFromCharacter(tree.lexer.current.character);
		} else if (isString(tree.lexer.current)) {
			value = createValueFromString(tree.lexer.current.string);
		} else if (isIdentifier(tree.lexer.current.name)) {
			value = createValueFromIdentifier(tree.lexer.current.name);
		}

		if (value != (Value)0) {
			next(tree.lexer);
			return createOperationFromValue(value);
		}

		if (isKeyword(tree.lexer.current.name, KEYWORD_sizeof)) {
			return parseSizeof(parser, tree);
		}

		if (isOperator(tree.lexer.current.operator, "-")) {
			return parseNegative(parser, tree);
		}

		if (isOperator(tree.lexer.current.operator, "(")) {
			return parseGroup(parser, tree);
		}

		if (tree.lexer.current.operator == (Operator)0) {
			printPosition(createPositionFromLexer(tree.lexer));
			print("operator is null\n");
		} else {
			printPosition(tree.lexer.current.operator.position);
			print(" '");
			print(tree.lexer.current.operator.name);
			print("', ");
		}

		print("do not recognise as unary\n");

		next(tree.lexer);
		return (Operation)0;
	}

	func parseIndex(SyntaxTree tree, Operation left) -> Operation {
		var lbracket = consumeOperator(parser, tree, "[", (bool)0);
		var index = parseExpression(parser, tree, PREC_expression);
		var rbracket = consumeOperator(parser, tree, "]", (bool)0);

		return createOperation(left, lbracket, index, rbracket);
	}

	func parseCall(SyntaxTree tree, Operation left) -> Operation {
		var lparen = consumeOperator(parser, tree, "(", (bool)0);

		if (isOperator(tree.lexer.current.operator, ")")) {
			var rparen = consumeOperator(parser, tree, ")", (bool)0);
			return createOperation(left, lparen, (Operation)0, rparen);
		}
		
		var args = parseExpression(parser, tree, PREC_expression);

		while (isOperator(tree.lexer.current.operator, ",")) {
			var comma = consumeOperator(parser, tree, ",", (bool)0);

			var right = parseExpression(parser, tree, PREC_expression);

			args = createOperation(args, comma, right, (Operator)0);
		}

		var rparen = consumeOperator(parser, tree, ")", (bool)0);

		return createOperation(left, lparen, args, rparen);
	}

	var operation = parseUnary(parser, tree);

	if (operation == (Operation)0) {
		print("left hand side is null\n");
		return (Operation)0;
	}

	var operator = tree.lexer.current.operator;

	while (operator != (Operator)0 && operator.precedence >= precedence) {
		if (isOperator(operator, "[")) {
			operation = parseIndex(tree, operation);
		} else if (isOperator(operator, "(")) {
			operation = parseCall(tree, operation);
		} else {
			next(tree.lexer);

			var right = parseExpression(parser, tree, operator.precedence + 1);

			if (right == (Operation)0) {
				print("right hand side is null\n");
				return (Operation)0;
			}

			operation = createOperation(operation, operator, right, (Operator)0);
		}

		operator = tree.lexer.current.operator;
	}

	return operation;
}

func parseImport(Parser parser, SyntaxTree tree) -> Import {
	var keyword = consumeKeyword(parser, tree, KEYWORD_import);

	var fileName = consumeString(parser, tree);

	return createImport(keyword, fileName);
}

func parseVariableDefinition(Parser parser, SyntaxTree tree, int depth, int position) -> VariableDefinition {
	var keyword = tree.lexer.current.name;
	next(tree.lexer);

	var name = consumeIdentifier(parser, tree);
	var equalSign = consumeOperator(parser, tree, "=", (bool)0);
	var value = parseExpression(parser, tree, PREC_expression);
	var semicolon = consumeOperator(parser, tree, ";", (bool)0);

	return createVariableDefinition(keyword, name, equalSign, value, depth, position, semicolon);
}

func parseParameterList(Parser parser, SyntaxTree tree) -> ParameterList {
	var list = createParameterList();

	if (isOperator(tree.lexer.current.operator, ")")) {
		return list;
	}

	var parameterType = parseType(parser, tree, (bool)0);
	var name = consumeIdentifier(parser, tree);

	while (isOperator(tree.lexer.current.operator, ",")) {
		var comma = consumeOperator(parser, tree, ",", (bool)0);

		var parameter = createParameter(parameterType, name, comma);
		addParameter(list, parameter);

		parameterType = parseType(parser, tree, (bool)0);
		name = consumeIdentifier(parser, tree);
	}

	var parameter = createParameter(parameterType, name, (Operator)0);
	addParameter(list, parameter);

	return list;
}

func parseReturnType(Parser parser, SyntaxTree tree) -> ReturnType {
	var rarrow = consumeOperator(parser, tree, "->", (bool)0);
	var typeObj = parseType(parser, tree, (bool)0);

	return createReturnType(rarrow, typeObj);
}

func parseStatement(Parser parser, SyntaxTree tree, TypeList typeList, FunctionList functionList, VariableList variableList, ImportList importList, Block outer) -> Statement {
	func parseBlock(SyntaxTree tree, Block outer) -> int {
		var lbrace = consumeOperator(parser, tree, "{", (bool)0);

		var statementList = createStatementList();
		var typeList = createTypeList();
		var functionList = createFunctionList();
		var variableList = createVariableList();

		var block = createBlock(lbrace, statementList, typeList, functionList, variableList, outer);
		var blockIndex = addBlock(tree.blocks, block);

		while (isOperator(tree.lexer.current.operator, "}") != (bool)1 || tree.lexer.current.isEOF) {
			var statement = parseStatement(parser, tree, typeList, functionList, variableList, importList, block);
			addStatement(statementList, statement);
		}

		var rbrace = consumeOperator(parser, tree, "}", (bool)0);

		setEnd(block, rbrace);

		return blockIndex;
	}

	func parseElseIf(Parser parser, SyntaxTree tree, ElseIfList list, Name elseKeyword, Block outer) {
		var ifKeyword = consumeKeyword(parser, tree, KEYWORD_if);
		var lparen = consumeOperator(parser, tree, "(", (bool)0);
		var condition = parseExpression(parser, tree, PREC_expression);
		var rparen = consumeOperator(parser, tree, ")", (bool)0);
		var block = parseBlock(tree, outer);
		var endPosition = tree.blocks.list[block].region.end;

		var elseIf = createElseIf(elseKeyword, ifKeyword, lparen, condition, rparen, block, endPosition, parser.numIfs);
		parser.numIfs = parser.numIfs + 1;
		addElseIf(list, elseIf);
	}

	func parseElse(SyntaxTree tree, Name keyword, Block outer) -> Else {
		var block = parseBlock(tree, outer);
		var endPosition = tree.blocks.list[block].region.end;

		return createElse(keyword, block, endPosition);
	}

	func parseIf(Parser parser, SyntaxTree tree, Block outer) -> If {
		var ifKeyword = consumeKeyword(parser, tree, KEYWORD_if);

		var lparen = consumeOperator(parser, tree, "(", (bool)0);
		var condition = parseExpression(parser, tree, PREC_expression);
		var rparen = consumeOperator(parser, tree, ")", (bool)0);
		
		var block = -1;
		var endPosition = (Position)0;

		if (isOperator(tree.lexer.current.operator, "{")) {
			block = parseBlock(tree, outer);
			endPosition = tree.blocks.list[block].region.end;
		} else {
			print("expected block after 'if'\n");
		}

		var elseIfs = createElseIfList();

		while (isKeyword(tree.lexer.current.name, KEYWORD_else)) {
			var elseKeyword = consumeKeyword(parser, tree, KEYWORD_else);

			if (isKeyword(tree.lexer.current.name, KEYWORD_if)) {
				parseElseIf(parser, tree, elseIfs, elseKeyword, outer);
			} else {
				var elseObj = parseElse(tree, elseKeyword, outer);
				var ifObj = createIf(ifKeyword, lparen, condition, rparen, block, elseIfs, elseObj, endPosition, parser.numIfs);
				parser.numIfs = parser.numIfs + 1;
				return ifObj;
			}
		}

		var ifObj = createIf(ifKeyword, lparen, condition, rparen, block, elseIfs, (Else)0, endPosition, parser.numIfs);
		parser.numIfs = parser.numIfs + 1;
		return ifObj;
	}

	func parseWhile(SyntaxTree tree, Block outer) -> While {
		var keyword = consumeKeyword(parser, tree, KEYWORD_while);

		var lparen = consumeOperator(parser, tree, "(", (bool)0);
		var condition = parseExpression(parser, tree, PREC_expression);
		var rparen = consumeOperator(parser, tree, ")", (bool)0);

		var block = -1;
		var endPosition = (Position)0;

		if (isOperator(tree.lexer.current.operator, "{")) {
			block = parseBlock(tree, outer);
			endPosition = tree.blocks.list[block].region.end;
		} else  {
			print("expected block after while\n");
		}

		var whileObj = createWhile(keyword, lparen, condition, rparen, block, endPosition, parser.numWhiles);
		parser.numWhiles = parser.numWhiles + 1;
		return whileObj;
	}

	func parseFunctionDefinition(Parser parser, SyntaxTree tree, Block outer) -> FunctionDefinition {
		var keyword = consumeKeyword(parser, tree, KEYWORD_func);
		var name = consumeIdentifier(parser, tree);

		var lparen = consumeOperator(parser, tree, "(", (bool)0);
		var parameters = parseParameterList(parser, tree);
		var rparen = consumeOperator(parser, tree, ")", (bool)0);

		var returnType = (ReturnType)0;
		if (isOperator(tree.lexer.current.operator, "->")) {
			returnType = parseReturnType(parser, tree);
		}

		var block = parseBlock(tree, outer);
		var blockObj = tree.blocks.list[block];
		var endPosition = blockObj.region.end;

		var function = createFunctionDefinition(keyword, name, lparen, parameters, rparen, returnType, block, endPosition);
		blockObj.function = function;

		return function;
	}

	func parseReturn(SyntaxTree tree) -> Return {
		var keyword = consumeKeyword(parser, tree, KEYWORD_return);

		if (isOperator(tree.lexer.current.operator, ";")) {
			var semicolon = consumeOperator(parser, tree, ";", (bool)0);

			return createReturn(keyword, (Operation)0, semicolon);
		}

		var expression = parseExpression(parser, tree, PREC_expression);
		var semicolon = consumeOperator(parser, tree, ";", (bool)0);

		return createReturn(keyword, expression, semicolon);
	}

	if (isKeyword(tree.lexer.current.name, KEYWORD_var) ||
		isKeyword(tree.lexer.current.name, KEYWORD_const)) {
		var depth = 0;
		if (outer != (Block)0) {
		    depth = outer.depth;
		}

		var size = variableList.size;
		if (depth == 0) {
		    size = size + 3;
		}

		var variable = parseVariableDefinition(parser, tree, depth, size);

		addVariable(variableList, variable);

		return createVariableStatement(variable);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_func)) {
		var function = parseFunctionDefinition(parser, tree, outer);

		addFunction(functionList, function);

		return createFunctionStatement(function);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_if)) {
		var ifStatement = parseIf(parser, tree, outer);

		return createIfStatement(ifStatement);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_while)) {
		var whileStatement = parseWhile(tree, outer);

		return createWhileStatement(whileStatement);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_type)) {
		var typeDefinition = parseTypeDefinition(parser, tree);

		addType(typeList, typeDefinition);

		return createTypeStatement(typeDefinition);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_import)) {
		var importStatement = parseImport(parser, tree);

		addImport(importList, importStatement);

		return createImportStatement(importStatement);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_return)) {
		var returnStatement = parseReturn(tree);

		return createReturnStatement(returnStatement);
	} else if (isOperator(tree.lexer.current.operator, "{")) {
		var blockId = parseBlock(tree, outer);

		return createBlockStatement(blockId, tree.blocks.list[blockId].region);
	}

	var operation = parseExpression(parser, tree, PREC_assignment);
	var semicolon = consumeOperator(parser, tree, ";", (bool)0);
	var expression = createExpression(operation, semicolon);

	return createExpressionStatement(expression);
}

func parse(Parser parser, str fileName, str outerName) -> SyntaxTree {
    if (outerName != (str)0) {
	var filePath = getLocalFilePath(outerName, fileName);
	fileName = getFullPathString(filePath);
    }

	var tree = findSyntaxTree(parser.files, fileName);
	if (tree != (SyntaxTree)0) {
	    return tree;
	}

	tree = createSyntaxTree(fileName, parser.numAnds, parser.numOrs);

	while (tree.lexer.current.isEOF != (bool)1) {
		var statement = parseStatement(parser, tree, tree.types, tree.functions, tree.variables, tree.imports, (Block)0);
		addStatement(tree.statements, statement);
	}

	addSyntaxTree(parser.files, tree);

	return tree;
}

func parseImports(Parser parser, SyntaxTree tree) {
    if (tree.importTrees != (SyntaxTree[])0) {
	return;
    }

    tree.importTrees = (SyntaxTree[])malloc(8 * tree.imports.size);

    var i = 0;
    while (i < tree.imports.size) {
	var importObj = tree.imports.list[i];
	var name = strndup((str)((int)importObj.fileName.value + 1), strlen(importObj.fileName.value) - 2);

	var importTree = parse(parser, name, tree.fileName);
	tree.importTrees[i] = importTree;
	i = i + 1;
    }
}

func findFunctionInParser(Parser parser, SyntaxTree tree, Block block, str name) -> FunctionDefinition {
    var function = (FunctionDefinition)0;

    if (block != (Block)0) {
	function = findFunctionInBlock(block, name);
    }

    if (function == (FunctionDefinition)0) {
	function = findFunction(tree.functions, name);
    }

    if (function == (FunctionDefinition)0) {
	function = findFunction(parser.functions, name);
    }

    var i = 0;
    while (i < tree.imports.size && function == (FunctionDefinition)0) {
	function = findFunction(tree.importTrees[i].functions, name);
	i = i + 1;
    }

    return function;
}

func findTypeInParser(Parser parser, SyntaxTree tree, Block block, str name) -> TypeDefinition {
    var typeDef = (TypeDefinition)0;

    if (block != (Block)0) {
	typeDef = findTypeInBlock(block, name);
    }

    if (typeDef == (TypeDefinition)0) {
	typeDef = findType(tree.types, name);
    }

    if (typeDef == (TypeDefinition)0) {
	typeDef = findType(parser.types, name);
    }

    var i = 0;
    while (i < tree.imports.size && typeDef == (TypeDefinition)0) {
	typeDef = findType(tree.importTrees[i].types, name);
	i = i + 1;
    }

    return typeDef;
}

func getTypeDefinitionFromType(Parser parser, SyntaxTree tree, Block block, Type typeObj) -> TypeDefinition {
    var typeDef = findTypeInParser(parser, tree, block, typeObj.name.name);

    var i = 0;
    while (i < typeObj.brackets.size) {
	typeDef = createArrayFrom((str)0, typeDef);
	i = i + 2;
    }

    return typeDef;
}

func getSizeFromType(Parser parser, SyntaxTree tree, Block block, TypeDefinition typeObj) -> int {
    if (typeObj.arrayType != (TypeDefinition)0) {
	return 8;
    }

    if (typeObj.properties.size == 0) {
	return typeObj.size;
    }

    var sum = 0;
    var i = 0;
    while (i < typeObj.properties.size) {
	var propertyType = getTypeDefinitionFromType(parser, tree, block, typeObj.properties.list[i].typeName);
	sum = sum + getSizeFromType(parser, tree, block, propertyType);
	i = i + 1;
    }

    return sum;
}

func getPropertyOffset(Parser parser, SyntaxTree tree, Block block, TypeDefinition typeObj, str propertyName) -> int {
    var sum = 0;
    var i = 0;
    while (i < typeObj.properties.size) {
	var property = typeObj.properties.list[i];
	if (streq(property.name.name, propertyName)) {
	    return sum;
	}

	var propertyType = getTypeDefinitionFromType(parser, tree, block, property.typeName);
	sum = sum + getSizeFromType(parser, tree, block, propertyType);
	i = i + 1;
    }

    return -1;
}

func createVariableFromParameter(Parser parser, SyntaxTree tree, Block block, Parameter parameter, int position) -> VariableDefinition {
    var variable = (VariableDefinition)malloc(sizeof(VariableDefinition));

    variable.region = parameter.region;
    variable.keyword = (Name)0;
    variable.name = parameter.name;
    variable.equalSign = (Operator)0;
    variable.value = (Operation)0;
    variable.semicolon = (Operator)0;

    variable.depth = block.depth;
    variable.position = position;
    
    variable.variableType = getTypeDefinitionFromType(parser, tree, block, parameter.parameterType);

    return variable;
}

func findVariableInParameters(Parser parser, SyntaxTree tree, Block block, FunctionDefinition function, str name) -> VariableDefinition {
    var i = 0;
    while (i < function.parameters.size) {
	if (streq(function.parameters.list[i].name.name, name)) {
	    return createVariableFromParameter(parser, tree, block, function.parameters.list[i], i);
	}
	i = i + 1;
    }

    return (VariableDefinition)0;
}

func findVariableInBlock(Parser parser, SyntaxTree tree, Block block, str name) -> VariableDefinition {
    var variable = findVariable(block.variables, name);

    if (variable == (VariableDefinition)0 && block.function != (FunctionDefinition)0) {
	variable = findVariableInParameters(parser, tree, block, block.function, name);
    }

    if (variable == (VariableDefinition)0 && block.outer != (Block)0) {
	return findVariableInBlock(parser, tree, block.outer, name);
    }

    return variable;
}

func findVariableInParser(Parser parser, SyntaxTree tree, Block block, str name) -> VariableDefinition {
    var variable = (VariableDefinition)0;

    if (block != (Block)0) {
	variable = findVariableInBlock(parser, tree, block, name);
    }

    if (variable == (VariableDefinition)0) {
	variable = findVariable(tree.variables, name);
    }

    if (variable == (VariableDefinition)0) {
	variable = findVariable(parser.variables, name);
    }

    var i = 0;
    while (i < tree.imports.size && variable == (VariableDefinition)0) {
	variable = findVariable(tree.importTrees[i].variables, name);
	i = i + 1;
    }

    return variable;
}

func bindName(Parser parser, SyntaxTree tree, Name name, Block block) {
    var function = findFunctionInParser(parser, tree, block, name.name);
    if (function != (FunctionDefinition)0) {
	name.definitionRegion = function.region;
	return;
    }

    var typeDef = findTypeInParser(parser, tree, block, name.name);
    if (typeDef != (TypeDefinition)0) {
	name.definitionRegion = typeDef.region;
	return;
    }

    var variable = findVariableInParser(parser, tree, block, name.name);
    if (variable != (VariableDefinition)0) {
	name.definitionRegion = variable.region;
	return;
    }

    printPosition(name.region.start);
    print("could not find name: '");
    print(name.name);
    print("'\n");
}

func bindNamesInType(Parser parser, SyntaxTree tree, Type typeObj, Block block) {
    bindName(parser, tree, typeObj.name, block);
}

func bindNamesInOperation(Parser parser, SyntaxTree tree, Operation operation, Block block) {
    if (operation.left != (Operation)0) {
	bindNamesInOperation(parser, tree, operation.left, block);
    }

    if (operation.right != (Operation)0) {
	if (operation.operator == (Operator)0 || isOperator(operation.operator, ".") != (bool)1) {
	    bindNamesInOperation(parser, tree, operation.right, block);
	}
    }

    if (operation.sizeOf != (SizeOf)0) {
	bindNamesInType(parser, tree, operation.sizeOf.typeObj, block);
    }

    if (operation.castType != (Type)0) {
	bindNamesInType(parser, tree, operation.castType, block);
    }

    if (operation.value != (Value)0 && operation.value.name != (Name)0) {
	bindName(parser, tree, operation.value.name, block);
    }
}

func bindNamesInExpression(Parser parser, SyntaxTree tree, Expression expression, Block block) {
    bindNamesInOperation(parser, tree, expression.operation, block);
}

func bindNamesInElseIf(Parser parser, SyntaxTree tree, ElseIf elseIf, Block block) {
    if (elseIf.condition != (Operation)0) {
	bindNamesInOperation(parser, tree, elseIf.condition, block);
    }
}

func bindNamesInIf(Parser parser, SyntaxTree tree, If ifStatement, Block block) {
    if (ifStatement.condition != (Operation)0) {
	bindNamesInOperation(parser, tree, ifStatement.condition, block);
    }

    var i = 0;
    while (i < ifStatement.elseIfs.size) {
	bindNamesInElseIf(parser, tree, ifStatement.elseIfs.list[i], block);
	i = i + 1;
    }
}

func bindNamesInWhile(Parser parser, SyntaxTree tree, While whileStatement, Block block) {
    if (whileStatement.condition != (Operation)0) {
	bindNamesInOperation(parser, tree, whileStatement.condition, block);
    }
}

func bindNamesInFunctionDefinition(Parser parser, SyntaxTree tree, FunctionDefinition function, Block block) {
    var i = 0;
    while (i < function.parameters.size) {
	bindNamesInType(parser, tree, function.parameters.list[i].parameterType, block);
	i = i + 1;
    }
}

func bindNamesInTypeDefinition(Parser parser, SyntaxTree tree, TypeDefinition typeDef, Block block) {
    var i = 0;
    while (i < typeDef.properties.size) {
	bindNamesInType(parser, tree, typeDef.properties.list[i].typeName, block);
	i = i + 1;
    }
}

func bindNamesInReturn(Parser parser, SyntaxTree tree, Return returnStatement, Block block) {
    if (returnStatement.expression != (Operation)0) {
	bindNamesInOperation(parser, tree, returnStatement.expression, block);
    }
}

func bindNamesInStatementList(Parser parser, SyntaxTree tree, StatementList list, Block block) {
    var i = 0;
    while (i < list.size) {
	var statement = list.list[i];
	if (statement.expression != (Expression)0) {
	    bindNamesInExpression(parser, tree, statement.expression, block);
	} else if (statement.ifStatement != (If)0) {
	    bindNamesInIf(parser, tree, statement.ifStatement, block);
	} else if (statement.whileStatement != (While)0) {
	    bindNamesInWhile(parser, tree, statement.whileStatement, block);
	} else if (statement.variable != (VariableDefinition)0) {
	    bindNamesInOperation(parser, tree, statement.variable.value, block);
	} else if (statement.function != (FunctionDefinition)0) {
	    bindNamesInFunctionDefinition(parser, tree, statement.function, block);
	} else if (statement.typeStatement != (TypeDefinition)0) {
	    bindNamesInTypeDefinition(parser, tree, statement.typeStatement, block);
	} else if (statement.returnStatement != (Return)0) {
	    bindNamesInReturn(parser, tree, statement.returnStatement, block);
	}

	i = i + 1;
    }
}

func bindNames(Parser parser, str fileName) {
    var tree = (SyntaxTree)0;

    var i = 0;
    while (i < parser.files.size) {
	if (streq(parser.files.list[i].fileName, fileName)) {
	    tree = parser.files.list[i];
	}
	i = i + 1;
    }

    if (tree == (SyntaxTree)0) {
	print("no tree has been created for the file '");
	print(fileName);
	print("'\n");
	return;
    }

    parseImports(parser, tree);

    bindNamesInStatementList(parser, tree, tree.statements, (Block)0);

    i = 0;
    while (i < tree.blocks.size) {
	bindNamesInStatementList(parser, tree, tree.blocks.list[i].statements, tree.blocks.list[i]);
	i = i + 1;
    }
}

func compareTypes(Parser parser, TypeDefinition a, TypeDefinition b) -> bool {
    return a == b || b == parser.any;
}

func checkTypesInName(Parser parser, SyntaxTree tree, Block block, Name name) -> TypeDefinition {
    var variable = findVariableInParser(parser, tree, block, name.name);

    if (variable == (VariableDefinition)0) {
	printPosition(name.region.start);
	print("can not find variable '");
	print(name.name);
	print("'\n");
	return (TypeDefinition)0;
    }

    if (variable.variableType == (TypeDefinition)0) {
	printPosition(name.region.start);
	print(" the type of variable '");
	print(variable.name.name);
	print("' is not defined\n");
    }

    return variable.variableType;
}

func checkTypesInValue(Parser parser, SyntaxTree tree, Block block, Value value) -> TypeDefinition {
    if (value.name != (Name)0) {
	return checkTypesInName(parser, tree, block, value.name);
    }

    if (value.number != (Number)0) {
	return parser.int;
    }

    if (value.character != (Character)0) {
	return parser.char;
    }

    if (value.string != (String)0) {
	value.string.id = addUniqueString(parser.strings, value.string.value);
	return parser.str;
    }

    print("value object is in an invalid state\n");
    return (TypeDefinition)0;
}

func checkTypesInSizeOf(Parser parser, SyntaxTree tree, Block block, SizeOf sizeOf) -> TypeDefinition {
    if (getTypeDefinitionFromType(parser, tree, block, sizeOf.typeObj) == (TypeDefinition)0) {
	printPosition(sizeOf.typeObj.region.start);
	print(" can not find type with this name\n");
    }

    return parser.int;
}

func checkTypesInOperation(Parser parser, SyntaxTree tree, Block block, Operation operation) -> TypeDefinition {
    func getArgumentTypes(Parser parser, SyntaxTree tree, Block block, TypeList list, Operation operation) {
	if (isOperator(operation.operator, ",")) {
	    getArgumentTypes(parser, tree, block, list, operation.left);
	    var argumentType = checkTypesInOperation(parser, tree, block, operation.right);
	    addType(list, argumentType);
	    return;
	}

	var argumentType = checkTypesInOperation(parser, tree, block, operation);
	addType(list, argumentType);
    }

    func checkTypesInFunctionCall(Parser parser, SyntaxTree tree, Block block, Operation call) -> TypeDefinition {
	var functionName = call.left.value.name;
	var function = findFunctionInParser(parser, tree, block, functionName.name);

	if (function == (FunctionDefinition)0) {
	    printPosition(functionName.region.start);
	    print(" can not find function with name '");
	    print(functionName.name);
	    print("'\n");
	    return (TypeDefinition)0;
	}

	var argumentList = createTypeList();
	if (operation.right != (Operation)0) {
	    getArgumentTypes(parser, tree, block, argumentList, operation.right);
	}

	var expectedList = createTypeList();
	var i = 0;
	while (i < function.parameters.size) {
	    var expectedType = getTypeDefinitionFromType(parser, tree, block, function.parameters.list[i].parameterType);
	    addType(expectedList, expectedType);
	    i = i + 1;
	}

	i = 0;
	var j = 0;
	var typesMatching = (bool)1;
	while (i < expectedList.size) {
	    var expectedType = expectedList.list[i];
	    var argumentType = (TypeDefinition)0;
	    if (j > argumentList.size) {
		i = expectedList.size;
	    } else {
		argumentType = argumentList.list[j];
	    }

	    if (compareTypes(parser, argumentType, expectedType)) {
		j = j + 1;
	    } else {
		typesMatching = (bool)0;
	    }
	    i = i + 1;
	}

	if (typesMatching != (bool)1) {
	    printPosition(call.operator.position);
	    print(" arguments do not match\n");
	    print("[NOTE] expected: ");
	    printTypeList(expectedList);
	    print(", got: ");
	    printTypeList(argumentList);
	    print("\n");
	}

	if (function.returnType == (ReturnType)0) {
	    return parser.null;
	}

	return getTypeDefinitionFromType(parser, tree, block, function.returnType.returnType);
    }

    func checkTypesInProperty(Parser parser, SyntaxTree tree, Block block, Operation operation) -> TypeDefinition {
	if (isVariable(operation.left) != (bool)1) {
	    printPosition(operation.operator.position);
	    print(" can not read a property from a value that is not a variable\n");
	    return (TypeDefinition)0;
	}

	var typeObj = checkTypesInOperation(parser, tree, block, operation.left);

	if (typeObj == (TypeDefinition)0) {
	    printPosition(operation.left.region.start);
	    print(" type of struct is undefined\n");
	    return (TypeDefinition)0;
	}
	
	var rightValue = operation.right.value;
	if (rightValue == (Value)0 || rightValue.name == (Name)0) {
	    printPosition(operation.right.region.start);
	    print(" expected an identifier after '.' operator\n");
	    return (TypeDefinition)0;
	}

	var property = findProperty(typeObj.properties, rightValue.name.name);
	if (property == (Property)0) {
	    printPosition(operation.right.region.start);
	    print(" could not find property with name '");
	    print(rightValue.name.name);
	    print("'\n");
	    return (TypeDefinition)0;
	}

	return getTypeDefinitionFromType(parser, tree, block, property.typeName);
    }

    if (operation == (Operation)0) {
	print("operation is null\n");
	return (TypeDefinition)0;
    }

    if (operation.value != (Value)0) {
	return checkTypesInValue(parser, tree, block, operation.value);
    }

    if (operation.sizeOf != (SizeOf)0) {
	return checkTypesInSizeOf(parser, tree, block, operation.sizeOf);
    }

    if (isOperator(operation.operator, "(") && operation.left != (Operation)0) {
	return checkTypesInFunctionCall(parser, tree, block, operation);
    }

    if (isOperator(operation.operator, ".")) {
	return checkTypesInProperty(parser, tree, block, operation);
    }

    if (isOperator(operation.operator, "-") && operation.left == (Operation)0) {
	var rightType = checkTypesInOperation(parser, tree, block, operation.right);

	if (rightType != parser.int) {
	    printPosition(operation.right.region.start);
	    print(" expected type 'int' for the unary '-' operation\n");
        }
	
	return parser.int;
    }

    var leftType = (TypeDefinition)0;
    var rightType = (TypeDefinition)0;

    if (operation.left != (Operation)0) {
	leftType = checkTypesInOperation(parser, tree, block, operation.left);
    }

    if (operation.right != (Operation)0) {
	rightType = checkTypesInOperation(parser, tree, block, operation.right);
    }

    //TODO: handle castType, and check other types

    if (isOperator(operation.operator, "<") ||
	isOperator(operation.operator, ">") ||
	isOperator(operation.operator, "<=") ||
	isOperator(operation.operator, ">=") ||
	isOperator(operation.operator, "==") ||
	isOperator(operation.operator, "!=")) {
	if (leftType != rightType) {
	    printPosition(operation.operator.position);
	    print(" can not compare values of different types\n");
	    print("[NOTE] types where: '");
	    printType(leftType);
	    print("' and '");
	    printType(rightType);
	    print("'\n");
	}
	return parser.bool;
    } else if (isOperator(operation.operator, "[")) {
	if (isVariable(operation.left) != (bool)1) {
	    printPosition(operation.operator.position);
	    print(" can not index from a value that is not a variable\n");
	    return (TypeDefinition)0;
	}

	if (leftType == (TypeDefinition)0) {
	    printPosition(operation.operator.position);
	    print(" type of list is null\n");
	    return (TypeDefinition)0;
	}

	if (rightType != parser.int) {
	    printPosition(operation.right.region.start);
	    print(" expected list index to be of type 'int'\n");
	    return (TypeDefinition)0;
	}

	return leftType.arrayType;
    } else if (isOperator(operation.operator, "+")) {
	if (leftType == parser.int) {
	    if (rightType == parser.int) {
		return parser.int;
	    } else if (rightType == parser.char) {
		return parser.char;
	    } else {
		printPosition(operation.operator.position);
		print(" can not add values of type 'int' and '");
		printType(rightType);
		print("'\n");
	    }
	} else if (leftType == parser.char) {
	    if (rightType == parser.int) {
		return parser.char;
	    } else {
		printPosition(operation.operator.position);
		print(" can not add values of type 'char' and '");
		printType(rightType);
		print("'\n");
	    }
	} else {
	    printPosition(operation.operator.position);
	    print(" can not add values of type '");
	    printType(leftType);
	    print("' and '");
	    printType(rightType);
	    print("'\n");
	}

	return (TypeDefinition)0;
    } else if (isOperator(operation.operator, "-")) {
	if (leftType == parser.int) {
	    if (rightType == parser.int) {
		return parser.int;
	    } else {
		printPosition(operation.operator.position);
		print(" can not subtract value of type '");
		printType(rightType);
		print("' from 'int'\n");
	    }
	} else if (leftType == parser.char) {
	    if (rightType == parser.int) {
		return parser.char;
	    } else if (rightType == parser.char) {
		return parser.int;
	    } else {
		printPosition(operation.operator.position);
		print(" can not subtract value of type '");
		printType(rightType);
		print("' from 'char'\n");
	    }
	} else {
	    printPosition(operation.operator.position);
	    print(" can not subtract value of type '");
	    printType(rightType);
	    print("' from '");
	    printType(leftType);
	    print("'\n");
	}

	return (TypeDefinition)0;
    } else if (isOperator(operation.operator, "*") ||
		isOperator(operation.operator, "&") ||
		isOperator(operation.operator, "|") ||
		isOperator(operation.operator, "<<") ||
		isOperator(operation.operator, ">>")) {
	if (leftType != parser.int || rightType != parser.int) {
	    printPosition(operation.operator.position);
	    print(" can not perform operation: '");
	    print(operation.operator.name);
	    print("' on values of type: '");
	    printType(leftType);
	    print("', and '");
	    printType(rightType);
	    print("'\n");
	}

	return parser.int;
    } else if (isOperator(operation.operator, "(")) {
	var typeObj = checkTypesInOperation(parser, tree, block, operation.right);

	if (operation.castType != (Type)0) {
	    return getTypeDefinitionFromType(parser, tree, block, operation.castType);
	}

	return typeObj;
    } else if (isOperator(operation.operator, "=")) {
	if (isVariable(operation.left) != (bool)1) {
	    printPosition(operation.operator.position);
	    print(" can not assign a value to a constant\n");
	    return (TypeDefinition)0;
	}

	if (leftType != rightType) {
	    printPosition(operation.operator.position);
	    print(" can not assign a value with a different type\n");
	    print("[NOTE] expected: '");
	    printType(leftType);
	    print("', got: '");
	    printType(rightType);
	    print("'\n");
	}

	return (TypeDefinition)0;
    } else if (isOperator(operation.operator, "&&") ||
		isOperator(operation.operator, "||")) {
	if (leftType != parser.bool || rightType != parser.bool) {
	    printPosition(operation.operator.position);
	    print(" can not perform an 'and' or 'or' operation on values of type '");
	    printType(leftType);
	    print("' and '");
	    printType(rightType);
	    print("'\n");
	}
	return parser.bool;
    } else {
	printPosition(operation.region.start);
	print(" do not support type checking for '");
	print(operation.operator.name);
	print("' operator yet\n");
    }

    return (TypeDefinition)0;
}

func checkTypesInExpression(Parser parser, SyntaxTree tree, Block block, Expression expression) {
    checkTypesInOperation(parser, tree, block, expression.operation);
}

func checkTypesInIf(Parser parser, SyntaxTree tree, Block block, If ifStatement) {
    var conditionType = checkTypesInOperation(parser, tree, block, ifStatement.condition);

    if (conditionType != parser.bool) {
	printPosition(ifStatement.region.start);
	print(" expected if condition to be of type boolean\n");
    }

    var i = 0;
    while (i < ifStatement.elseIfs.size) {
	var conditionType = checkTypesInOperation(parser, tree, block, ifStatement.elseIfs.list[i].condition);

	if (conditionType != parser.bool) {
	    printPosition(ifStatement.elseIfs.list[i].region.start);
	    print(" expected else if condition to be of type boolean\n");
	}
	i = i + 1;
    }
}

func checkTypesInWhile(Parser parser, SyntaxTree tree, Block block, While whileStatement) {
    var conditionType = checkTypesInOperation(parser, tree, block, whileStatement.condition);

    if (conditionType != parser.bool) {
	printPosition(whileStatement.region.start);
	print(" expected while condition to be of type boolean\n");
    }
}

func checkTypesInVariable(Parser parser, SyntaxTree tree, Block block, VariableDefinition variable) {
    var variableType = checkTypesInOperation(parser, tree, block, variable.value);

    if (variableType == (TypeDefinition)0) {
	printPosition(variable.value.region.start);
	print(" type is undefined\n");
    }

    variable.variableType = variableType;
}

func checkTypesInReturn(Parser parser, SyntaxTree tree, Block block, Return returnStatement) {
    var returnType = parser.null;
    if (returnStatement.expression != (Operation)0) {
	returnType = checkTypesInOperation(parser, tree, block, returnStatement.expression);
    }
    
    var function = getBlockFunction(block);
    if (function == (FunctionDefinition)0) {
	printPosition(returnStatement.region.start);
	print(" can not return from outside a function\n");
	return;
    }

    if (function.returnType == (ReturnType)0) {
	if (returnType != parser.null) {
	    printPosition(returnStatement.expression.region.start);
	    print(" can not return a value from a null function\n");
	}
	return;
    }

    var expectedType = getTypeDefinitionFromType(parser, tree, block, function.returnType.returnType);

    if (returnType != expectedType) {
	printPosition(returnStatement.expression.region.start);
	print(" expected type '");
	printType(expectedType);
	print("', got '");
	printType(returnType);
	print("'\n");
	return;
    }
}

func checkTypesInStatementList(Parser parser, SyntaxTree tree, Block block, StatementList list) {
    var i = 0;
    while (i < list.size) {
	var statement = list.list[i];
	if (statement.expression != (Expression)0) {
	    checkTypesInExpression(parser, tree, block, statement.expression);
	} else if (statement.ifStatement != (If)0) {
	    checkTypesInIf(parser, tree, block, statement.ifStatement);
	} else if (statement.whileStatement != (While)0) {
	    checkTypesInWhile(parser, tree, block, statement.whileStatement);
	} else if (statement.variable != (VariableDefinition)0) {
	    checkTypesInVariable(parser, tree, block, statement.variable);
	} else if (statement.returnStatement != (Return)0) {
	    checkTypesInReturn(parser, tree, block, statement.returnStatement);
	}

	i = i + 1;
    }
}

func checkTypes(Parser parser, SyntaxTree tree) {
    if (tree == (SyntaxTree)0) {
	print("syntax tree is null\n");
	return;
    }

    checkTypesInStatementList(parser, tree, (Block)0, tree.statements);

    var i = 0;
    while (i < tree.blocks.size) {
	var block = tree.blocks.list[i];
	checkTypesInStatementList(parser, tree, block, block.statements);
	i = i + 1;
    }
}

func listFunctions(Parser parser) -> FunctionList {
    var list = createFunctionList();

    extendFunctionList(list, parser.functions);

    var i = 0;
    while (i < parser.files.size) {
	var tree = parser.files.list[i];
	extendFunctionList(list, tree.functions);

	var j = 0;
	while (j < tree.blocks.size) {
	    var block = tree.blocks.list[i];
	    extendFunctionList(list, block.functions);
	    j = j + 1;
	}
	i = i + 1;
    }

    return list;
}
