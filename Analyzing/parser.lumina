import "block.lumina"
import "type.lumina"
import "lexer.lumina"


type Parser {
	BlockList blocks;
	Lexer lexer;
	Token current;
}

func createParser(str fileName) -> Parser {
	var parser = (Parser)malloc(sizeof(Parser));

	parser.blocks = createBlockList();
	parser.lexer = createLexer(fileName);
	parser.current = nextToken(parser.lexer);

	return parser;
}

func next(Parser parser) {
	parser.current = nextToken(parser.lexer);
}

func parseType(Parser parser) -> Type {
	var name = parser.current.name;

	next(parser);
	var brackets = createOperatorList();
	while (isOperator(parser.current.operator, "[")) {
		addOperator(brackets, parser.current.operator);

		next(parser);
		if (isOperator(parser.current.operator, "]") != (bool)1) {
			print("expected ']' after '[' in list definition\n");
		}
		addOperator(brackets, parser.current.operator);

		next(parser);
	}

	return createType(name, brackets);
}

func parseProperty(Parser parser) -> Property {
	var propertyType = parseType(parser);

	var propertyName = parser.current.name;

	next(parser);
	var semicolon = parser.current.operator;
	
	next(parser);

	return createProperty(propertyType, propertyName, semicolon);
}

func parseTypeDefinition(Parser parser) -> TypeDefinition {
	var keyword = parser.current.name;

	next(parser);
	var typeName = parser.current.name;

	next(parser);
	var lbrace = parser.current.operator;

	var properties = createPropertyList();
	next(parser);
	while (isOperator(parser.current.operator, "}") != (bool)1) {
		var property = parseProperty(parser);
		addProperty(properties, property);
	}

	var rbrace = parser.current.operator;

	next(parser);

	return createTypeDefinition(keyword, typeName, lbrace, properties, rbrace);
}

func parseUnary(Parser parser) -> Operation {
	func parseNegative(Parser parser) -> Operation {
		var operator = parser.current.operator;
		next(parser);

		var operation = parseUnary(parser);
		return createUnaryOperation(operator, operation);
	}

	var value = (Value)0;

	if (isNumber(parser.current)) {
		value = createValueFromNumber(parser.current.number);
	} else if (isCharacter(parser.current)) {
		value = createValueFromCharacter(parser.current.character);
	} else if (isString(parser.current)) {
		value = createValueFromString(parser.current.string);
	} else if (isIdentifier(parser.current.name)) {
		value = createValueFromIdentifier(parser.current.name);
	}

	if (value != (Value)0) {
		next(parser);
		return createOperationFromValue(value);
	}

	if (isOperator(parser.current.operator, "-")) {
		return parseNegative(parser);
	}

	if (isComment(parser.current)) {
		print("is comment\n");
	} else {
		if (parser.current.operator == (Operator)0) {
			print("operator is null\n");
		} else {
			printPosition(parser.current.operator.position);
			print(" '");
			print(parser.current.operator.name);
			print("', ");
		}

		print("do not recognise as unary\n");
	}

	next(parser);
	return (Operation)0;
}

func parseBlock(Parser parser) -> Block {
	var lbrace = parser.current.operator;

	while (isOperator(parser.current.operator, "}") != (bool)1) {
		next(parser);
	}

	var rbrace = parser.current.operator;
	var block = createBlock(lbrace, rbrace);
	addBlock(parser.blocks, block);

	return block;
}

func parseExpression(Parser parser) {
	parseUnary(parser);
}

func parseStatement(Parser parser) {
	if (isKeyword(parser.current.name, KEYWORD_var)) {
		print("do not support var yet\n");
		next(parser);
	} else if (isKeyword(parser.current.name, KEYWORD_const)) {
		print("do not support const yet\n");
		next(parser);
	} else if (isKeyword(parser.current.name, KEYWORD_func)) {
		print("do not support func yet\n");
		next(parser);
	} else if (isKeyword(parser.current.name, KEYWORD_if)) {
		print("do not support if yet\n");
		next(parser);
	} else if (isKeyword(parser.current.name, KEYWORD_else)) {
		print("do not support else yet\n");
		next(parser);
	} else if (isKeyword(parser.current.name, KEYWORD_while)) {
		print("do not support while yet\n");
		next(parser);
	} else if (isKeyword(parser.current.name, KEYWORD_type)) {
		parseTypeDefinition(parser);
	} else if (isKeyword(parser.current.name, KEYWORD_import)) {
		print("do not support import yet\n");
		next(parser);
	} else if (isKeyword(parser.current.name, KEYWORD_return)) {
		print("do not support return yet\n");
		next(parser);
	} else if (isKeyword(parser.current.name, KEYWORD_sizeof)) {
		print("do not support sizeof yet\n");
		next(parser);
	} else if (isOperator(parser.current.operator, "{")) {
		parseBlock(parser);
	} else {
		parseExpression(parser);
	}
}

func parse(Parser parser) {
	while (parser.current.isEOF != (bool)1) {
		parseStatement(parser);
	}
}
