import "../std/path.lumina"
import "../std/io.lumina"
import "../std/string.lumina"
import "../std/memory.lumina"
import "../std/syscalls.lumina"

import "block.lumina"
import "type.lumina"
import "function.lumina"
import "variable.lumina"
import "expression.lumina"
import "lexer.lumina"
import "statement.lumina"
import "operation.lumina"
import "operator.lumina"
import "value.lumina"
import "immediate.lumina"
import "if.lumina"
import "while.lumina"
import "whitespace.lumina"
import "name.lumina"
import "identifier.lumina"
import "position.lumina"
import "import.lumina"
import "comment.lumina"
import "definition.lumina"


type SyntaxTree {
	str fileName;
	Lexer lexer;
	BlockList blocks;
	StatementList statements;

	DefinitionList definitions;
	TypeList types;
	FunctionList functions;
	VariableList variables;
	ImportList imports;

	SyntaxTree[] importTrees;
}

type SyntaxTreeList {
	int size;
	int maxSize;
	SyntaxTree[] list;
}

type Parser {
	SyntaxTreeList files;

	DefinitionList definitions;

	TypeList types;
	TypeObj int;
	TypeObj char;
	TypeObj str;
	TypeObj bool;
	TypeObj any;
	TypeObj ptr;
	TypeObj null;
	TypeObj Type;

	FunctionList functions;
	FunctionDefinition syscall;

	VariableList variables;
	Variable argc;
	Variable argv;

	int numIfs;
	int numWhiles;
	int numAnds;
	int numOrs;

	StringList strings;

	bool hadError;
}

func createSyntaxTree(str fileName, int numAnds, int numOrs) -> SyntaxTree {
	var tree = (SyntaxTree)malloc(sizeof(SyntaxTree));

	tree.fileName = fileName;
	tree.blocks = createBlockList();
	tree.lexer = createLexer(fileName);
	next(tree.lexer);

	tree.statements = createStatementList();

	tree.definitions = createDefinitionList();
	tree.types = createTypeList();
	tree.functions = createFunctionList();
	tree.variables = createVariableList();
	tree.imports = createImportList();

	tree.importTrees = (SyntaxTree[])0;

	return tree;
}

func createSyntaxTreeList() -> SyntaxTreeList {
	var list = (SyntaxTreeList)malloc(sizeof(SyntaxTreeList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (SyntaxTree[])malloc(8 * 8);

	return list;
}

func addSyntaxTree(SyntaxTreeList list, SyntaxTree tree) {
	list.list[list.size] = tree;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (SyntaxTree[])realloc((ptr)list.list, 8 * list.maxSize, list.maxSize * 8 * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func findSyntaxTree(SyntaxTreeList list, str fileName) -> SyntaxTree {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].fileName, fileName)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (SyntaxTree)0;
}

func getSyntaxTreeIndex(SyntaxTreeList list, SyntaxTree tree) -> int {
	var i = 0;
	while (i < list.size) {
		if (list.list[i] == tree) {
			return i;
		}
		i = i + 1;
	}
	return -1;
}

func createParser() -> Parser {
	var parser = (Parser)malloc(sizeof(Parser));

	parser.files = createSyntaxTreeList();

	parser.definitions = createDefinitionList();

	parser.types = createTypeList();
	parser.int = createTypeFromString("int", 8);
	parser.char = createTypeFromString("char", 1);
	parser.str = createListType("str", parser.char);
	parser.bool = createTypeFromString("bool", 1);
	parser.any = createTypeFromString("any", 8);
	parser.ptr = createTypeFromString("ptr", 8);
	parser.null = createTypeFromString("null", 8);

	addDefinition(parser.definitions, createDefinitionFromType(parser.int));
	addType(parser.types, parser.int);
	addDefinition(parser.definitions, createDefinitionFromType(parser.char));
	addType(parser.types, parser.char);
	addDefinition(parser.definitions, createDefinitionFromType(parser.str));
	addType(parser.types, parser.str);
	addDefinition(parser.definitions, createDefinitionFromType(parser.bool));
	addType(parser.types, parser.bool);
	addDefinition(parser.definitions, createDefinitionFromType(parser.any));
	addType(parser.types, parser.any);
	addDefinition(parser.definitions, createDefinitionFromType(parser.ptr));
	addType(parser.types, parser.ptr);
	addDefinition(parser.definitions, createDefinitionFromType(parser.null));
	addType(parser.types, parser.null);

	parser.Type = createTypeFromString("Type", 8);
	addProperty(parser.Type.properties, createPropertyFromString("name", parser.str));
	addProperty(parser.Type.properties, createPropertyFromString("size", parser.int));
	addProperty(parser.Type.properties, createPropertyFromString("listOf", parser.Type));
	addProperty(parser.Type.properties, createPropertyFromString("listType", parser.Type));
	//TODO: add properties

	parser.functions = createFunctionList();
	var syscallParameters = createParameterList();

	var i = 0;
	while (i < 7) {
		addParameter(syscallParameters, createParameterFromString(parser.any, (str)0));
		i = i + 1;
	}

	var syscallReturnType = createReturnTypeFromString(parser.any);

	parser.syscall = createFunctionFromString("syscall", syscallParameters, syscallReturnType);
	addDefinition(parser.definitions, createDefinitionFromFunction(parser.syscall));
	addFunction(parser.functions, parser.syscall);

	parser.variables = createVariableList();
	parser.argv = createVariableFromString("argv", 0, 1, createListType((str)0, parser.str));
	parser.argc = createVariableFromString("argc", 0, 2, parser.int);
	addDefinition(parser.definitions, createDefinitionFromVariable(parser.argv));
	addVariable(parser.variables, parser.argv);
	addDefinition(parser.definitions, createDefinitionFromVariable(parser.argc));
	addVariable(parser.variables, parser.argc);

	parser.numIfs = 0;
	parser.numWhiles = 0;
	parser.numAnds = 0;
	parser.numOrs = 0;

	parser.strings = createStringList();

	parser.hadError = (bool)0;

	return parser;
}

func printError(Parser parser, Position position, str message) {
	printPosition(position);
	print(message);
	
	parser.hadError = (bool)1;
}

func consumeOperator(Parser parser, SyntaxTree tree, str operator, bool ignoreError) -> Operator {
	if (isOperator(tree.lexer.current.operator, operator)) {
		var value = tree.lexer.current.operator;
		next(tree.lexer);

		return value;
	}

	if (ignoreError != (bool)1) {
		printError(parser, createPositionFromLexer(tree.lexer), " did not find operator: '");
		print(operator);
		print("'\n");
	}

	return (Operator)0;
}

func consumeKeyword(Parser parser, SyntaxTree tree, int keyword) -> Name {
	if (isKeyword(tree.lexer.current.name, keyword)) {
		var value = tree.lexer.current.name;
		next(tree.lexer);
		return value;
	}

	printError(parser, createPositionFromLexer(tree.lexer), " did not find keyword: '");
	printi(keyword);
	print("'\n");

	return (Name)0;
}

func consumeIdentifier(Parser parser, SyntaxTree tree) -> Name {
	if (isIdentifier(tree.lexer.current.name)) {
		var value = tree.lexer.current.name;
		next(tree.lexer);
		return value;
	}

	printError(parser, createPositionFromLexer(tree.lexer), " did not find identifier\n");

	return (Name)0;
}

func consumeString(Parser parser, SyntaxTree tree) -> String {
	if (isString(tree.lexer.current)) {
		var value = tree.lexer.current.string;
		next(tree.lexer);
		return value;
	}

	printError(parser, createPositionFromLexer(tree.lexer), " did not find string\n");

	return (String)0;
}

func parsePropertyDefinition(Parser parser, SyntaxTree tree) -> PropertyDefinition {
	var propertyType = parseExpression(parser, tree, PREC_index);

	var propertyName = consumeIdentifier(parser, tree);

	var semicolon = consumeOperator(parser, tree, ";", (bool)0);

	return createPropertyDefinition(propertyType, propertyName, semicolon);
}

func parseTypeDefinition(Parser parser, SyntaxTree tree) -> TypeDefinition {
	var keyword = tree.lexer.current.name;

	next(tree.lexer);
	var typeName = tree.lexer.current.name;

	next(tree.lexer);
	var lbrace = tree.lexer.current.operator;

	var properties = createPropertyDefinitionList();
	next(tree.lexer);
	while (isOperator(tree.lexer.current.operator, "}") != (bool)1) {
		var property = parsePropertyDefinition(parser, tree);
		addPropertyDefinition(properties, property);
	}

	var rbrace = tree.lexer.current.operator;

	next(tree.lexer);

	return createTypeDefinition(keyword, typeName, lbrace, properties, rbrace);
}

func parseGroup(Parser parser, SyntaxTree tree) -> Operation {
	var lparen = consumeOperator(parser, tree, "(", (bool)0);

	if (isIdentifier(tree.lexer.current.name)) {
		var typeObj = parseExpression(parser, tree, PREC_index);
		var rparen = consumeOperator(parser, tree, ")", (bool)0);

		var operation = parseExpression(parser, tree, PREC_index);
		return createTypeCast(lparen, typeObj, rparen, operation);
	}

	var operation = parseExpression(parser, tree, PREC_expression);
	var rparen = consumeOperator(parser, tree, ")", (bool)0);

	var group = createUnaryOperation(lparen, operation, rparen);
	return group;
}

func parseNegative(Parser parser, SyntaxTree tree) -> Operation {
	var operator = consumeOperator(parser, tree, "-", (bool)0);

	var operation = parseUnary(parser, tree);
	return createUnaryOperation(operator, operation, (Operator)0);
}

func parseSizeof(Parser parser, SyntaxTree tree) -> Operation {
	var keyword = consumeKeyword(parser, tree, KEYWORD_sizeof);
	var lparen = consumeOperator(parser, tree, "(", (bool)0);
	var typeObj = parseExpression(parser, tree, PREC_index);
	var rparen = consumeOperator(parser, tree, ")", (bool)0);

	var sizeOf = createSizeOf(keyword, lparen, typeObj, rparen);
	return createOperationFromSizeOf(sizeOf);
}

func parseUnary(Parser parser, SyntaxTree tree) -> Operation {
	var value = (Value)0;

	if (isNumber(tree.lexer.current)) {
		value = createValueFromNumber(tree.lexer.current.number);
	} else if (isCharacter(tree.lexer.current)) {
		value = createValueFromCharacter(tree.lexer.current.character);
	} else if (isString(tree.lexer.current)) {
		value = createValueFromString(tree.lexer.current.string);
	} else if (isIdentifier(tree.lexer.current.name)) {
		var identifier = createIdentifierFromName(tree.lexer.current.name);
		value = createValueFromIdentifier(identifier);
	}

	if (value != (Value)0) {
		next(tree.lexer);
		return createOperationFromValue(value);
	}

	if (isKeyword(tree.lexer.current.name, KEYWORD_sizeof)) {
		return parseSizeof(parser, tree);
	}

	if (isOperator(tree.lexer.current.operator, "-")) {
		return parseNegative(parser, tree);
	}

	if (isOperator(tree.lexer.current.operator, "(")) {
		return parseGroup(parser, tree);
	}

	if (tree.lexer.current.operator == (Operator)0) {
		printError(parser, createPositionFromLexer(tree.lexer), " operator is null\n");
	} else {
		printError(parser, tree.lexer.current.operator.position, " '");
		print(tree.lexer.current.operator.name);
		print("', ");
	}

	print("do not recognise as unary\n");

	next(tree.lexer);
	return (Operation)0;
}

func parseIndex(Parser parser, SyntaxTree tree, Operation left) -> Operation {
	var lbracket = consumeOperator(parser, tree, "[", (bool)0);

	if (isOperator(tree.lexer.current.operator, "]")) {
		var rbracket = consumeOperator(parser, tree, "]", (bool)0);
		return createOperation(left, lbracket, (Operation)0, rbracket);
	}

	var index = parseExpression(parser, tree, PREC_expression);
	var rbracket = consumeOperator(parser, tree, "]", (bool)0);

	return createOperation(left, lbracket, index, rbracket);
}

func parseCall(Parser parser, SyntaxTree tree, Operation left) -> Operation {
	var lparen = consumeOperator(parser, tree, "(", (bool)0);

	if (isOperator(tree.lexer.current.operator, ")")) {
		var rparen = consumeOperator(parser, tree, ")", (bool)0);
		return createOperation(left, lparen, (Operation)0, rparen);
	}

	var args = parseExpression(parser, tree, PREC_expression);

	while (isOperator(tree.lexer.current.operator, ",")) {
		var comma = consumeOperator(parser, tree, ",", (bool)0);

		var right = parseExpression(parser, tree, PREC_expression);

		args = createOperation(args, comma, right, (Operator)0);
	}

	var rparen = consumeOperator(parser, tree, ")", (bool)0);

	return createOperation(left, lparen, args, rparen);
}

func parseExpression(Parser parser, SyntaxTree tree, int precedence) -> Operation {
	var operation = parseUnary(parser, tree);

	if (operation == (Operation)0) {
		print("left hand side is null\n");
		return (Operation)0;
	}

	var operator = tree.lexer.current.operator;

	while (operator != (Operator)0 && operator.precedence >= precedence) {
		if (isOperator(operator, "[")) {
			operation = parseIndex(parser, tree, operation);
		} else if (isOperator(operator, "(")) {
			operation = parseCall(parser, tree, operation);
		} else {
			next(tree.lexer);

			var right = parseExpression(parser, tree, operator.precedence + 1);

			if (right == (Operation)0) {
				print("right hand side is null\n");
				return (Operation)0;
			}

			operation = createOperation(operation, operator, right, (Operator)0);
		}

		operator = tree.lexer.current.operator;
	}

	return operation;
}

func parseImport(Parser parser, SyntaxTree tree) -> Import {
	var keyword = consumeKeyword(parser, tree, KEYWORD_import);

	var fileName = consumeString(parser, tree);

	return createImport(keyword, fileName);
}

func parseVariableDefinition(Parser parser, SyntaxTree tree) -> VariableDefinition {
	var keyword = tree.lexer.current.name;
	next(tree.lexer);

	var name = consumeIdentifier(parser, tree);

	var equalSign = consumeOperator(parser, tree, "=", (bool)0);
	var value = parseExpression(parser, tree, PREC_expression);
	var semicolon = consumeOperator(parser, tree, ";", (bool)0);

	return createVariableDefinition(keyword, name, equalSign, value, semicolon);
}

func parseParameterList(Parser parser, SyntaxTree tree) -> ParameterList {
	var list = createParameterList();

	if (isOperator(tree.lexer.current.operator, ")")) {
		return list;
	}

	var parameterType = parseExpression(parser, tree, PREC_index);
	var name = consumeIdentifier(parser, tree);

	while (isOperator(tree.lexer.current.operator, ",")) {
		var comma = consumeOperator(parser, tree, ",", (bool)0);

		var parameter = createParameter(parameterType, name, comma);
		addParameter(list, parameter);

		parameterType = parseExpression(parser, tree, PREC_index);
		name = consumeIdentifier(parser, tree);
	}

	var parameter = createParameter(parameterType, name, (Operator)0);
	addParameter(list, parameter);

	return list;
}

func parseReturnType(Parser parser, SyntaxTree tree) -> ReturnType {
	var rarrow = consumeOperator(parser, tree, "->", (bool)0);
	var typeObj = parseExpression(parser, tree, PREC_index);

	return createReturnType(rarrow, typeObj);
}

func parseBlock(Parser parser, SyntaxTree tree, Block outer, FunctionDefinition function, ImportList importList) -> Block {
	var lbrace = consumeOperator(parser, tree, "{", (bool)0);

	var statementList = createStatementList();

	var definitionList = createDefinitionList();
	var typeList = createTypeList();
	var functionList = createFunctionList();
	var variableList = createVariableList();

	var block = createBlock(lbrace, statementList, definitionList, typeList, functionList, variableList, outer, function);
	addBlock(tree.blocks, block);

	if (block.function != (FunctionDefinition)0) {
		block.depth = block.depth + 1;
	}

	while (isOperator(tree.lexer.current.operator, "}") != (bool)1 || tree.lexer.current.isEOF) {
		var statement = parseStatement(parser, tree, block, definitionList, typeList, functionList, variableList, importList);
		addStatement(statementList, statement);
	}

	var rbrace = consumeOperator(parser, tree, "}", (bool)0);

	setEnd(block, rbrace);

	return block;
}

func parseElseIf(Parser parser, SyntaxTree tree, ElseIfList list, Name elseKeyword, Block outer, ImportList importList) {
	var ifKeyword = consumeKeyword(parser, tree, KEYWORD_if);
	var lparen = consumeOperator(parser, tree, "(", (bool)0);
	var condition = parseExpression(parser, tree, PREC_expression);
	var rparen = consumeOperator(parser, tree, ")", (bool)0);
	var block = parseBlock(parser, tree, outer, (FunctionDefinition)0, importList);
	var endPosition = block.region.end;

	var elseIf = createElseIf(elseKeyword, ifKeyword, lparen, condition, rparen, block, endPosition, parser.numIfs);
	parser.numIfs = parser.numIfs + 1;
	addElseIf(list, elseIf);
}

func parseElse(Parser parser, SyntaxTree tree, Name keyword, Block outer, ImportList importList) -> Else {
	var block = parseBlock(parser, tree, outer, (FunctionDefinition)0, importList);
	var endPosition = block.region.end;

	return createElse(keyword, block, endPosition);
}

func parseIf(Parser parser, SyntaxTree tree, Block outer, ImportList importList) -> If {
	var ifKeyword = consumeKeyword(parser, tree, KEYWORD_if);

	var lparen = consumeOperator(parser, tree, "(", (bool)0);
	var condition = parseExpression(parser, tree, PREC_expression);
	var rparen = consumeOperator(parser, tree, ")", (bool)0);
	var block = (Block)0;
	var endPosition = (Position)0;

	if (isOperator(tree.lexer.current.operator, "{")) {
		block = parseBlock(parser, tree, outer, (FunctionDefinition)0, importList);
		endPosition = block.region.end;
	} else {
		print("expected block after 'if'\n");
	}

	var elseIfs = createElseIfList();

	while (isKeyword(tree.lexer.current.name, KEYWORD_else)) {
		var elseKeyword = consumeKeyword(parser, tree, KEYWORD_else);

		if (isKeyword(tree.lexer.current.name, KEYWORD_if)) {
			parseElseIf(parser, tree, elseIfs, elseKeyword, outer, importList);
		} else {
			var elseObj = parseElse(parser, tree, elseKeyword, outer, importList);
			var ifObj = createIf(ifKeyword, lparen, condition, rparen, block, elseIfs, elseObj, endPosition, parser.numIfs);
			parser.numIfs = parser.numIfs + 1;
			return ifObj;
		}
	}

	var ifObj = createIf(ifKeyword, lparen, condition, rparen, block, elseIfs, (Else)0, endPosition, parser.numIfs);
	parser.numIfs = parser.numIfs + 1;
	return ifObj;
}

func parseWhile(Parser parser, SyntaxTree tree, Block outer, ImportList importList) -> While {
	var keyword = consumeKeyword(parser, tree, KEYWORD_while);

	var lparen = consumeOperator(parser, tree, "(", (bool)0);
	var condition = parseExpression(parser, tree, PREC_expression);
	var rparen = consumeOperator(parser, tree, ")", (bool)0);

	var block = (Block)0;
	var endPosition = (Position)0;

	if (isOperator(tree.lexer.current.operator, "{")) {
		block = parseBlock(parser, tree, outer, (FunctionDefinition)0, importList);
		endPosition = block.region.end;
	} else  {
		print("expected block after while\n");
	}

	var whileObj = createWhile(keyword, lparen, condition, rparen, block, endPosition, parser.numWhiles);
	parser.numWhiles = parser.numWhiles + 1;
	return whileObj;
}

func parseFunctionDefinition(Parser parser, SyntaxTree tree, Block outer, ImportList importList) -> FunctionDefinition {
	var keyword = consumeKeyword(parser, tree, KEYWORD_func);
	var name = consumeIdentifier(parser, tree);

	var lparen = consumeOperator(parser, tree, "(", (bool)0);
	var parameters = parseParameterList(parser, tree);
	var rparen = consumeOperator(parser, tree, ")", (bool)0);

	var returnType = (ReturnType)0;
	if (isOperator(tree.lexer.current.operator, "->")) {
		returnType = parseReturnType(parser, tree);
	}

	var function = createFunctionDefinition(keyword, name, lparen, parameters, rparen, returnType);

	var block = parseBlock(parser, tree, outer, function, importList);
	function.block = block;

	return function;
}

func parseReturn(Parser parser, SyntaxTree tree) -> Return {
	var keyword = consumeKeyword(parser, tree, KEYWORD_return);

	if (isOperator(tree.lexer.current.operator, ";")) {
		var semicolon = consumeOperator(parser, tree, ";", (bool)0);

		return createReturn(keyword, (Operation)0, semicolon);
	}

	var expression = parseExpression(parser, tree, PREC_expression);
	var semicolon = consumeOperator(parser, tree, ";", (bool)0);

	return createReturn(keyword, expression, semicolon);
}

func parseStatement(Parser parser, SyntaxTree tree, Block block, DefinitionList definitionList, TypeList typeList, FunctionList functionList, VariableList variableList, ImportList importList) -> Statement {
	if (isKeyword(tree.lexer.current.name, KEYWORD_var)) {
		var depth = 0;
		if (block != (Block)0) {
			depth = block.depth;
		}

		var size = 0;
		if (depth == 0) {
			size = size + parser.variables.size + 1;

			var i = 1;
			while (i < parser.files.size) {
				var tree = parser.files.list[i];
				size = size + tree.variables.size;

				i = i + 1;
			}

			size = size + tree.variables.size;
		}

		if (block != (Block)0) {
			size = size + block.variables.size;

			var outerBlock = block;
			while (outerBlock.outer != (Block)0 && outerBlock.outer.depth == depth) {
				outerBlock = outerBlock.outer;
				size = size + outerBlock.variables.size;
			}

			if (outerBlock.function != (FunctionDefinition)0) {
				size = size + outerBlock.function.parameters.size + 1;
			}
		}

		var variableDefinition = parseVariableDefinition(parser, tree);
		var variable = createVariableFromDefinition(variableDefinition, depth, size);

		addDefinition(definitionList, createDefinitionFromVariable(variable));
		addVariable(variableList, variable);

		return createVariableStatement(variable);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_const)) {
		var constantDefinition = parseVariableDefinition(parser, tree);
		var constant = createConstantFromDefinition(constantDefinition);

		addDefinition(definitionList, createDefinitionFromVariable(constant));
		addVariable(variableList, constant);
		
		return createVariableStatement(constant);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_func)) {
		var function = parseFunctionDefinition(parser, tree, block, importList);

		addDefinition(definitionList, createDefinitionFromFunction(function));
		addFunction(functionList, function);

		return createFunctionStatement(function);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_if)) {
		var ifStatement = parseIf(parser, tree, block, importList);

		return createIfStatement(ifStatement);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_while)) {
		var whileStatement = parseWhile(parser, tree, block, importList);

		return createWhileStatement(whileStatement);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_type)) {
		var typeDefinition = parseTypeDefinition(parser, tree);
		var typeObj = createTypeFromDefinition(typeDefinition);

		addDefinition(definitionList, createDefinitionFromType(typeObj));
		addType(typeList, typeObj);

		return createTypeStatement(typeObj);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_import)) {
		var importStatement = parseImport(parser, tree);

		addImport(importList, importStatement);

		return createImportStatement(importStatement);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_return)) {
		var returnStatement = parseReturn(parser, tree);

		return createReturnStatement(returnStatement);
	} else if (isOperator(tree.lexer.current.operator, "{")) {
		var innerBlock = parseBlock(parser, tree, block, (FunctionDefinition)0, importList);

		return createBlockStatement(innerBlock, innerBlock.region);
	}

	var operation = parseExpression(parser, tree, PREC_assignment);
	var semicolon = consumeOperator(parser, tree, ";", (bool)0);
	var expression = createExpression(operation, semicolon);

	return createExpressionStatement(expression);
}

func parse(Parser parser, str fileName, str outerName) -> SyntaxTree {
	if (outerName != (str)0) {
		var filePath = getLocalFilePath(outerName, fileName);
		fileName = getFullPathString(filePath);
	}

	var tree = findSyntaxTree(parser.files, fileName);
	if (tree != (SyntaxTree)0) {
		return tree;
	}

	tree = createSyntaxTree(fileName, parser.numAnds, parser.numOrs);

	while (tree.lexer.current.isEOF != (bool)1) {
		var statement = parseStatement(parser, tree, (Block)0, tree.definitions, tree.types, tree.functions, tree.variables, tree.imports);
		addStatement(tree.statements, statement);
	}

	addSyntaxTree(parser.files, tree);

	return tree;
}

func parseImports(Parser parser, SyntaxTree tree) {
	if (tree.importTrees != (SyntaxTree[])0) {
		return;
	}

	tree.importTrees = (SyntaxTree[])malloc(8 * tree.imports.size);

	var i = 0;
	while (i < tree.imports.size) {
		var importObj = tree.imports.list[i];
		var name = strndup((str)((int)importObj.fileName.value + 1), strlen(importObj.fileName.value) - 2);

		var importTree = parse(parser, name, tree.fileName);
		tree.importTrees[i] = importTree;
		i = i + 1;
	}
}

func findDefinitionInBlock(Block block, str name) -> Definition {
	var definition = findDefinition(block.definitions, name);

	if (definition == (Definition)0 && block.outer != (Block)0) {
		return findDefinitionInBlock(block.outer, name);
	}

	return definition;
}

func findDefinitionInParser(Parser parser, SyntaxTree tree, Block block, str name) -> Definition {
	var definition = (Definition)0;

	if (block != (Block)0) {
		definition = findDefinitionInBlock(block, name);
	}

	if (definition == (Definition)0) {
		definition = findDefinition(tree.definitions, name);
	}

	if (definition == (Definition)0) {
		definition = findDefinition(parser.definitions, name);
	}

	var i = 0;
	while (i < tree.imports.size && definition == (Definition)0) {
		definition = findDefinition(tree.importTrees[i].definitions, name);
		i = i + 1;
	}

	return definition;
}

func findFunctionInParser(Parser parser, SyntaxTree tree, Block block, str name) -> FunctionDefinition {
	var function = (FunctionDefinition)0;

	if (block != (Block)0) {
		function = findFunctionInBlock(block, name);
	}

	if (function == (FunctionDefinition)0) {
		function = findFunction(tree.functions, name);
	}

	if (function == (FunctionDefinition)0) {
		function = findFunction(parser.functions, name);
	}

	var i = 0;
	while (i < tree.imports.size && function == (FunctionDefinition)0) {
		function = findFunction(tree.importTrees[i].functions, name);
		i = i + 1;
	}

	return function;
}

func findTypeInParser(Parser parser, SyntaxTree tree, Block block, str name) -> TypeObj {
	var typeDef = (TypeObj)0;

	if (block != (Block)0) {
		typeDef = findTypeInBlock(block, name);
	}

	if (typeDef == (TypeObj)0) {
		typeDef = findType(tree.types, name);
	}

	if (typeDef == (TypeObj)0) {
		typeDef = findType(parser.types, name);
	}

	var i = 0;
	while (i < tree.imports.size && typeDef == (TypeObj)0) {
		typeDef = findType(tree.importTrees[i].types, name);
		i = i + 1;
	}

	return typeDef;
}

func getTypeFromValue(Parser parser, SyntaxTree tree, Block block, Value value) -> TypeObj {
	if (value.identifier == (Identifier)0) {
		printError(parser, value.region.start, " an immediate value is not a type\n");
		return (TypeObj)0;
	}

	if (value.identifier.value == (Definition)0) {
		printError(parser, value.region.start, " can not find definition of type\n");
		return (TypeObj)0;
	}

	if (value.identifier.value.typeObj == (TypeObj)0) {
		printError(parser, value.region.start, " value is not a type\n");
		return (TypeObj)0;
	}

	return value.identifier.value.typeObj;
}

func getTypeFromOperation(Parser parser, SyntaxTree tree, Block block, Operation operation) -> TypeObj {
	if (operation == (Operation)0) {
		print("operation is null in 'getTypeFromOperation'\n");
		exit(1);
	}

	if (operation.value != (Value)0) {
		return getTypeFromValue(parser, tree, block, operation.value);
	}

	if (isOperator(operation.operator, "[") != (bool)1) {
		printError(parser, operation.operator.position, " can not get type object from this operator\n");
		return (TypeObj)0;
	}

	var typeObj = getTypeFromOperation(parser, tree, block, operation.left);

	return createListType((str)0, typeObj);
}

func getSizeFromType(Parser parser, SyntaxTree tree, Block block, TypeObj typeObj) -> int {
	if (typeObj == (TypeObj)0) {
		print("type obj is null in 'getSizeFromType'\n");
		exit(1);
		return 0;
	}

	if (typeObj.properties.size == 0 || typeObj.listType != (TypeObj)0) {
		return typeObj.size;
	}

	var sum = 0;
	var i = 0;
	while (i < typeObj.properties.size) {
		var property = typeObj.properties.list[i];
		var propertyType = getTypeFromOperation(parser, tree, block, property.definition.propertyType);

		if (propertyType == (TypeObj)0) {
			printError(parser, typeObj.definition.properties.list[i].region.start, " property type is null in 'getSizeFromType' in file: '");
			print(tree.fileName);
			print("'\n");
			return 0;
		}

		sum = sum + propertyType.size;
		i = i + 1;
	}

	return sum;
}

func getPropertyOffset(Parser parser, SyntaxTree tree, Block block, TypeObj typeObj, str propertyName) -> int {
	var sum = 0;
	var i = 0;
	while (i < typeObj.properties.size) {
		var property = typeObj.properties.list[i];
		if (streq(property.name, propertyName)) {
			return sum;
		}

		var propertyType = getTypeFromOperation(parser, tree, block, property.definition.propertyType);

		if (propertyType == (TypeObj)0) {
			printError(parser, property.definition.region.start, " property type is null in 'getPropertyDefinitionOffset' in file: '");
			print(tree.fileName);
			print("'\n");
			return 0;
		}

		sum = sum + propertyType.size;
		i = i + 1;
	}

	return -1;
}

func createVariableFromParameter(Parser parser, SyntaxTree tree, Block block, Parameter parameter, int position) -> Variable {
	return createVariableFromString(parameter.name.name, block.depth, position, getTypeFromOperation(parser, tree, block, parameter.parameterType));
}

func findVariableInParameters(Parser parser, SyntaxTree tree, Block block, FunctionDefinition function, str name) -> Variable {
	var i = 0;
	while (i < function.parameters.size) {
		if (streq(function.parameters.list[i].name.name, name)) {
			return createVariableFromParameter(parser, tree, block, function.parameters.list[i], i);
		}
		i = i + 1;
	}

	return (Variable)0;
}

func findVariableInBlock(Parser parser, SyntaxTree tree, Block block, str name) -> Variable {
	var variable = findVariable(block.variables, name);

	if (variable == (Variable)0 && block.function != (FunctionDefinition)0) {
		variable = findVariableInParameters(parser, tree, block, block.function, name);
	}

	if (variable == (Variable)0 && block.outer != (Block)0) {
		return findVariableInBlock(parser, tree, block.outer, name);
	}

	return variable;
}

func findVariableInParser(Parser parser, SyntaxTree tree, Block block, str name) -> Variable {
	var variable = (Variable)0;

	if (block != (Block)0) {
		variable = findVariableInBlock(parser, tree, block, name);
	}

	if (variable == (Variable)0) {
		variable = findVariable(tree.variables, name);
	}

	if (variable == (Variable)0) {
		variable = findVariable(parser.variables, name);
	}

	var i = 0;
	while (i < tree.imports.size && variable == (Variable)0) {
		variable = findVariable(tree.importTrees[i].variables, name);
		i = i + 1;
	}

	return variable;
}

func bindName(Parser parser, SyntaxTree tree, Name name, Block block) {
	var function = findFunctionInParser(parser, tree, block, name.name);
	if (function != (FunctionDefinition)0) {
		name.definitionRegion = function.region;
		return;
	}

	var typeDef = findTypeInParser(parser, tree, block, name.name);
	if (typeDef != (TypeObj)0) {
		if (typeDef.definition != (TypeDefinition)0) {
			name.definitionRegion = typeDef.definition.region;
		}
		return;
	}

	var variable = findVariableInParser(parser, tree, block, name.name);
	if (variable != (Variable)0) {
		if (variable.definition != (VariableDefinition)0) {
			name.definitionRegion = variable.definition.region;
		}
		return;
	}

	printError(parser, name.region.start, "could not find name: '");
	print(name.name);
	print("'\n");
}

func bindIdentifier(Parser parser, SyntaxTree tree, Block block, Identifier identifier) {
	identifier.value = findDefinitionInParser(parser, tree, block, identifier.name);
	if (identifier.value != (Definition)0) {
		return;
	}

	var variable = findVariableInParser(parser, tree, block, identifier.name); // this is because findDefinitionInParser does not yet look for function parameters

	if (variable == (Variable)0) {
		printError(parser, identifier.definition.region.start, " did not find value with name: '");
		print(identifier.name);
		print("'\n");
		return;
	}

	identifier.value = createDefinitionFromVariable(variable);
}

func bindNamesInOperation(Parser parser, SyntaxTree tree, Operation operation, Block block) {
	if (operation.left != (Operation)0) {
		bindNamesInOperation(parser, tree, operation.left, block);
	}

	if (operation.right != (Operation)0) {
		if (operation.operator == (Operator)0 || isOperator(operation.operator, ".") != (bool)1) {
			bindNamesInOperation(parser, tree, operation.right, block);
		}
	}

	if (operation.sizeOf != (SizeOf)0) {
		bindNamesInOperation(parser, tree, operation.sizeOf.typeObj, block);
	}

	if (operation.castType != (Operation)0) {
		bindNamesInOperation(parser, tree, operation.castType, block);
	}

	if (operation.value != (Value)0 && operation.value.identifier != (Identifier)0) {
		bindIdentifier(parser, tree, block, operation.value.identifier);
	}
}

func bindNamesInExpression(Parser parser, SyntaxTree tree, Expression expression, Block block) {
	bindNamesInOperation(parser, tree, expression.operation, block);
}

func bindNamesInElseIf(Parser parser, SyntaxTree tree, ElseIf elseIf, Block block) {
	if (elseIf.condition != (Operation)0) {
		bindNamesInOperation(parser, tree, elseIf.condition, block);
	}
}

func bindNamesInIf(Parser parser, SyntaxTree tree, If ifStatement, Block block) {
	if (ifStatement.condition != (Operation)0) {
		bindNamesInOperation(parser, tree, ifStatement.condition, block);
	}

	var i = 0;
	while (i < ifStatement.elseIfs.size) {
		bindNamesInElseIf(parser, tree, ifStatement.elseIfs.list[i], block);
		i = i + 1;
	}
}

func bindNamesInWhile(Parser parser, SyntaxTree tree, While whileStatement, Block block) {
	if (whileStatement.condition != (Operation)0) {
		bindNamesInOperation(parser, tree, whileStatement.condition, block);
	}
}

func bindNamesInFunctionDefinition(Parser parser, SyntaxTree tree, FunctionDefinition function, Block block) {
	var foundFunction = findFunctionInParser(parser, tree, block, function.name.name);
	if (foundFunction != (FunctionDefinition)0 && foundFunction != function) {
		printError(parser, function.name.region.start, " a function with this name already exists\n");
	}

	if (findVariableInParser(parser, tree, block, function.name.name) != (Variable)0) {
		printError(parser, function.name.region.start, " a variable with this name already exists\n");
	}

	if (findTypeInParser(parser, tree, block, function.name.name) != (TypeObj)0) {
		printError(parser, function.name.region.start, " a type with this name already exists\n");
	}

	var i = 0;
	while (i < function.parameters.size) {
		bindNamesInOperation(parser, tree, function.parameters.list[i].parameterType, block);
		i = i + 1;
	}

	if (function.returnType != (ReturnType)0) {
		bindNamesInOperation(parser, tree, function.returnType.returnType, block);
	}
}

func bindNamesInTypeDefinition(Parser parser, SyntaxTree tree, TypeDefinition typeDef, Block block) {
	var foundType = findTypeInParser(parser, tree, block, typeDef.name.name);
	if (foundType != (TypeObj)0 && foundType.definition != typeDef) {
		printError(parser, typeDef.name.region.start, " a type with this name already exists\n");
	}

	if (findVariableInParser(parser, tree, block, typeDef.name.name) != (Variable)0) {
		printError(parser, typeDef.name.region.start, " a variable with this name already exists\n");
	}

	if (findFunctionInParser(parser, tree, block, typeDef.name.name) != (FunctionDefinition)0) {
		printError(parser, typeDef.name.region.start, " a function with this name already exists\n");
	}

	var i = 0;
	while (i < typeDef.properties.size) {
		bindNamesInOperation(parser, tree, typeDef.properties.list[i].propertyType, block);
		i = i + 1;
	}
}

func bindNamesInVariable(Parser parser, SyntaxTree tree, Variable variable, Block block) {
	var foundVariable = findVariableInParser(parser, tree, block, variable.name);
	if (foundVariable != (Variable)0 && foundVariable.depth != variable.depth && foundVariable != variable) {
		printError(parser, variable.definition.name.region.start, " a variable with this name already exists\n");
	}

	if (findTypeInParser(parser, tree, block, variable.name) != (TypeObj)0) {
		printError(parser, variable.definition.name.region.start, " a type with this name already exists\n");
	}

	if (findFunctionInParser(parser, tree, block, variable.name) != (FunctionDefinition)0) {
		printError(parser, variable.definition.name.region.start, " a function with this name already exists\n");
	}

	bindNamesInOperation(parser, tree, variable.definition.value, block);
}

func bindNamesInReturn(Parser parser, SyntaxTree tree, Return returnStatement, Block block) {
	if (returnStatement.expression != (Operation)0) {
		bindNamesInOperation(parser, tree, returnStatement.expression, block);
	}
}

func bindNamesInStatementList(Parser parser, SyntaxTree tree, StatementList list, Block block) {
	var i = 0;
	while (i < list.size) {
		var statement = list.list[i];
		if (statement.expression != (Expression)0) {
			bindNamesInExpression(parser, tree, statement.expression, block);
		} else if (statement.ifStatement != (If)0) {
			bindNamesInIf(parser, tree, statement.ifStatement, block);
		} else if (statement.whileStatement != (While)0) {
			bindNamesInWhile(parser, tree, statement.whileStatement, block);
		} else if (statement.variable != (Variable)0) {
			bindNamesInVariable(parser, tree, statement.variable, block);
		} else if (statement.function != (FunctionDefinition)0) {
			bindNamesInFunctionDefinition(parser, tree, statement.function, block);
		} else if (statement.typeStatement != (TypeObj)0) {
			bindNamesInTypeDefinition(parser, tree, statement.typeStatement.definition, block);
		} else if (statement.returnStatement != (Return)0) {
			bindNamesInReturn(parser, tree, statement.returnStatement, block);
		}

		i = i + 1;
	}
}

func bindNames(Parser parser, str fileName) {
	var tree = (SyntaxTree)0;

	var i = 0;
	while (i < parser.files.size) {
		if (streq(parser.files.list[i].fileName, fileName)) {
			tree = parser.files.list[i];
		}
		i = i + 1;
	}

	if (tree == (SyntaxTree)0) {
		print("no tree has been created for the file '");
		print(fileName);
		print("'\n");
		return;
	}

	parseImports(parser, tree);

	bindNamesInStatementList(parser, tree, tree.statements, (Block)0);

	i = 0;
	while (i < tree.blocks.size) {
		bindNamesInStatementList(parser, tree, tree.blocks.list[i].statements, tree.blocks.list[i]);
		i = i + 1;
	}
}

func compareTypes(Parser parser, TypeObj a, TypeObj b) -> bool {
	return a == b || b == parser.any;
}

func checkTypesInName(Parser parser, SyntaxTree tree, Block block, Name name) -> TypeObj {
	var variable = findVariableInParser(parser, tree, block, name.name);

	if (variable == (Variable)0) {
		var typeObj = findTypeInParser(parser, tree, block, name.name);
		if (typeObj != (TypeObj)0) {
			return parser.Type;
		}

		printError(parser, name.region.start, "can not find variable '");
		print(name.name);
		print("'\n");
		return (TypeObj)0;
	}

	if (variable.variableType == (TypeObj)0) {
		printError(parser, name.region.start, " the type of variable '");
		print(variable.name);
		print("' is not defined\n");
	}

	return variable.variableType;
}

func checkTypesInValue(Parser parser, SyntaxTree tree, Block block, Value value) -> TypeObj {
	if (value.identifier != (Identifier)0) {
		return checkTypesInName(parser, tree, block, value.identifier.definition);
	}

	if (value.number != (Number)0) {
		return parser.int;
	}

	if (value.character != (Character)0) {
		return parser.char;
	}

	if (value.string != (String)0) {
		value.string.id = addUniqueString(parser.strings, value.string.value);
		return parser.str;
	}

	print("value object is in an invalid state\n");
	return (TypeObj)0;
}

func checkTypesInSizeOf(Parser parser, SyntaxTree tree, Block block, SizeOf sizeOf) -> TypeObj {
	var typeType = checkTypesInOperation(parser, tree, block, sizeOf.typeObj);
	if (typeType != parser.Type) {
		printError(parser, sizeOf.typeObj.region.start, " can not take size of something that is not a type\n");
	}

	if (getTypeFromOperation(parser, tree, block, sizeOf.typeObj) == (TypeObj)0) {
		printError(parser, sizeOf.typeObj.region.start, " can not find type with this name\n");
	}

	return parser.int;
}

func getArgumentTypes(Parser parser, SyntaxTree tree, Block block, TypeList list, Operation operation) {
	if (isOperator(operation.operator, ",")) {
		getArgumentTypes(parser, tree, block, list, operation.left);
		var argumentType = checkTypesInOperation(parser, tree, block, operation.right);
		addType(list, argumentType);
		return;
	}

	var argumentType = checkTypesInOperation(parser, tree, block, operation);
	addType(list, argumentType);
}

func checkTypesInFunctionCall(Parser parser, SyntaxTree tree, Block block, Operation call) -> TypeObj {
	var functionName = call.left.value.identifier;
	var function = findFunctionInParser(parser, tree, block, functionName.name);

	if (function == (FunctionDefinition)0) {
		printError(parser, functionName.definition.region.start, " can not find function with name '");
		print(functionName.name);
		print("'\n");
		return (TypeObj)0;
	}

	var argumentList = createTypeList();
	if (call.right != (Operation)0) {
		getArgumentTypes(parser, tree, block, argumentList, call.right);
	}

	var expectedList = createTypeList();
	var i = 0;
	while (i < function.parameters.size) {
		var parameter = function.parameters.list[i];
		var expectedType = parameter.typeObj;

		if (expectedType == (TypeObj)0 && parameter.parameterType != (Operation)0) {
			expectedType = getTypeFromOperation(parser, tree, block, parameter.parameterType);
		}

		if (expectedType == (TypeObj)0) {
			printError(parser, parameter.region.start, " type definition not found\n");
		}

		addType(expectedList, expectedType);
		i = i + 1;
	}

	i = 0;
	var j = 0;
	var typesMatching = (bool)1;
	while (i < expectedList.size) {
		var expectedType = expectedList.list[i];
		var argumentType = (TypeObj)0;
		if (j > argumentList.size) {
			i = expectedList.size;
		} else {
			argumentType = argumentList.list[j];
		}

		if (compareTypes(parser, argumentType, expectedType)) {
			j = j + 1;
		} else {
			typesMatching = (bool)0;
		}
		i = i + 1;
	}

	if (typesMatching != (bool)1) {
		printError(parser, call.operator.position, " arguments do not match\n");
		print("[NOTE] expected: ");
		printTypeList(expectedList);
		print(", got: ");
		printTypeList(argumentList);
		print("\n");
	}

	if (function.returnType == (ReturnType)0) {
		call.operationType = parser.null;
		return parser.null;
	}

	var returnType = function.returnType.typeObj;
	if (returnType == (TypeObj)0 && function.returnType.returnType != (Operation)0) {
		returnType = getTypeFromOperation(parser, tree, block, function.returnType.returnType);
	}

	if (returnType == (TypeObj)0) {
		printError(parser, function.returnType.region.start, " return type is null\n");
	}

	call.operationType = returnType;
	return returnType;
}

func checkTypesInProperty(Parser parser, SyntaxTree tree, Block block, Operation operation) -> TypeObj {
	if (isVariable(operation.left) != (bool)1) {
		printError(parser, operation.operator.position, " can not read a property from a value that is not a variable\n");
		return (TypeObj)0;
	}

	var typeObj = checkTypesInOperation(parser, tree, block, operation.left);

	if (typeObj == (TypeObj)0) {
		printError(parser, operation.left.region.start, " type of struct is undefined\n");
		return (TypeObj)0;
	}

	if (typeObj.properties.size == 0) {
		printError(parser, operation.left.region.start, " cannot read property of immediate type\n");
		return (TypeObj)0;
	}

	var rightValue = operation.right.value;
	if (rightValue == (Value)0 || rightValue.identifier == (Identifier)0) {
		printError(parser, operation.right.region.start, " expected an identifier after '.' operator\n");
		return (TypeObj)0;
	}

	var property = findProperty(typeObj.properties, rightValue.identifier.name);
	if (property == (Property)0) {
		printError(parser, operation.right.region.start, " could not find property with name '");
		print(rightValue.identifier.name);
		print("'\n");
		return (TypeObj)0;
	}

	if (property.definition == (PropertyDefinition)0) {
		printError(parser, operation.right.region.start, " property has no definition\n");
		return (TypeObj)0;
	}

	var propertyType = getTypeFromOperation(parser, tree, block, property.definition.propertyType);
	operation.operationType = propertyType;
	return propertyType;
}

func checkTypesInOperation(Parser parser, SyntaxTree tree, Block block, Operation operation) -> TypeObj {
	if (operation == (Operation)0) {
		print("operation is null\n");
		return (TypeObj)0;
	}

	if (operation.value != (Value)0) {
		var valueType = checkTypesInValue(parser, tree, block, operation.value);
		operation.operationType = valueType;
		return valueType;
	}

	if (operation.sizeOf != (SizeOf)0) {
		operation.operationType = parser.int;
		return checkTypesInSizeOf(parser, tree, block, operation.sizeOf);
	}

	if (isOperator(operation.operator, "(") && operation.left != (Operation)0) {
		return checkTypesInFunctionCall(parser, tree, block, operation);
	}

	if (isOperator(operation.operator, ".")) {
		return checkTypesInProperty(parser, tree, block, operation);
	}

	if (isOperator(operation.operator, "-") && operation.left == (Operation)0) {
		var rightType = checkTypesInOperation(parser, tree, block, operation.right);

		if (rightType != parser.int) {
			printError(parser, operation.right.region.start, " expected type 'int' for the unary '-' operation\n");
		}

		operation.operationType = parser.int;
		return parser.int;
	}

	if (isOperator(operation.operator, "[") && operation.right == (Operation)0) {
		var leftType = checkTypesInOperation(parser, tree, block, operation.left);

		if (leftType != parser.Type) {
			printError(parser, operation.right.region.start, " expected a 'Type' for this list operator '[]'\n");
		}

		operation.operationType = parser.Type;
		return parser.Type;
	}

	var leftType = (TypeObj)0;
	var rightType = (TypeObj)0;

	if (operation.left != (Operation)0) {
		leftType = checkTypesInOperation(parser, tree, block, operation.left);
	}

	if (operation.right != (Operation)0) {
		rightType = checkTypesInOperation(parser, tree, block, operation.right);
	}

	if (((TypeObj)0 == leftType || rightType == (TypeObj)0) && isOperator(operation.operator, "(") != (bool)1) {
		return (TypeObj)0;
	}

	if (isOperator(operation.operator, "<") ||
		isOperator(operation.operator, ">") ||
		isOperator(operation.operator, "<=") ||
		isOperator(operation.operator, ">=") ||
		isOperator(operation.operator, "==") ||
		isOperator(operation.operator, "!=")) {
		if (leftType != rightType) {
			printError(parser, operation.operator.position, " can not compare values of different types\n");
			print("[NOTE] types where: '");
			printType(leftType);
			print("' and '");
			printType(rightType);
			print("'\n");
		}
		operation.operationType = parser.bool;
		return parser.bool;
	} else if (isOperator(operation.operator, "[")) {
		if (isVariable(operation.left) != (bool)1) {
			printError(parser, operation.operator.position, " can not index from a value that is not a variable\n");
			return (TypeObj)0;
		}

		if (leftType == (TypeObj)0) {
			printError(parser, operation.operator.position, " type of list is null\n");
			return (TypeObj)0;
		}

		if (rightType != parser.int) {
			printError(parser, operation.right.region.start, " expected list index to be of type 'int'\n");
			return (TypeObj)0;
		}

		operation.operationType = leftType.listType;
		return leftType.listType;
	} else if (isOperator(operation.operator, "+")) {
		if (leftType == parser.int) {
			if (rightType == parser.int) {
				operation.operationType = parser.int;
				return parser.int;
			} else if (rightType == parser.char) {
				operation.operationType = parser.char;
				return parser.char;
			} else {
				printError(parser, operation.operator.position, " can not add values of type 'int' and '");
				printType(rightType);
				print("'\n");
			}
		} else if (leftType == parser.char) {
			if (rightType == parser.int) {
				operation.operationType = parser.char;
				return parser.char;
			} else {
				printError(parser, operation.operator.position, " can not add values of type 'char' and '");
				printType(rightType);
				print("'\n");
			}
		} else {
			printError(parser, operation.operator.position, " can not add values of type '");
			printType(leftType);
			print("' and '");
			printType(rightType);
			print("'\n");
		}

		return (TypeObj)0;
	} else if (isOperator(operation.operator, "-")) {
		if (leftType == parser.int) {
			if (rightType == parser.int) {
				operation.operationType = parser.int;
				return parser.int;
			} else {
				printError(parser, operation.operator.position, " can not subtract value of type '");
				printType(rightType);
				print("' from 'int'\n");
			}
		} else if (leftType == parser.char) {
			if (rightType == parser.int) {
				operation.operationType = parser.char;
				return parser.char;
			} else if (rightType == parser.char) {
				operation.operationType = parser.int;
				return parser.int;
			} else {
				printError(parser, operation.operator.position, " can not subtract value of type '");
				printType(rightType);
				print("' from 'char'\n");
			}
		} else {
			printError(parser, operation.operator.position, " can not subtract value of type '");
			printType(rightType);
			print("' from '");
			printType(leftType);
			print("'\n");
		}

		return (TypeObj)0;
	} else if (isOperator(operation.operator, "*") ||
			isOperator(operation.operator, "&") ||
			isOperator(operation.operator, "|") ||
			isOperator(operation.operator, "<<") ||
			isOperator(operation.operator, ">>")) {
		if (leftType != parser.int || rightType != parser.int) {
			printError(parser, operation.operator.position, " can not perform operation: '");
			print(operation.operator.name);
			print("' on values of type: '");
			printType(leftType);
			print("', and '");
			printType(rightType);
			print("'\n");
		}

		operation.operationType = parser.int;
		return parser.int;
	} else if (isOperator(operation.operator, "(")) {
		var typeObj = checkTypesInOperation(parser, tree, block, operation.right);

		if (operation.castType != (Operation)0) {
			var castType = getTypeFromOperation(parser, tree, block, operation.castType);
			operation.operationType = castType;
			return castType;
		}

		operation.operationType = typeObj;
		return typeObj;
	} else if (isOperator(operation.operator, "=")) {
		if (isVariable(operation.left) != (bool)1) {
			printError(parser, operation.operator.position, " can not assign a value to a constant\n");
			return (TypeObj)0;
		}

		if (leftType != rightType) {
			printError(parser, operation.operator.position, " can not assign a value with a different type\n");
			print("[NOTE] expected: '");
			printType(leftType);
			print("', got: '");
			printType(rightType);
			print("'\n");
		}

		return (TypeObj)0;
	} else if (isOperator(operation.operator, "&&") ||
			isOperator(operation.operator, "||")) {
		if (leftType != parser.bool || rightType != parser.bool) {
			printError(parser, operation.operator.position, " can not perform an 'and' or 'or' operation on values of type '");
			printType(leftType);
			print("' and '");
			printType(rightType);
			print("'\n");
		}
		operation.operationType = parser.bool;
		return parser.bool;
	} else {
		printError(parser, operation.region.start, " do not support type checking for '");
		print(operation.operator.name);
		print("' operator yet\n");
	}

	return (TypeObj)0;
}

func checkTypesInExpression(Parser parser, SyntaxTree tree, Block block, Expression expression) {
	checkTypesInOperation(parser, tree, block, expression.operation);
}

func checkTypesInIf(Parser parser, SyntaxTree tree, Block block, If ifStatement) {
	var conditionType = checkTypesInOperation(parser, tree, block, ifStatement.condition);

	if (conditionType != parser.bool) {
		printError(parser, ifStatement.region.start, " expected if condition to be of type boolean\n");
	}

	var i = 0;
	while (i < ifStatement.elseIfs.size) {
		var conditionType = checkTypesInOperation(parser, tree, block, ifStatement.elseIfs.list[i].condition);

		if (conditionType != parser.bool) {
			printError(parser, ifStatement.elseIfs.list[i].region.start, " expected else if condition to be of type boolean\n");
		}
		i = i + 1;
	}
}

func checkTypesInWhile(Parser parser, SyntaxTree tree, Block block, While whileStatement) {
	var conditionType = checkTypesInOperation(parser, tree, block, whileStatement.condition);

	if (conditionType != parser.bool) {
		printError(parser, whileStatement.region.start, " expected while condition to be of type boolean\n");
	}
}

func checkTypesInVariable(Parser parser, SyntaxTree tree, Block block, Variable variable) {
	var variableType = checkTypesInOperation(parser, tree, block, variable.definition.value);

	if (variableType == (TypeObj)0) {
		printError(parser, variable.definition.value.region.start, " type is undefined\n");
	}

	variable.variableType = variableType;
}

func checkTypesInReturn(Parser parser, SyntaxTree tree, Block block, Return returnStatement) {
	var returnType = parser.null;
	if (returnStatement.expression != (Operation)0) {
		returnType = checkTypesInOperation(parser, tree, block, returnStatement.expression);
	}

	var function = getBlockFunction(block);
	if (function == (FunctionDefinition)0) {
		printError(parser, returnStatement.region.start, " can not return from outside a function\n");
		return;
	}

	if (function.returnType == (ReturnType)0) {
		if (returnType != parser.null) {
			printError(parser, returnStatement.expression.region.start, " can not return a value from a null function\n");
		}
		return;
	}

	var expectedType = getTypeFromOperation(parser, tree, block, function.returnType.returnType);

	if (returnType != expectedType) {
		if (returnType == parser.null) {
			printError(parser, returnStatement.semicolon.position, "expected a return value\n");
			return;
		}

		printError(parser, returnStatement.expression.region.start, " expected type '");
		printType(expectedType);
		print("', got '");
		printType(returnType);
		print("'\n");
		return;
	}
}

func checkTypesInStatementList(Parser parser, SyntaxTree tree, Block block, StatementList list) {
	var i = 0;
	while (i < list.size) {
		var statement = list.list[i];
		if (statement.expression != (Expression)0) {
			checkTypesInExpression(parser, tree, block, statement.expression);
		} else if (statement.ifStatement != (If)0) {
			checkTypesInIf(parser, tree, block, statement.ifStatement);
		} else if (statement.whileStatement != (While)0) {
			checkTypesInWhile(parser, tree, block, statement.whileStatement);
		} else if (statement.variable != (Variable)0) {
			checkTypesInVariable(parser, tree, block, statement.variable);
		} else if (statement.returnStatement != (Return)0) {
			checkTypesInReturn(parser, tree, block, statement.returnStatement);
		}

		i = i + 1;
	}
}

func checkTypes(Parser parser, SyntaxTree tree) {
	if (tree == (SyntaxTree)0) {
		print("syntax tree is null\n");
		return;
	}

	checkTypesInStatementList(parser, tree, (Block)0, tree.statements);

	var i = 0;
	while (i < tree.blocks.size) {
		var block = tree.blocks.list[i];
		checkTypesInStatementList(parser, tree, block, block.statements);
		i = i + 1;
	}
}

func listFunctions(Parser parser) -> FunctionList {
	var list = createFunctionList();

	extendFunctionList(list, parser.functions);

	var i = 0;
	while (i < parser.files.size) {
		var tree = parser.files.list[i];

		if (tree == (SyntaxTree)0) {
			print("tree is null in 'listFunctions'\n");
			return list;
		}

		extendFunctionList(list, tree.functions);

		var j = 0;
		while (j < tree.blocks.size) {
			var block = tree.blocks.list[j];

			if (block == (Block)0) {
				print("block is null in 'listFunctions'\n");
				return list;
			}

			extendFunctionList(list, block.functions);
			j = j + 1;
		}
		i = i + 1;
	}

	return list;
}
