import "block.lumina"
import "type.lumina"
import "lexer.lumina"
import "statement.lumina"
import "operation.lumina"


type SyntaxTree {
	str fileName;
	Lexer lexer;
	BlockList blocks;
	StatementList statements;
	TypeList types;
	FunctionList functions;
	VariableList variables;
}

type SyntaxTreeList {
	int size;
	int maxSize;
	SyntaxTree[] list;
}

type Parser {
	SyntaxTreeList files;
}

func createSyntaxTree(str fileName) -> SyntaxTree {
	var tree = (SyntaxTree)malloc(sizeof(SyntaxTree));

	tree.fileName = fileName;
	tree.blocks = createBlockList();
	tree.lexer = createLexer(fileName);
	next(tree.lexer);

	tree.statements = createStatementList();
	tree.types = createTypeList();
	tree.functions = createFunctionList();
	tree.variables = createVariableList();
	
	return tree;
}

func createSyntaxTreeList() -> SyntaxTreeList {
	var list = (SyntaxTreeList)malloc(sizeof(SyntaxTreeList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (SyntaxTree[])malloc(8 * 8);

	return list;
}

func addSyntaxTree(SyntaxTreeList list, SyntaxTree tree) {
	list.list[list.size] = tree;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (SyntaxTree[])realloc((ptr)list.list, 8 * list.maxSize, list.maxSize * 8 * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func createParser() -> Parser {
	var parser = (Parser)malloc(sizeof(Parser));

	parser.files = createSyntaxTreeList();

	return parser;
}

func consumeOperator(SyntaxTree tree, str operator, bool ignoreError) -> Operator {
	if (isOperator(tree.lexer.current.operator, operator)) {
		var value = tree.lexer.current.operator;
		next(tree.lexer);
		return value;
	}

	if (ignoreError != (bool)1) {
		printPosition(createPositionFromLexer(tree.lexer));
		print("did not find operator: '");
		print(operator);
		print("'\n");
	}

	return (Operator)0;
}

func consumeKeyword(SyntaxTree tree, int keyword) -> Name {
	if (isKeyword(tree.lexer.current.name, keyword)) {
		var value = tree.lexer.current.name;
		next(tree.lexer);
		return value;
	}

	printPosition(createPositionFromLexer(tree.lexer));
	print("did not find keyword: '");
	printi(keyword);
	print("'\n");

	return (Name)0;
}

func consumeIdentifier(SyntaxTree tree) -> Name {
	if (isIdentifier(tree.lexer.current.name)) {
		var value = tree.lexer.current.name;
		next(tree.lexer);
		return value;
	}

	printPosition(createPositionFromLexer(tree.lexer));
	print("did not find identifier\n");

	return (Name)0;
}

func consumeString(SyntaxTree tree) -> String {
	if (isString(tree.lexer.current)) {
		var value = tree.lexer.current.string;
		next(tree.lexer);
		return value;
	}

	printPosition(createPositionFromLexer(tree.lexer));
	print("did not find string\n");
	
	return (String)0;
}

func parseType(SyntaxTree tree, bool ignoreErrors) -> Type {
	var name = consumeIdentifier(tree);

	var brackets = createOperatorList();
	while (isOperator(tree.lexer.current.operator, "[")) {
		addOperator(brackets, tree.lexer.current.operator);

		next(tree.lexer);
		if (isOperator(tree.lexer.current.operator, "]") != (bool)1) {
			print("expected ']' after '[' in list definition\n");
		}
		var lbracket = consumeOperator(tree, "]", ignoreErrors);
		addOperator(brackets, lbracket);
	}

	return createType(name, brackets);
}

func parseProperty(SyntaxTree tree) -> Property {
	var propertyType = parseType(tree, (bool)0);

	var propertyName = tree.lexer.current.name;

	next(tree.lexer);
	var semicolon = tree.lexer.current.operator;
	
	next(tree.lexer);

	return createProperty(propertyType, propertyName, semicolon);
}

func parseTypeDefinition(SyntaxTree tree) -> TypeDefinition {
	var keyword = tree.lexer.current.name;

	next(tree.lexer);
	var typeName = tree.lexer.current.name;

	next(tree.lexer);
	var lbrace = tree.lexer.current.operator;

	var properties = createPropertyList();
	next(tree.lexer);
	while (isOperator(tree.lexer.current.operator, "}") != (bool)1) {
		var property = parseProperty(tree);
		addProperty(properties, property);
	}

	var rbrace = tree.lexer.current.operator;

	next(tree.lexer);

	return createTypeDefinition(keyword, typeName, lbrace, properties, rbrace);
}

func parseExpression(SyntaxTree tree, int precedence) -> Operation {
	func parseUnary(SyntaxTree tree) -> Operation {
		func parseGroup(SyntaxTree tree) -> Operation {
			var lparen = consumeOperator(tree, "(", (bool)0);

			if (isIdentifier(tree.lexer.current.name)) {
				var typeObj = parseType(tree, (bool)1);
				var rparen = consumeOperator(tree, ")", (bool)0);

				var operation = parseExpression(tree, PREC_index);
				return createTypeCast(lparen, typeObj, rparen, operation);
			}

			var operation = parseExpression(tree, PREC_expression);
			var rparen = consumeOperator(tree, ")", (bool)0);

			var group = createUnaryOperation(lparen, operation, rparen);
			return group;
		}

		func parseNegative(SyntaxTree tree) -> Operation {
			var operator = consumeOperator(tree, "-", (bool)0);

			var operation = parseUnary(tree);
			return createUnaryOperation(operator, operation, (Operator)0);
		}

		func parseSizeof(SyntaxTree tree) -> Operation {
			var keyword = consumeKeyword(tree, KEYWORD_sizeof);
			var lparen = consumeOperator(tree, "(", (bool)0);
			var typeObj = parseType(tree, (bool)0);
			var rparen = consumeOperator(tree, ")", (bool)0);

			var sizeOf = createSizeOf(keyword, lparen, typeObj, rparen);
			return createOperationFromSizeOf(sizeOf);
		}

		var value = (Value)0;

		if (isNumber(tree.lexer.current)) {
			value = createValueFromNumber(tree.lexer.current.number);
		} else if (isCharacter(tree.lexer.current)) {
			value = createValueFromCharacter(tree.lexer.current.character);
		} else if (isString(tree.lexer.current)) {
			value = createValueFromString(tree.lexer.current.string);
		} else if (isIdentifier(tree.lexer.current.name)) {
			value = createValueFromIdentifier(tree.lexer.current.name);
		}

		if (value != (Value)0) {
			next(tree.lexer);
			return createOperationFromValue(value);
		}

		if (isKeyword(tree.lexer.current.name, KEYWORD_sizeof)) {
			return parseSizeof(tree);
		}

		if (isOperator(tree.lexer.current.operator, "-")) {
			return parseNegative(tree);
		}

		if (isOperator(tree.lexer.current.operator, "(")) {
			return parseGroup(tree);
		}

		if (tree.lexer.current.operator == (Operator)0) {
			printPosition(createPositionFromLexer(tree.lexer));
			print("operator is null\n");
		} else {
			printPosition(tree.lexer.current.operator.position);
			print(" '");
			print(tree.lexer.current.operator.name);
			print("', ");
		}

		print("do not recognise as unary\n");

		next(tree.lexer);
		return (Operation)0;
	}

	func parseIndex(SyntaxTree tree, Operation left) -> Operation {
		var lbracket = consumeOperator(tree, "[", (bool)0);
		var index = parseExpression(tree, PREC_expression);
		var rbracket = consumeOperator(tree, "]", (bool)0);

		return createOperation(left, lbracket, index, rbracket);
	}

	func parseCall(SyntaxTree tree, Operation left) -> Operation {
		var lparen = consumeOperator(tree, "(", (bool)0);

		if (isOperator(tree.lexer.current.operator, ")")) {
			var rparen = consumeOperator(tree, ")", (bool)0);
			return createOperation(left, lparen, (Operation)0, rparen);
		}
		
		var args = parseExpression(tree, PREC_expression);

		while (isOperator(tree.lexer.current.operator, ",")) {
			var comma = consumeOperator(tree, ",", (bool)0);

			var right = parseExpression(tree, PREC_expression);

			args = createOperation(args, comma, right, (Operator)0);
		}

		var rparen = consumeOperator(tree, ")", (bool)0);

		return createOperation(left, lparen, args, rparen);
	}

	var operation = parseUnary(tree);

	if (operation == (Operation)0) {
		print("left hand side is null\n");
		return (Operation)0;
	}

	var operator = tree.lexer.current.operator;

	while (operator != (Operator)0 && operator.precedence >= precedence) {
		if (isOperator(operator, "[")) {
			operation = parseIndex(tree, operation);
		} else if (isOperator(operator, "(")) {
			operation = parseCall(tree, operation);
		} else {
			next(tree.lexer);

			var right = parseExpression(tree, precedence + 1);

			if (right == (Operation)0) {
				print("right hand side is null\n");
				return (Operation)0;
			}

			operation = createOperation(operation, operator, right, (Operator)0);
		}

		operator = tree.lexer.current.operator;
	}

	return operation;
}

func parseImport(SyntaxTree tree) -> Import {
	var keyword = consumeKeyword(tree, KEYWORD_import);

	var fileName = consumeString(tree);

	return createImport(keyword, fileName);
}

func parseVariableDefinition(SyntaxTree tree) -> VariableDefinition {
	var keyword = tree.lexer.current.name;
	next(tree.lexer);

	var name = consumeIdentifier(tree);
	var equalSign = consumeOperator(tree, "=", (bool)0);
	var value = parseExpression(tree, PREC_expression);
	var semicolon = consumeOperator(tree, ";", (bool)0);

	return createVariableDefinition(keyword, name, equalSign, value, semicolon);
}

func parseParameterList(SyntaxTree tree) -> ParameterList {
	var list = createParameterList();

	if (isOperator(tree.lexer.current.operator, ")")) {
		return list;
	}

	var parameterType = parseType(tree, (bool)0);
	var name = consumeIdentifier(tree);

	while (isOperator(tree.lexer.current.operator, ",")) {
		var comma = consumeOperator(tree, ",", (bool)0);

		var parameter = createParameter(parameterType, name, comma);
		addParameter(list, parameter);

		parameterType = parseType(tree, (bool)0);
		name = consumeIdentifier(tree);
	}

	var parameter = createParameter(parameterType, name, (Operator)0);
	addParameter(list, parameter);

	return list;
}

func parseReturnType(SyntaxTree tree) -> ReturnType {
	var rarrow = consumeOperator(tree, "->", (bool)0);
	var typeObj = parseType(tree, (bool)0);

	return createReturnType(rarrow, typeObj);
}

func parseStatement(SyntaxTree tree, TypeList typeList, FunctionList functionList, VariableList variableList, Block outer) -> Statement {
	func parseBlock(SyntaxTree tree, Block outer) -> int {
		var lbrace = consumeOperator(tree, "{", (bool)0);

		var statementList = createStatementList();
		var typeList = createTypeList();
		var functionList = createFunctionList();
		var variableList = createVariableList();

		var block = createBlock(lbrace, statementList, typeList, functionList, variableList, outer);

		while (isOperator(tree.lexer.current.operator, "}") != (bool)1 || tree.lexer.current.isEOF) {
			var statement = parseStatement(tree, typeList, functionList, variableList, block);
			addStatement(statementList, statement);
		}

		var rbrace = consumeOperator(tree, "}", (bool)0);

		setEnd(block, rbrace);
		addBlock(tree.blocks, block);

		return tree.blocks.size - 1;
	}

	func parseElseIf(SyntaxTree tree, ElseIfList list, Name elseKeyword, Block outer) {
		var ifKeyword = consumeKeyword(tree, KEYWORD_if);
		var lparen = consumeOperator(tree, "(", (bool)0);
		var condition = parseExpression(tree, PREC_expression);
		var rparen = consumeOperator(tree, ")", (bool)0);
		var block = parseBlock(tree, outer);
		var endPosition = tree.blocks.list[block].region.end;

		var elseIf = createElseIf(elseKeyword, ifKeyword, lparen, condition, rparen, block, endPosition);
		addElseIf(list, elseIf);
	}

	func parseElse(SyntaxTree tree, Name keyword, Block outer) -> Else {
		var block = parseBlock(tree, outer);
		var endPosition = tree.blocks.list[block].region.end;

		return createElse(keyword, block, endPosition);
	}

	func parseIf(SyntaxTree tree, Block outer) -> If {
		var ifKeyword = consumeKeyword(tree, KEYWORD_if);

		var lparen = consumeOperator(tree, "(", (bool)0);
		var condition = parseExpression(tree, PREC_expression);
		var rparen = consumeOperator(tree, ")", (bool)0);
		
		var block = -1;
		var endPosition = (Position)0;

		if (isOperator(tree.lexer.current.operator, "{")) {
			block = parseBlock(tree, outer);
			endPosition = tree.blocks.list[block].region.end;
		} else {
			print("expected block after 'if'\n");
		}

		var elseIfs = createElseIfList();

		while (isKeyword(tree.lexer.current.name, KEYWORD_else)) {
			var elseKeyword = consumeKeyword(tree, KEYWORD_else);

			if (isKeyword(tree.lexer.current.name, KEYWORD_if)) {
				parseElseIf(tree, elseIfs, elseKeyword, outer);
			} else {
				var elseObj = parseElse(tree, elseKeyword, outer);
				return createIf(ifKeyword, lparen, condition, rparen, block, elseIfs, elseObj, endPosition);
			}
		}

		return createIf(ifKeyword, lparen, condition, rparen, block, elseIfs, (Else)0, endPosition);
	}

	func parseWhile(SyntaxTree tree, Block outer) -> While {
		var keyword = consumeKeyword(tree, KEYWORD_while);

		var lparen = consumeOperator(tree, "(", (bool)0);
		var condition = parseExpression(tree, PREC_expression);
		var rparen = consumeOperator(tree, ")", (bool)0);

		var block = -1;
		var endPosition = (Position)0;

		if (isOperator(tree.lexer.current.operator, "{")) {
			block = parseBlock(tree, outer);
			endPosition = tree.blocks.list[block].region.end;
		} else  {
			print("expected block after while\n");
		}

		return createWhile(keyword, lparen, condition, rparen, block, endPosition);
	}

	func parseFunctionDefinition(SyntaxTree tree, Block outer) -> FunctionDefinition {
		var keyword = consumeKeyword(tree, KEYWORD_func);
		var name = consumeIdentifier(tree);

		var lparen = consumeOperator(tree, "(", (bool)0);
		var parameters = parseParameterList(tree);
		var rparen = consumeOperator(tree, ")", (bool)0);

		var returnType = (ReturnType)0;
		if (isOperator(tree.lexer.current.operator, "->")) {
			returnType = parseReturnType(tree);
		}

		var block = parseBlock(tree, outer);
		var endPosition = tree.blocks.list[block].region.end;

		return createFunctionDefinition(keyword, name, lparen, parameters, rparen, returnType, block, endPosition);
	}

	func parseReturn(SyntaxTree tree) -> Return {
		var keyword = consumeKeyword(tree, KEYWORD_return);

		if (isOperator(tree.lexer.current.operator, ";")) {
			var semicolon = consumeOperator(tree, ";", (bool)0);

			return createReturn(keyword, (Operation)0, semicolon);
		}

		var expression = parseExpression(tree, PREC_expression);
		var semicolon = consumeOperator(tree, ";", (bool)0);

		return createReturn(keyword, expression, semicolon);
	}

	if (isKeyword(tree.lexer.current.name, KEYWORD_var) ||
		isKeyword(tree.lexer.current.name, KEYWORD_const)) {
		var variable = parseVariableDefinition(tree);

		addVariable(variableList, variable);

		return createVariableStatement(variable);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_func)) {
		var function = parseFunctionDefinition(tree, outer);

		addFunction(functionList, function);

		return createFunctionStatement(function);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_if)) {
		var ifStatement = parseIf(tree, outer);

		return createIfStatement(ifStatement);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_while)) {
		var whileStatement = parseWhile(tree, outer);

		return createWhileStatement(whileStatement);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_type)) {
		var typeDefinition = parseTypeDefinition(tree);

		addType(typeList, typeDefinition);

		return createTypeStatement(typeDefinition);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_import)) {
		var importStatement = parseImport(tree);

		return createImportStatement(importStatement);
	} else if (isKeyword(tree.lexer.current.name, KEYWORD_return)) {
		var returnStatement = parseReturn(tree);

		return createReturnStatement(returnStatement);
	} else if (isOperator(tree.lexer.current.operator, "{")) {
		var blockId = parseBlock(tree, outer);

		return createBlockStatement(blockId, tree.blocks.list[blockId].region);
	}

	var operation = parseExpression(tree, PREC_assignment);
	var semicolon = consumeOperator(tree, ";", (bool)0);
	var expression = createExpression(operation, semicolon);

	return createExpressionStatement(expression);
}

func parse(Parser parser, str fileName) -> SyntaxTree {
	var tree = createSyntaxTree(fileName);

	while (tree.lexer.current.isEOF != (bool)1) {
		var statement = parseStatement(tree, tree.types, tree.functions, tree.variables, (Block)0);
		addStatement(tree.statements, statement);
	}

	addSyntaxTree(parser.files, tree);

	return tree;
}

func bindName(SyntaxTree tree, Name name, Block block) {
    var function = (FunctionDefinition)0;
    var typeDef = (TypeDefinition)0;
    var variable = (VariableDefinition)0;

    if (block != (Block)0) {
	function = findFunctionInBlock(block, name.name);
	typeDef = findTypeInBlock(block, name.name);
	variable = findVariableInBlock(block, name.name);
    }

    if (function == (FunctionDefinition)0) {
	function = findFunction(tree.functions, name.name);
    }

    if (function != (FunctionDefinition)0) {
	name.definitionRegion = function.region;
	return;
    }

    if (typeDef == (TypeDefinition)0) {
	typeDef = findType(tree.types, name.name);
    }

    if (typeDef != (TypeDefinition)0) {
	name.definitionRegion = typeDef.region;
	return;
    }

    if (variable == (VariableDefinition)0) {
	variable = findVariable(tree.variables, name.name);
    }

    if (variable != (VariableDefinition)0) {
	name.definitionRegion = variable.region;
	return;
    }

    print("could not find name: '");
    print(name.name);
    print("'\n");
}

func bindNamesInType(SyntaxTree tree, Type typeObj, Block block) {
    bindName(tree, typeObj.name, block);
}

func bindNamesInOperation(SyntaxTree tree, Operation operation, Block block) {
    if (operation.left != (Operation)0) {
	bindNamesInOperation(tree, operation.left, block);
    }

    if (operation.right != (Operation)0 && (operation.operator == (Operator)0 || isOperator(operation.operator, "."))) {
	bindNamesInOperation(tree, operation.right, block);
    }

    if (operation.sizeOf != (SizeOf)0) {
	bindNamesInType(tree, operation.sizeOf.typeObj, block);
    }

    if (operation.castType != (Type)0) {
	bindNamesInType(tree, operation.castType, block);
    }

    if (operation.value != (Value)0 && operation.value.name != (Name)0) {
	bindName(tree, operation.value.name, block);
    }
}

func bindNamesInExpression(SyntaxTree tree, Expression expression, Block block) {
    bindNamesInOperation(tree, expression.operation, block);
}

func bindNamesInIf(SyntaxTree tree, If ifStatement, Block block) {
    print("can not bind names in if yet\n");
}

func bindNamesInWhile(SyntaxTree tree, While whileStatement, Block block) {
    print("can not bind names in while yet\n");
}

func bindNamesInFunctionDefinition(SyntaxTree tree, FunctionDefinition function, Block block) {
    print("can not bind names in function definitions yet\n");
}

func bindNamesInTypeDefinition(SyntaxTree tree, TypeDefinition typeDef, Block block) {
    print("can not bind names in type definitions yet\n");
}

func bindNamesInReturn(SyntaxTree tree, Return returnStatement, Block block) {
    if (returnStatement.expression != (Operation)0) {
	bindNamesInOperation(tree, returnStatement.expression, block);
    }
}

func bindNamesInStatementList(SyntaxTree tree, StatementList list, Block block) {
    var i = 0;
    while (i < list.size) {
	var statement = list.list[i];
	if (statement.expression != (Expression)0) {
	    bindNamesInExpression(tree, statement.expression, block);
	} else if (statement.ifStatement != (If)0) {
	    bindNamesInIf(tree, statement.ifStatement, block);
	} else if (statement.whileStatement != (While)0) {
	    bindNamesInWhile(tree, statement.whileStatement, block);
	} else if (statement.variable != (VariableDefinition)0) {
	    bindNamesInOperation(tree, statement.variable.value, block);
	} else if (statement.function != (FunctionDefinition)0) {
	    bindNamesInFunctionDefinition(tree, statement.function, block);
	} else if (statement.typeStatement != (TypeDefinition)0) {
	    bindNamesInTypeDefinition(tree, statement.typeStatement, block);
	} else if (statement.returnStatement != (Return)0) {
	    bindNamesInReturn(tree, statement.returnStatement, block);
	}

	i = i + 1;
    }
}

func bindNames(Parser parser, str fileName) {
    var tree = (SyntaxTree)0;

    var i = 0;
    while (i < parser.files.size) {
	if (streq(parser.files.list[i].fileName, fileName)) {
	    tree = parser.files.list[i];
	}
	i = i + 1;
    }

    if (tree == (SyntaxTree)0) {
	print("no tree has been created for the file '");
	print(fileName);
	print("'\n");
    }

    bindNamesInStatementList(tree, tree.statements, (Block)0);

    i = 0;
    while (i < tree.blocks.size) {
	bindNamesInStatementList(tree, tree.blocks.list[i].statements, tree.blocks.list[i]);
	i = i + 1;
    }
}
