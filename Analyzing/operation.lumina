import "../std/memory.lumina"

import "position.lumina"
import "operator.lumina"
import "value.lumina"
import "type.lumina"
import "name.lumina"


type SizeOf {
	Region region;

	Name keyword;
	Operator lparen;
	Type typeObj;
	Operator rparen;
}

type Operation {
	Region region;
	Operation left;
	Operator operator;
	Operation right;
	Operator end;
	Value value;
	SizeOf sizeOf;
	Type castType;
}

func createSizeOf(Name keyword, Operator lparen, Type typeObj, Operator rparen) -> SizeOf {
	var sizeOf = (SizeOf)malloc(sizeof(SizeOf));

	sizeOf.region = createRegion(keyword.region.start, rparen.position);

	sizeOf.keyword = keyword;
	sizeOf.lparen = lparen;
	sizeOf.typeObj = typeObj;
	sizeOf.rparen = rparen;

	return sizeOf;
}

func createOperation(Operation left, Operator operator, Operation right, Operator end) -> Operation {
	var operation = (Operation)malloc(sizeof(Operation));

	if (end == (Operator)0) {
		operation.region = createRegion(left.region.start, right.region.end);
	} else {
		operation.region = createRegion(left.region.start, end.position);
	}

	operation.left = left;
	operation.operator = operator;
	operation.right = right;
	operation.value = (Value)0;
	operation.end = end;
	operation.sizeOf = (SizeOf)0;
	operation.castType = (Type)0;

	return operation;
}

func createUnaryOperation(Operator operator, Operation right, Operator end) -> Operation {
	var operation = (Operation)malloc(sizeof(Operation));

	if (end == (Operator)0) {
		operation.region = createRegion(operator.position, right.region.end);
	} else {
		operation.region = createRegion(operator.position, end.position);
	}

	operation.left = (Operation)0;
	operation.operator = operator;
	operation.right = right;
	operation.value = (Value)0;
	operation.end = end;
	operation.sizeOf = (SizeOf)0;
	operation.castType = (Type)0;

	return operation;
}

func createOperationFromValue(Value value) -> Operation {
	var operation = (Operation)malloc(sizeof(Operation));

	operation.region = value.region;
	operation.left = (Operation)0;
	operation.operator = (Operator)0;
	operation.right = (Operation)0;
	operation.value = value;
	operation.end = (Operator)0;
	operation.sizeOf = (SizeOf)0;
	operation.castType = (Type)0;

	return operation;
}

func createTypeCast(Operator lparen, Type castType, Operator rparen, Operation castOperation) -> Operation {
	var operation = (Operation)malloc(sizeof(Operation));

	operation.region = createRegion(lparen.position, castOperation.region.end);

	operation.left = (Operation)0;
	operation.operator = lparen;
	operation.right = castOperation;
	operation.value = (Value)0;
	operation.end = rparen;
	operation.sizeOf = (SizeOf)0;
	operation.castType = castType;

	return operation;
}

func createOperationFromSizeOf(SizeOf sizeOf) -> Operation {
	var operation = (Operation)malloc(sizeof(Operation));

	operation.region = sizeOf.region;
	operation.left = (Operation)0;
	operation.operator = (Operator)0;
	operation.right = (Operation)0;
	operation.value = (Value)0;
	operation.end = (Operator)0;
	operation.sizeOf = sizeOf;

	return operation;
}

func isVariable(Operation operation) -> bool {
    if (isName(operation.value)) {
	return (bool)1;
    }

    if (isOperator(operation.operator, ".")) {
	return isVariable(operation.left) && isName(operation.right.value);
    }

    if (isOperator(operation.operator, "[")) {
	return isVariable(operation.left);
    }

    return (bool)0;
}
