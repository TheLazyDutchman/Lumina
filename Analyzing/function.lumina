import "../std/string.lumina"
import "../std/io.lumina"
import "../std/collections.lumina"

import "position.lumina"
import "name.lumina"
import "operation.lumina"
import "operator.lumina"
import "type.lumina"
import "variable.lumina"
import "whitespace.lumina"
import "block.lumina"


type Parameter {
	Region region;
	
	Operation parameterType;
	Name name;
	Operator comma;

	TypeObj typeObj;
}

type ReturnType {
	Region region;

	Operator rarrow;
	Operation returnType;

	TypeObj typeObj;
}

type FunctionDefinition {
	Region region;

	Name keyword;
	Name name;

	Array<Generic> generics;
	GenericsDefinition genericsDefinition;

	Operator lparen;
	Array<Parameter> parameters;
	Operator rparen;

	ReturnType returnType;

	Block block;

	Array<FunctionDefinition> variants;
}

type Return {
	Region region;

	Name keyword;
	Operation expression;
	Operator semicolon;
}

func createParameter(Operation parameterType, Name name, Operator comma) -> Parameter {
	var parameter = new Parameter();

	if (comma != (Operator)0) {
		parameter.region = createRegion(parameterType.region.start, comma.position);
	} else {
		parameter.region = createRegion(parameterType.region.start, name.region.end);
	}

	parameter.parameterType = parameterType;
	parameter.name = name;

	return parameter;
}

func createParameterFromString(TypeObj typeObj, str name) -> Parameter {
	var parameter = new Parameter();

	parameter.typeObj = typeObj;
	if (name != (str)0) {
		parameter.name = createNameFromString(name);
	}

	return parameter;
}

func copyParameter(Parameter original) -> Parameter {
	var parameter = new Parameter();

	parameter.region = original.region;
	parameter.parameterType = original.parameterType;
	parameter.name = original.name;

	parameter.typeObj = original.typeObj;

	return parameter;
}

func copyParameterArray(Array<Parameter> original) -> Array<Parameter> {
	var list = new Array<Parameter>();

	list.size = original.size;
	list.maxSize = original.maxSize;
	list.list = new Parameter[](list.maxSize);

	var i = 0;
	while (i < original.size) {
		list.list[i] = copyParameter(original.list[i]);
		i = i + 1;
	}

	return list;
}

func createReturnType(Operator rarrow, Operation typeObj) -> ReturnType {
	var returnType = new ReturnType();

	returnType.region = createRegion(rarrow.position, typeObj.region.end);
	
	returnType.rarrow = rarrow;
	returnType.returnType = typeObj;

	return returnType;
}

func createReturnTypeFromString(TypeObj typeObj) -> ReturnType {
	var returnType = new ReturnType();

	returnType.typeObj = typeObj;

	return returnType;
}

func copyReturnType(ReturnType original) -> ReturnType {
	var returnType = new ReturnType();

	returnType.region = original.region;
	returnType.rarrow = original.rarrow;
	returnType.returnType = original.returnType;
	returnType.typeObj = original.typeObj;

	return returnType;
}

func createFunctionDefinition(Name keyword, Name name, Operator lparen, GenericsDefinition genericsDefinition, Array<Parameter> parameters, Operator rparen, ReturnType returnType, int depth) -> FunctionDefinition {
	var function = new FunctionDefinition();

	function.keyword = keyword;
	function.name = name;

	function.generics = createArray<Generic>();
	function.genericsDefinition = genericsDefinition;
	var i = 0;
	while (i < genericsDefinition.generics.size) {
		addItem<Generic>(function.generics, createGenericFromDefinition(genericsDefinition.generics.list[i], depth, i));
		i = i + 1;
	}

	function.lparen = lparen;
	function.parameters = parameters;
	function.rparen = rparen;
	function.returnType = returnType;

	function.variants = createArray<FunctionDefinition>();

	return function;
}

func createFunctionFromString(str value, Array<Parameter> parameters, ReturnType returnType) -> FunctionDefinition {
	var function = new FunctionDefinition();

	function.name = createNameFromString(value);
	function.parameters = parameters;
	function.returnType = returnType;

	function.generics = createArray<Generic>();

	function.variants = createArray<FunctionDefinition>();

	return function;
}

func createNewFunctionVariant(Array<TypeObj> arrayType, FunctionDefinition original, Array<TypeObj> generics) -> FunctionDefinition {
	var function = new FunctionDefinition();

	function.region = original.region;
	function.keyword = original.keyword;
	function.name = original.name;

	function.generics = createArray<Generic>();
	function.genericsDefinition = original.genericsDefinition;
	var i = 0;
	while (i < generics.size) {
		addItem<Generic>(function.generics, createGenericFromType(generics.list[i]));
		i = i + 1;
	}

	function.lparen = original.lparen;
	function.parameters = copyParameterArray(original.parameters);
	i = 0;
	while (i < function.parameters.size) {
		var j = 0;
		while (j < generics.size) {
			function.parameters.list[i].typeObj = applyGeneric(arrayType, function.parameters.list[i].typeObj, original.generics.list[j].typeObj, generics.list[j]);
			j = j + 1;
		}
		i = i + 1;
	}

	function.rparen = original.rparen;

	if (original.returnType != (ReturnType)0) {
		function.returnType = copyReturnType(original.returnType);
		i = 0;
		while (i < generics.size) {
			function.returnType.typeObj = applyGeneric(arrayType, function.returnType.typeObj, original.generics.list[i].typeObj, generics.list[i]);
			i = i + 1;
		}
	}

	function.block = original.block;

	function.variants = original.variants;
	addItem<FunctionDefinition>(function.variants, function);

	return function;
}

func getVariantFunction(Array<TypeObj> arrayType, FunctionDefinition function, Array<TypeObj> generics) -> FunctionDefinition {
	if (function.generics.size != generics.size) {
		print("expected ");
		printi(function.generics.size);
		print(" generics, got ");
		printi(generics.size);
		print(" instead\n");
		return (FunctionDefinition)0;
	}

	var i = 0;
	while (i < function.variants.size) {
		var variant = function.variants.list[i];
		var j = 0;
		var isEqual = (bool)1;
		while (j < generics.size) {
			if (variant.generics.list[j] == (Generic)0 || variant.generics.list[j].typeObj != generics.list[j]) {
				isEqual = (bool)0;
			}
			j = j + 1;
		}
		i = i + 1;
	}

	return createNewFunctionVariant(arrayType, function, generics);
}

func findFunction(Array<FunctionDefinition> list, str name) -> FunctionDefinition {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name.name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (FunctionDefinition)0;
}

func createReturn(Name keyword, Operation expression, Operator semicolon) -> Return {
	var returnObj = new Return();

	returnObj.region = createRegion(keyword.region.start, semicolon.position);

	returnObj.keyword = keyword;
	returnObj.expression = expression;
	returnObj.semicolon = semicolon;

	return returnObj;
}
