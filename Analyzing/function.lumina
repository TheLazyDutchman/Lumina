import "../std/memory.lumina"
import "../std/string.lumina"
import "../std/io.lumina"

import "position.lumina"
import "name.lumina"
import "operation.lumina"
import "operator.lumina"
import "type.lumina"
import "variable.lumina"
import "whitespace.lumina"
import "block.lumina"


type Parameter {
	Region region;
	
	Operation parameterType;
	Name name;
	Operator comma;

	TypeObj typeObj;
}

type ParameterList {
	int size;
	int maxSize;
	Parameter[] list;
}

type ReturnType {
	Region region;

	Operator rarrow;
	Operation returnType;

	TypeObj typeObj;
}

type FunctionDefinition {
	Region region;

	Name keyword;
	Name name;

	GenericList generics;
	GenericsDefinition genericsDefinition;

	Operator lparen;
	ParameterList parameters;
	Operator rparen;

	ReturnType returnType;

	Block block;

	FunctionList variants;
}

type FunctionList {
	int size;
	int maxSize;
	FunctionDefinition[] list;
}

type Return {
	Region region;

	Name keyword;
	Operation expression;
	Operator semicolon;
}

func createParameter(Operation parameterType, Name name, Operator comma) -> Parameter {
	var parameter = (Parameter)malloc(sizeof(Parameter));

	if (comma != (Operator)0) {
		parameter.region = createRegion(parameterType.region.start, comma.position);
	} else {
		parameter.region = createRegion(parameterType.region.start, name.region.end);
	}

	parameter.parameterType = parameterType;
	parameter.name = name;

	parameter.typeObj = (TypeObj)0;

	return parameter;
}

func createParameterFromString(TypeObj typeObj, str name) -> Parameter {
	var parameter = (Parameter)malloc(sizeof(Parameter));

	parameter.region = (Region)0;
	parameter.parameterType = (Operation)0;
	parameter.typeObj = typeObj;
	if (name != (str)0) {
		parameter.name = createNameFromString(name);
	} else {
		parameter.name = (Name)0;
	}
	parameter.comma = (Operator)0;

	return parameter;
}

func copyParameter(Parameter original) -> Parameter {
	var parameter = (Parameter)malloc(sizeof(Parameter));

	parameter.region = original.region;
	parameter.parameterType = original.parameterType;
	parameter.name = original.name;

	parameter.typeObj = original.typeObj;

	return parameter;
}

func createParameterList() -> ParameterList {
	var list = (ParameterList)malloc(sizeof(ParameterList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (Parameter[])malloc(8 * 8);

	return list;
}

func copyParameterList(ParameterList original) -> ParameterList {
	var list = (ParameterList)malloc(sizeof(ParameterList));

	list.size = original.size;
	list.maxSize = original.maxSize;
	list.list = (Parameter[])malloc(8 * list.maxSize);

	var i = 0;
	while (i < original.size) {
		list.list[i] = copyParameter(original.list[i]);
		i = i + 1;
	}

	return list;
}

func addParameter(ParameterList list, Parameter parameter) {
	list.list[list.size] = parameter;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (Parameter[])realloc((ptr)list.list, 8 * list.maxSize, list.maxSize * 8 * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func createReturnType(Operator rarrow, Operation typeObj) -> ReturnType {
	var returnType = (ReturnType)malloc(sizeof(ReturnType));

	returnType.region = createRegion(rarrow.position, typeObj.region.end);
	
	returnType.rarrow = rarrow;
	returnType.returnType = typeObj;

	return returnType;
}

func createReturnTypeFromString(TypeObj typeObj) -> ReturnType {
	var returnType = (ReturnType)malloc(sizeof(ReturnType));

	returnType.region = (Region)0;

	returnType.rarrow = (Operator)0;
	returnType.returnType = (Operation)0;
	returnType.typeObj = typeObj;

	return returnType;
}

func copyReturnType(ReturnType original) -> ReturnType {
	var returnType = (ReturnType)malloc(sizeof(ReturnType));

	returnType.region = original.region;
	returnType.rarrow = original.rarrow;
	returnType.returnType = original.returnType;
	returnType.typeObj = original.typeObj;

	return returnType;
}

func createFunctionDefinition(Name keyword, Name name, Operator lparen, GenericsDefinition genericsDefinition, ParameterList parameters, Operator rparen, ReturnType returnType) -> FunctionDefinition {
	var function = (FunctionDefinition)malloc(sizeof(FunctionDefinition));

	function.region = (Region)0;

	function.keyword = keyword;
	function.name = name;

	function.generics = createGenericList();
	function.genericsDefinition = genericsDefinition;
	var i = 0;
	while (i < genericsDefinition.generics.size) {
		addGeneric(function.generics, createGenericFromDefinition(genericsDefinition.generics.list[i]));
		i = i + 1;
	}

	function.lparen = lparen;
	function.parameters = parameters;
	function.rparen = rparen;
	function.returnType = returnType;
	function.block = (Block)0;

	function.variants = createFunctionList();

	return function;
}

func createFunctionFromString(str value, ParameterList parameters, ReturnType returnType) -> FunctionDefinition {
	var function = (FunctionDefinition)malloc(sizeof(FunctionDefinition));

	function.region = (Region)0;
	function.keyword = (Name)0;
	function.name = createNameFromString(value);
	function.lparen = (Operator)0;
	function.parameters = parameters;
	function.rparen = (Operator)0;
	function.returnType = returnType;
	function.block = (Block)0;

	function.variants = createFunctionList();

	return function;
}

func createNewFunctionVariant(FunctionDefinition original, TypeList generics) -> FunctionDefinition {
	var function = (FunctionDefinition)malloc(sizeof(FunctionDefinition));

	function.region = original.region;
	function.keyword = original.keyword;
	function.name = original.name;

	function.generics = createGenericList();
	function.genericsDefinition = original.genericsDefinition;
	var i = 0;
	while (i < generics.size) {
		addGeneric(function.generics, createGenericFromType(generics.list[i]));
		i = i + 1;
	}

	function.lparen = original.lparen;
	function.parameters = copyParameterList(original.parameters);
	i = 0;
	while (i < function.parameters.size) {
		var j = 0;
		while (j < generics.size) {
			function.parameters.list[i].typeObj = applyGeneric(function.parameters.list[i].typeObj, original.generics.list[j].typeObj, generics.list[j]);
			j = j + 1;
		}
		i = i + 1;
	}

	function.rparen = original.rparen;

	if (original.returnType != (ReturnType)0) {
		function.returnType = copyReturnType(original.returnType);
		i = 0;
		while (i < generics.size) {
			function.returnType.typeObj = applyGeneric(function.returnType.typeObj, original.generics.list[i].typeObj, generics.list[i]);
			i = i + 1;
		}
	}

	function.block = original.block;

	function.variants = original.variants;
	addFunction(function.variants, function);

	return function;
}

func getVariantFunction(FunctionDefinition function, TypeList generics) -> FunctionDefinition {
	if (function.generics.size != generics.size) {
		print("expected ");
		printi(function.generics.size);
		print(" generics, got ");
		printi(generics.size);
		print(" instead\n");
		return (FunctionDefinition)0;
	}

	var i = 0;
	while (i < function.variants.size) {
		var variant = function.variants.list[i];
		var j = 0;
		var isEqual = (bool)1;
		while (j < generics.size) {
			if (variant.generics.list[j] == (Generic)0 || variant.generics.list[j].typeObj != generics.list[j]) {
				isEqual = (bool)0;
			}
			j = j + 1;
		}
		i = i + 1;
	}

	return createNewFunctionVariant(function, generics);
}

func createFunctionList() -> FunctionList {
	var list = (FunctionList)malloc(sizeof(FunctionList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (FunctionDefinition[])malloc(8 * 8);

	return list;
}

func addFunction(FunctionList list, FunctionDefinition function) {
	list.list[list.size] = function;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (FunctionDefinition[])realloc((ptr)list.list, list.maxSize * 8, list.maxSize * 8 * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func findFunction(FunctionList list, str name) -> FunctionDefinition {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name.name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (FunctionDefinition)0;
}

func extendFunctionList(FunctionList destination, FunctionList source) {
	var i = 0;

	if (source == (FunctionList)0) {
		print("source was zero in 'extendFunctionList'\n");
		return;
	}

	while (i < source.size) {
		addFunction(destination, source.list[i]);
		i = i + 1;
	}
}

func createReturn(Name keyword, Operation expression, Operator semicolon) -> Return {
	var returnObj = (Return)malloc(sizeof(Return));

	returnObj.region = createRegion(keyword.region.start, semicolon.position);

	returnObj.keyword = keyword;
	returnObj.expression = expression;
	returnObj.semicolon = semicolon;

	return returnObj;
}
