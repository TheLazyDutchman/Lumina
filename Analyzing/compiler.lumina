import "../std/io.lumina"
import "../std/syscalls.lumina"
import "../std/memory.lumina"
import "../std/string.lumina"
import "../std/path.lumina"

import "parser.lumina"

import "block.lumina"
import "comment.lumina"
import "expression.lumina"
import "function.lumina"
import "if.lumina"
import "immediate.lumina"
import "import.lumina"
import "lexer.lumina"
import "name.lumina"
import "operation.lumina"
import "operator.lumina"
import "position.lumina"
import "statement.lumina"
import "type.lumina"
import "value.lumina"
import "variable.lumina"
import "while.lumina"
import "whitespace.lumina"


type Register {
	str name;
	bool used;
}

type RegisterList {
	int size;
	int maxSize;
	Register[] list;
}

const CALLSTACKSIZE = 2048;

func createRegister(str name) -> Register {
	var reg = (Register)malloc(sizeof(Register));

	reg.name = name;
	reg.used = (bool)0;

	return reg;
}

func createRegisterList() -> RegisterList {
	var list = (RegisterList)malloc(sizeof(RegisterList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (Register[])malloc(8 * 8);

	return list;
}

func addRegister(RegisterList list, Register reg) {
	list.list[list.size] = reg;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (Register[])realloc((ptr)list.list, list.maxSize * 8, list.maxSize * 8 * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func findRegister(RegisterList list, str name) -> Register {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (Register)0;
}

func getRegister(RegisterList list) -> Register {
	var i = 0;
	while (i < list.size) {
		if (list.list[i].used != (bool)1) {
			list.list[i].used = (bool)1;
			return list.list[i];
		}
		i = i + 1;
	}
	return (Register)0;
}

func initRegisters() -> RegisterList {
	var registers = createRegisterList();
	addRegister(registers, createRegister("r8"));
	addRegister(registers, createRegister("r9"));
	addRegister(registers, createRegister("r10"));
	addRegister(registers, createRegister("r11"));
	addRegister(registers, createRegister("rax"));
	addRegister(registers, createRegister("rcx"));
	addRegister(registers, createRegister("rdx"));

	return registers;
}

func printEscapedCharacter(int output, char chr) {
	//split the higher and lower 4 bits of the character
	var lower = (int)chr;

	var higher = 0;
	while (lower >= 16) {
		higher = higher + 1;
		lower = lower - 16;
	}

	if (higher >= 16) {
		return;
	}

	var charString = (str)malloc(5);

	if ((int)charString + 5 > (int)curEnd) {
		print("malloc returned an invalid pointer at 'printEscapedCharacter'\n");
		return;
	}

	charString[0] = '0';
	charString[1] = 'x';

	if (0 <= higher && higher <= 9) {
		charString[2] = '0' + higher;
	} else {
		charString[2] = 'A' + higher - 10;
	}

	if (0 <= lower && lower <= 9) {
		charString[3] = '0' + lower;
	} else {
		charString[3] = 'A' + lower - 10;
	}

	charString[4] = '\0';

	fprint(output, charString);
}

func writeStringLiteral(int output, str string, int id) {
	fprint(output, "	string_");
	fprinti(output, id);
	fprint(output, ": db ");
	
	string = (str)((int)string + 1);
	var len = strlen(string) - 1; // remove '"' from string literal

	var i = 0;
	while (i < len) {
		var chr = (str)((int)string + i);
		var length = 1;
		if (chr[0] == '\\') {
			length = 2;
		}

		printEscapedCharacter(output, unEscapeCharacter(chr));

		i = i + length;

		fprint(output, ", ");

		if (length == -1) {
			i = len;
		}
	}

	fprint(output, "0x00\n");
}

func writeHeader(int output) {
	fprint(output, "section .text\n");
	fprint(output, "global _start\n");
	fprint(output, "	;; -- syscall builtin --\n");
	fprint(output, "addr_func_syscall_0:\n");
	fprint(output, "	xchg rsp, [datarsp]\n");
	fprint(output, "	pop r9\n");
	fprint(output, "	pop r8\n");
	fprint(output, "	pop r10\n");
	fprint(output, "	pop rdx\n");
	fprint(output, "	pop rsi\n");
	fprint(output, "	pop rdi\n");
	fprint(output, "	pop rax\n");
	fprint(output, "	xchg rsp, [datarsp]\n");
	fprint(output, "	syscall\n");
	fprint(output, "	ret\n\n");
}

func writeStart(int output) {
	fprint(output, "_start:\n");
	fprint(output, "	lea rax, [datastack + ");
	fprinti(output, CALLSTACKSIZE);
	fprint(output, "]\n");
	fprint(output, "	mov [basestack], rax\n");
	fprint(output, "	xchg rsp, rax\n");
	fprint(output, "	add rax, 8\n");
	fprint(output, "	push rax\n");
	fprint(output, "	sub rax, 8\n");
	fprint(output, "	mov rbx, [rax]\n");
	fprint(output, "	push rbx\n");
	fprint(output, "	xchg rsp, rax\n");
	fprint(output, "	mov [datarsp], rax\n\n");
}

func writeFooter(int output, StringList strings) {
	fprint(output, "	mov rax, 60\n");
	fprint(output, "	xor rdi, rdi\n");
	fprint(output, "	syscall\n\n");

	fprint(output, "section .bss\n");

	fprint(output, "	basestack: resq ");
	fprinti(output, CALLSTACKSIZE);
	fprint(output, "\n");

	fprint(output, "	datarsp: resq 1\n");
	fprint(output, "	datastack: resq ");
	fprinti(output, CALLSTACKSIZE);
	fprint(output, "\n");
	
	fprint(output, "section .data\n");
	var i = 0;
	while (i < strings.size) {
		writeStringLiteral(output, strings.list[i], i);
		i = i + 1;
	}
}

func writeIdentifier(Parser parser, SyntaxTree tree, Block block, int output, Name name, str register, bool getValue) -> str {
	var variable = (VariableDefinition)0;
	if (block != (Block)0) {
		variable = findVariableInBlock(parser, tree, block, name.name);
	}

	if (variable == (VariableDefinition)0) {
		variable = findVariable(tree.variables, name.name);
	}

	var i = 0;
	while (i < tree.imports.size && variable == (VariableDefinition)0) {
		variable = findVariable(tree.importTrees[i].variables, name.name);
		i = i + 1;
	}

	if (variable == (VariableDefinition)0) {
		variable = findVariable(parser.variables, name.name);
	}

	if (variable == (VariableDefinition)0) {
		printPosition(name.region.start);
		print(" can not find variable\n");
		return (str)0;
	}

	fprint(output, "	mov ");
	fprint(output, register);

	if (variable.depth == 0) {
		fprint(output, ", [basestack]\n");
	} else {
		fprint(output, ", [basestack + ");
		fprinti(output, 8 * variable.depth);
		fprint(output, "]\n");
	}

	if (variable.position != 0) {
		fprint(output, "	sub ");
		fprint(output, register);
		fprint(output, ", ");
		fprinti(output, 8 * variable.position);
		fprint(output, "\n");
	}

	if (getValue) {
		fprint(output, "	mov ");
		fprint(output, register);
		fprint(output, ", [");
		fprint(output, register);
		fprint(output, "] ;; variable\n");
	}

	return register;
}

func writeIndex(int output, int size, Register registerA, Register registerB, bool getValue) -> str {
	fprint(output, "	lea ");
	fprint(output, registerA.name);
	fprint(output, ", [");
	fprint(output, registerA.name);
	fprint(output, " + ");
	fprinti(output, size);
	fprint(output, " * ");
	fprint(output, registerB.name);
	fprint(output, "]\n");

	if (getValue) {
		fprint(output, "	mov ");
		fprint(output, registerA.name);
		fprint(output, ", [");
		fprint(output, registerA.name);
		fprint(output, "] ;; index \n");

		if (size != 8) {
			fprint(output, "	and ");
			fprint(output, registerA.name);
			fprint(output, ", ");
			fprinti(output, (1 << (8 * size)) - 1);
			fprint(output, " ;; mask\n");
		}
	}

	registerB.used = (bool)0;
	return registerA.name;
}

func writeValue(Parser parser, SyntaxTree tree, Block block, int output, Value value, str register, bool getValue) -> str {
	if (value.number != (Number)0) {
		fprint(output, "	mov ");
		fprint(output, register);
		fprint(output, ", ");
		fprinti(output, value.number.value);
		fprint(output, " ;; number\n");
	} else if (value.character != (Character)0) {
		fprint(output, "	mov ");
		fprint(output, register);
		fprint(output, ", ");
		printEscapedCharacter(output, value.character.value);
		fprint(output, " ;; character\n");
	} else if (value.string != (String)0) {
		var id = findString(parser.strings, value.string.value);

		fprint(output, "	mov ");
		fprint(output, register);
		fprint(output, ", string_");
		fprinti(output, id);
		fprint(output, " ;; string\n");
	} else if (value.name != (Name)0) {
		writeIdentifier(parser, tree, block, output, value.name, register, getValue);
	}

	return register;
}

func writeBinaryOperation(int output, str operation, str registerA, str registerB) {
	fprint(output, "	");
	fprint(output, operation);
	fprint(output, " ");
	fprint(output, registerA);
	fprint(output, ", ");
	fprint(output, registerB);
	fprint(output, "\n");
}

func writeComparison(int output, str cmov, Register registerA, Register registerB) -> str {
	fprint(output, "	cmp ");
	fprint(output, registerA.name);
	fprint(output, ", ");
	fprint(output, registerB.name);
	fprint(output, "\n");
	
	fprint(output, "	mov ");
	fprint(output, registerA.name);
	fprint(output, ", 0\n");

	fprint(output, "	mov ");
	fprint(output, registerB.name);
	fprint(output, ", 1\n");

	fprint(output, "	");
	fprint(output, cmov);
	fprint(output, " ");
	fprint(output, registerA.name);
	fprint(output, ", ");
	fprint(output, registerB.name);
	fprint(output, " ;; comparison\n");

	registerB.used = (bool)0;
	return registerA.name;
}

func writePushData(int output, Register register) {
	fprint(output, "	xchg rsp, [datarsp]\n");

	fprint(output, "	push ");
	fprint(output, register.name);
	fprint(output, "\n");

	fprint(output, "	xchg rsp, [datarsp]\n\n");

	register.used = (bool)0;
}

func writePopData(int output, Register register) {
	fprint(output, "	xchg rsp, [datarsp]\n");

	fprint(output, "	pop ");
	fprint(output, register.name);
	fprint(output, "\n");

	fprint(output, "	xchg rsp, [datarsp]\n");
}

func writeJumpNotEqual(int output, Register register, str addr, int id) {
	fprint(output, "	cmp ");
	fprint(output, register.name);
	fprint(output, ", 0\n");
	fprint(output, "	je ");
	fprint(output, addr);
	fprinti(output, id);
	fprint(output, "\n\n");

	register.used = (bool)0;
}

func writeJumpEqual(int output, Register register, str addr, int id) {
	fprint(output, "	cmp ");
	fprint(output, register.name);
	fprint(output, ", 0\n");
	fprint(output, "	jne ");
	fprint(output, addr);
	fprinti(output, id);
	fprint(output, "\n\n");

	register.used = (bool)0;
}

func writeJump(int output, str addr, int id) {
	fprint(output, "	jmp ");
	fprint(output, addr);
	fprinti(output, id);
	fprint(output, "\n\n");
}

func writeAddress(int output, str addr, int id) {
	fprint(output, addr);
	fprinti(output, id);
	fprint(output, ":\n\n");
}

func writeSizeOf(Parser parser, SyntaxTree tree, Block block, int output, SizeOf sizeOf, str register) -> str {
	var typeDef = getTypeDefinitionFromType(parser, tree, block, sizeOf.typeObj);

	if (typeDef == (TypeDefinition)0) {
		printPosition(sizeOf.region.start);
		print(" type is null in size of\n");
		return register;
	}

	var size = getSizeFromType(parser, tree, block, typeDef, (bool)0);

	fprint(output, "	mov ");
	fprint(output, register);
	fprint(output, ", ");
	fprinti(output, size);
	fprint(output, " ;; type size\n");

	return register;
}

func writeOperation(Parser parser, SyntaxTree tree, Block block, int output, Operation operation, RegisterList registers, Register registerA, bool getValue, FunctionList functions) -> str {
	func writeCall(Parser parser, SyntaxTree tree, Block block, int output, Operation call, RegisterList registers, Register register, FunctionList functions) -> str {
		var name = operation.left.value.name.name;
		var id = 0;
		var i = 0;
		while (i < functions.size) {
			if (streq(functions.list[i].name.name, name)) {
			id = i;
			i = functions.size;
			}
			i = i + 1;
		}

		var arguments = createOperationList();

		if (operation.right != (Operation)0) {
			getArguments(arguments, operation.right);
		}

		i = 0;
		while (i < registers.size) {
			var reg = registers.list[i];
			if (reg.used && reg != register) {
			writePushData(output, reg);
			reg.used = (bool)1; // writePush frees register, but in this case we just do that temporarily, because the function we are calling might use the same ones
			}
			i = i + 1;
		}

		i = 0;
		while (i < arguments.size) {
			var argumentRegister = getRegister(registers);
			writeOperation(parser, tree, block, output, arguments.list[i], registers, argumentRegister, (bool)1, functions);
			writePushData(output, argumentRegister);
			i = i + 1;
		}

		fprint(output, "	call addr_func_");
		fprint(output, functions.list[id].name.name);
		fprint(output, "_");
		fprinti(output, id);
		fprint(output, "\n");

		if (streq(register.name, "rax") != (bool)1) {
			fprint(output, "	mov ");
			fprint(output, register.name);
			fprint(output, ", rax ;; return value\n");
		}

		i = 0;
		while (i < registers.size) {
			var reg = registers.list[i];
			if (reg.used && reg != register) {
			writePopData(output, reg);
			}
			i = i + 1;
		}

		return register.name;
	}

	func writeNegative(Parser parser, SyntaxTree tree, Block block, int output, Operation operation, RegisterList registers, Register register, FunctionList functions) -> str {
		writeOperation(parser, tree, block, output, operation.right, registers, register, (bool)1, functions);

		fprint(output, "	neg ");
		fprint(output, register.name);
		fprint(output, " ;; negative\n");

		return register.name;
	}

	func writeMultiplication(Parser parser, SyntaxTree tree, Block block, int output, Operation operation, RegisterList registers, Register register, FunctionList functions) -> str {
		var rax = findRegister(registers, "rax");

		var registerB = register;

		if (rax.used) {
			writeOperation(parser, tree, block, output, operation.left, registers, register, (bool)1, functions);
			registerB = getRegister(registers);
		} else {
			rax.used = (bool)1;
			writeOperation(parser, tree, block, output, operation.left, registers, rax, (bool)1, functions);
		}

		writeOperation(parser, tree, block, output, operation.right, registers, registerB, (bool)1, functions);

		if (register != registerB && register != rax) {
			writePushData(output, rax);
			rax.used = (bool)1;

			fprint(output, "	mov rax, ");
			fprint(output, register.name);
			fprint(output, "\n");
		}

		fprint(output, "	mul ");
		fprint(output, registerB.name);
		fprint(output, " ;; multiplication\n");

		if (register != rax) {
			fprint(output, "	mov ");
			fprint(output, register.name);
			fprint(output, ", rax\n");

			rax.used = (bool)0;
		}

		if (register != registerB) {
			registerB.used = (bool)0;
		}

		if (register != registerB && register != rax) {
			writePopData(output, rax);
			rax.used = (bool)1;
		}

		return register.name;
	}

	func writeShift(Parser parser, SyntaxTree tree, Block block, int output, str shiftWord, Operation operation, RegisterList registers, Register register, FunctionList functions) -> str {
		var rcx = findRegister(registers, "rcx");

		var leftReg = register;

		if (rcx.used) {
			leftReg = getRegister(registers);
			writeOperation(parser, tree, block, output, operation.left, registers, leftReg, (bool)1, functions);

			writeOperation(parser, tree, block, output, operation.right, registers, register, (bool)1, functions);
		} else {
			writeOperation(parser, tree, block, output, operation.left, registers, leftReg, (bool)1, functions);

			rcx.used = (bool)1;
			writeOperation(parser, tree, block, output, operation.right, registers, rcx, (bool)1, functions);
		}

		if (register != leftReg && register != rcx) {
			writePushData(output, rcx);
			rcx.used = (bool)1;

			fprint(output, "	mov rcx, ");
			fprint(output, register.name);
			fprint(output, "\n");
		}

		fprint(output, "	");
		fprint(output, shiftWord);
		fprint(output, " ");
		fprint(output, leftReg.name);
		fprint(output, ", cl ;; shift\n");

		if (register != leftReg && register != rcx) {
			writePopData(output, rcx);
		}

		if (leftReg != register) {
			fprint(output, "	mov ");
			fprint(output, register.name);
			fprint(output, ", ");
			fprint(output, leftReg.name);
			fprint(output, "\n");

			leftReg.used = (bool)0;
		} else {
			rcx.used = (bool)0;
		}

		return register.name;
	}

	func writeProperty(Parser parser, SyntaxTree tree, Block block, int output, Operation operation, RegisterList registers, Register register, bool getValue, FunctionList functions) -> str {
		writeOperation(parser, tree, block, output, operation.left, registers, register, (bool)1, functions);

		var typeObj = checkTypesInOperation(parser, tree, block, operation.left);

		if (typeObj == (TypeDefinition)0) {
			printPosition(operation.operator.position);
			print(" struct type is null\n");
			return register.name;
		}

		var propertyName = operation.right.value.name;
		var propertyType = checkTypesInOperation(parser, tree, block, operation);

		if (propertyType == (TypeDefinition)0) {
			printPosition(operation.operator.position);
			print(" type of property is null\n");
			return register.name;
		}

		var offset = getPropertyOffset(parser, tree, block, typeObj, propertyName.name);
		
		if (getValue) {
			fprint(output, "	mov ");
			fprint(output, register.name);
			fprint(output, ", [");
			fprint(output, register.name);

			if (offset != 0) {
				fprint(output, " + ");
				fprinti(output, offset);
			}

			fprint(output, "] ;; read offset\n");

			var propertySize = getSizeFromType(parser, tree, block, propertyType, (bool)1);

			if (propertySize != 8) {
				var mask = (1 << (8 * propertySize)) - 1;

				fprint(output, "	and ");
				fprint(output, register.name);
				fprint(output, ", ");
				fprinti(output, mask);
				fprint(output, " ;; mask\n");
			}
		} else if (offset != 0) {
			fprint(output, "	add ");
			fprint(output, register.name);
			fprint(output, ", ");
			fprinti(output, offset);
			fprint(output, " ;; property offset\n");
		}

		return register.name;
	}

	func writeAssignment(Parser parser, SyntaxTree tree, Block block, int output, Operation operation, RegisterList registers, Register register, FunctionList functions) -> str {
		writeOperation(parser, tree, block, output, operation.left, registers, register, (bool)0, functions);

		var valueRegister = getRegister(registers);
		writeOperation(parser, tree, block, output, operation.right, registers, valueRegister, (bool)1, functions);

		if (isOperator(operation.left.operator, "[")) {
			var arrayType = checkTypesInOperation(parser, tree, block, operation.left);

			if (arrayType == (TypeDefinition)0) {
				printPosition(operation.operator.position);
				print(" array type is null\n");
				return register.name;
			}

			var size = getSizeFromType(parser, tree, block, arrayType, (bool)1);

			var movWord = "mov";
			if (size != 8) {
				var mask = (1 << (8 * size)) - 1;
				var inverseMask = -mask - 1; //We do not have a bitwise not operation yet

				fprint(output, "	and qword [");
				fprint(output, register.name);
				fprint(output, "], ");
				fprinti(output, inverseMask);
				fprint(output, " ;; mask\n");

				movWord = "add";
			}

			fprint(output, "	");
			fprint(output, movWord);
			fprint(output, " [");
			fprint(output, register.name);
			fprint(output, "], ");
			fprint(output, valueRegister.name);
			fprint(output, " ;; assign to list\n");
		} else if (isOperator(operation.left.operator, ".")) {
			var propertyType = checkTypesInOperation(parser, tree, block, operation.left);

			if (propertyType == (TypeDefinition)0) {
				printPosition(operation.operator.position);
				print(" type is null\n");
				return register.name;
			}

			var size = getSizeFromType(parser, tree, block, propertyType, (bool)1);

			var movWord = "mov";
			if (size != 8) {
				var mask = (1 << (8 * size)) - 1;
				var inverseMask = -mask - 1; //We do not have a bitwise not operation yet

				fprint(output, "	and qword [");
				fprint(output, register.name);
				fprint(output, "], ");
				fprinti(output, inverseMask);
				fprint(output, " ;; mask\n");

				movWord = "add";
			}

			fprint(output, "	");
			fprint(output, movWord);
			fprint(output, " [");
			fprint(output, register.name);
			fprint(output, "], ");
			fprint(output, valueRegister.name);
			fprint(output, " ;; assign to property\n");
		} else if (operation.left.value != (Value)0) {
			fprint(output, "	mov [");
			fprint(output, register.name);
			fprint(output, "], ");
			fprint(output, valueRegister.name);
			fprint(output, " ;; assign to variable\n");
		} else {
			printPosition(operation.operator.position);
			print(" assignment of this kind is not yet supported\n");
		}

		valueRegister.used = (bool)0;
		return register.name;
	}

	func writeAnd(Parser parser, SyntaxTree tree, Block block, int output, Operation operation, RegisterList registers, Register register, FunctionList functions) -> str {
		writeOperation(parser, tree, block, output, operation.left, registers, register, (bool)1, functions);

		var andId = parser.numAnds;

		writeJumpNotEqual(output, register, "addr_and_", andId);
		register.used = (bool)1;

		parser.numAnds = parser.numAnds + 1;

		writeOperation(parser, tree, block, output, operation.right, registers, register, (bool)1, functions);

		writeAddress(output, "addr_and_", andId);

		return register.name;
	}

	func writeOr(Parser parser, SyntaxTree tree, Block block, int output, Operation operation, RegisterList registers, Register register, FunctionList functions) -> str {
		writeOperation(parser, tree, block, output, operation.left, registers, register, (bool)1, functions);

		var orId = parser.numOrs;

		writeJumpEqual(output, register, "addr_or_", orId);
		register.used = (bool)1;

		parser.numOrs = parser.numOrs + 1;

		writeOperation(parser, tree, block, output, operation.right, registers, register, (bool)1, functions);

		writeAddress(output, "addr_or_", orId);

		return register.name;
	}

	if (operation == (Operation)0) {
		print("operation is null\n");
		return (str)0;
	}

	if (registerA == (Register)0) {
		printPosition(operation.region.start);
		print(" register is null\n");
		return (str)0;
	}

	if (operation.value != (Value)0) {
		return writeValue(parser, tree, block, output, operation.value, registerA.name, getValue);
	}

	if (operation.sizeOf != (SizeOf)0) {
		return writeSizeOf(parser, tree, block, output, operation.sizeOf, registerA.name);
	}

	if (operation.operator == (Operator)0) {
		print("operator is null\n");
		return (str)0;
	}

	if (isOperator(operation.operator, "(") && operation.left != (Operation)0) {
		return writeCall(parser, tree, block, output, operation, registers, registerA, functions);
	}

	if (isOperator(operation.operator, "-") && operation.left == (Operation)0) {
		return writeNegative(parser, tree, block, output, operation, registers, registerA, functions);
	}

	if (isOperator(operation.operator, "*")) {
		return writeMultiplication(parser, tree, block, output, operation, registers, registerA, functions);
	}

	if (isOperator(operation.operator, "=")) {
		return writeAssignment(parser, tree, block, output, operation, registers, registerA, functions);
	}

	if (isOperator(operation.operator, "(")) {
		return writeOperation(parser, tree, block, output, operation.right, registers, registerA, getValue, functions);
	}

	if (isOperator(operation.operator, ".")) {
		return writeProperty(parser, tree, block, output, operation, registers, registerA, getValue, functions);
	}

	if (isOperator(operation.operator, "&&")) {
		return writeAnd(parser, tree, block, output, operation, registers, registerA, functions);
	}

	if (isOperator(operation.operator, "||")) {
		return writeOr(parser, tree, block, output, operation, registers, registerA, functions);
	}

	if (isOperator(operation.operator, "<<")) {
		return writeShift(parser, tree, block, output, "shl", operation, registers, registerA, functions);
	}

	if (isOperator(operation.operator, ">>")) {
		return writeShift(parser, tree, block, output, "shr", operation, registers, registerA, functions);
	}

	var registerB = getRegister(registers);

	writeOperation(parser, tree, block, output, operation.left, registers, registerA, (bool)1, functions);
	writeOperation(parser, tree, block, output, operation.right, registers, registerB, (bool)1, functions);

	var operationString = (str)0;
	if (isOperator(operation.operator, "==")) {
		return writeComparison(output, "cmove", registerA, registerB);
	} else if (isOperator(operation.operator, "!=")) {
		return writeComparison(output, "cmovne", registerA, registerB);
	} else if (isOperator(operation.operator, "<")) {
		return writeComparison(output, "cmovl", registerA, registerB);
	} else if (isOperator(operation.operator, ">")) {
		return writeComparison(output, "cmovg", registerA, registerB);
	} else if (isOperator(operation.operator, "<=")) {
		return writeComparison(output, "cmovle", registerA, registerB);
	} else if (isOperator(operation.operator, ">=")) {
		return writeComparison(output, "cmovge", registerA, registerB);
	} else if (isOperator(operation.operator, "[")) {
		var typeObj = checkTypesInOperation(parser, tree, block, operation);

		if (typeObj == (TypeDefinition)0) {
			printPosition(operation.operator.position);
			print(" array type is null\n");
			return registerA.name;
		}

		var size = getSizeFromType(parser, tree, block, typeObj, (bool)1);
		return writeIndex(output, size, registerA, registerB, getValue);
	} else if (isOperator(operation.operator, "+")) {
		operationString = "add";
	} else if (isOperator(operation.operator, "-")) {
		operationString = "sub";
	} else if (isOperator(operation.operator, "&")) {
		operationString = "and";
	} else if (isOperator(operation.operator, "|")) {
		operationString = "or";
	} else {
		print("do not support operator '");
		print(operation.operator.name);
		print("' yet\n");

		registerB.used = (bool)0;
		return (str)0;
	}

	writeBinaryOperation(output, operationString, registerA.name, registerB.name);
	registerB.used = (bool)0;

	return registerA.name;
}

func writeVariable(Parser parser, SyntaxTree tree, Block block, int output, VariableDefinition variable, RegisterList registers, FunctionList functions) {
	var register = getRegister(registers);
	writeOperation(parser, tree, block, output, variable.value, registers, register, (bool)1, functions);
	writePushData(output, register);
}

func writeReturn(Parser parser, SyntaxTree tree, Block block, int output, Return returnStatement, RegisterList registers, FunctionList functions) {
	if (returnStatement.expression != (Operation)0) {
		var rax = findRegister(registers, "rax");
		rax.used = (bool)1;

		writeOperation(parser, tree, block, output, returnStatement.expression, registers, rax, (bool)1, functions);
		rax.used = (bool)0;
	}

	var numVariables = 0;

	while (block.function == (FunctionDefinition)0) {
		var i = 0;
		while (i < block.variables.size) {
			if (block.variables.list[i].region.start.index < returnStatement.region.start.index) {
				numVariables = numVariables + 1;
			} else {
				i = block.variables.size;
			}

			i = i + 1;
		}

		block = block.outer;
	}

	var i = 0;
	while (i < block.variables.size) {
		if (block.variables.list[i].region.start.index < returnStatement.region.start.index) {
			numVariables = numVariables + 1;
		} else {
			i = block.variables.size;
		}

		i = i + 1;
	}

	fprint(output, "	xchg rsp, [datarsp]\n");

	if (numVariables != 0) {
		fprint(output, "	add rsp, ");
		fprinti(output, numVariables * 8);
		fprint(output, " ;; pop local variables\n");
	}

	var basePointer = getRegister(registers);
	var baseValue = getRegister(registers);

	fprint(output, "	lea ");
	fprint(output, basePointer.name);
	fprint(output, ", [basestack + ");
	fprinti(output, block.depth * 8);
	fprint(output, "]\n");

	fprint(output, "	pop ");
	fprint(output, baseValue.name);
	fprint(output, "\n");

	fprint(output, "	mov [");
	fprint(output, basePointer.name);
	fprint(output, "], ");
	fprint(output, baseValue.name);
	fprint(output, " ;; restore base pointer\n");

	basePointer.used = (bool)0;
	baseValue.used = (bool)0;

	if (block.function.parameters == (ParameterList)0) {
		print("parameter list is null\n");
		return;
	}

	if (block.function.parameters.size != 0) {
		fprint(output, "	add rsp, ");
		fprinti(output, block.function.parameters.size * 8);
		fprint(output, " ;; pop parameters\n");
	}

	fprint(output, "	xchg rsp, [datarsp]\n");
	fprint(output, "	ret\n\n");
}

func writeStatementList(Parser parser, SyntaxTree tree, Block block, int output, StatementList statements, RegisterList registers, FunctionList functions) {
	func writeBlock(Parser parser, SyntaxTree tree, Block outer, int output, Block block, RegisterList registers, FunctionList functions) {
		writeStatementList(parser, tree, block, output, block.statements, registers, functions);

		if (block.variables.size > 0) {
			fprint(output, "	add qword [datarsp], ");
			fprinti(output, block.variables.size * 8);
			fprint(output, " ;; pop local variables in block\n");
		}
	}

	func writeIf(Parser parser, SyntaxTree tree, Block block, int output, If ifStatement, RegisterList registers, FunctionList functions) {
		var conditionRegister = getRegister(registers);
		writeOperation(parser, tree, block, output, ifStatement.condition, registers, conditionRegister, (bool)1, functions);
		writeJumpNotEqual(output, conditionRegister, "addr_if_", ifStatement.id);

		conditionRegister.used = (bool)0;

		writeBlock(parser, tree, block, output, tree.blocks.list[ifStatement.blockId], registers, functions);

		if (ifStatement.elseIfs.size != 0 || ifStatement.elseObj != (Else)0) {
			writeJump(output, "addr_if_end_", ifStatement.id);
		}

		writeAddress(output, "addr_if_", ifStatement.id);
		var i = 0;
		while (i < ifStatement.elseIfs.size) {
			var elseIf = ifStatement.elseIfs.list[i];
			var conditionRegister = getRegister(registers);
			writeOperation(parser, tree, block, output, elseIf.condition, registers, conditionRegister, (bool)1, functions);
			writeJumpNotEqual(output, conditionRegister, "addr_if_", elseIf.id);

			writeBlock(parser, tree, block, output, tree.blocks.list[elseIf.blockId], registers, functions);

			writeJump(output, "addr_if_end_", ifStatement.id);
			writeAddress(output, "addr_if_", elseIf.id);
			i = i + 1;
		}

		if (ifStatement.elseObj != (Else)0) {
			writeBlock(parser, tree, block, output, tree.blocks.list[ifStatement.elseObj.blockId], registers, functions);
		}

		if (ifStatement.elseIfs.size != 0 || ifStatement.elseObj != (Else)0) {
			writeAddress(output, "addr_if_end_", ifStatement.id);
		}
	}

	func writeWhile(Parser parser, SyntaxTree tree, Block block, int output, While whileStatement, RegisterList registers, FunctionList functions) {
		var conditionRegister = getRegister(registers);

		writeAddress(output, "addr_while_condition_", whileStatement.id);

		writeOperation(parser, tree, block, output, whileStatement.condition, registers, conditionRegister, (bool)1, functions);
		writeJumpNotEqual(output, conditionRegister, "addr_while_end_", whileStatement.id);

		conditionRegister.used = (bool)0;

		writeBlock(parser, tree, block, output, tree.blocks.list[whileStatement.blockId], registers, functions);

		writeJump(output, "addr_while_condition_", whileStatement.id);
		writeAddress(output, "addr_while_end_", whileStatement.id);
	}

	func writeStatement(Parser parser, SyntaxTree tree, Block block, int output, Statement statement, RegisterList registers, FunctionList functions) {
		if (statement.expression != (Expression)0) {
			var register = getRegister(registers);
			writeOperation(parser, tree, block, output, statement.expression.operation, registers, register, (bool)1, functions);
			fprint(output, "\n");

			register.used = (bool)0;
		} else if (statement.ifStatement != (If)0) {
			writeIf(parser, tree, block, output, statement.ifStatement, registers, functions);
		} else if (statement.whileStatement != (While)0) {
			writeWhile(parser, tree, block, output, statement.whileStatement, registers, functions);
		} else if (statement.variable != (VariableDefinition)0) {
			writeVariable(parser, tree, block, output, statement.variable, registers, functions);
		} else if (statement.returnStatement != (Return)0) {
			writeReturn(parser, tree, block, output, statement.returnStatement, registers, functions);
		}
	}

	var i = 0;

	while (i < statements.size) {
		writeStatement(parser, tree, block, output, statements.list[i], registers, functions);
		i = i + 1;
	}
}

func writeFunctionDefinition(Parser parser, SyntaxTree tree, int output, FunctionDefinition function, RegisterList registers, FunctionList functions, int id) {
	fprint(output, "addr_func_");
	fprint(output, function.name.name);
	fprint(output, "_");
	fprinti(output, id);
	fprint(output, ":\n");

	var block = tree.blocks.list[function.blockId];

	var basePointer = getRegister(registers);
	var baseValue = getRegister(registers);
	var stackPointer = getRegister(registers);

	fprint(output, "	lea ");
	fprint(output, basePointer.name);
	fprint(output, ", [basestack + ");
	fprinti(output, block.depth * 8);
	fprint(output, "]\n");

	fprint(output, "	xchg rsp, [datarsp]\n");

	fprint(output, "	mov ");
	fprint(output, baseValue.name);
	fprint(output, ", [");
	fprint(output, basePointer.name);
	fprint(output, "]\n");

	fprint(output, "	push ");
	fprint(output, baseValue.name);
	fprint(output, "\n");

	fprint(output, "	mov ");
	fprint(output, stackPointer.name);
	fprint(output, ", rsp\n");

	fprint(output, "	xchg rsp, [datarsp]\n");

	if (function.parameters.size != 0) {
		fprint(output, "	add ");
		fprint(output, stackPointer.name);
		fprint(output, ", ");
		fprinti(output, function.parameters.size * 8);
		fprint(output, "\n");
	}

	fprint(output, "	mov [");
	fprint(output, basePointer.name);
	fprint(output, "], ");
	fprint(output, stackPointer.name);
	fprint(output, "\n\n");

	basePointer.used = (bool)0;
	baseValue.used = (bool)0;
	stackPointer.used = (bool)0;

	writeStatementList(parser, tree, block, output, block.statements, registers, functions);

	if (function.returnType == (ReturnType)0) {
		fprint(output, "	xchg rsp, [datarsp]\n");

		if (block.variables.size != 0) {
			fprint(output, "	add rsp, ");
			fprinti(output, block.variables.size * 8);
			fprint(output, " ;; pop local variables\n");
		}

		var basePointer = getRegister(registers);
		var baseValue = getRegister(registers);

		fprint(output, "	lea ");
		fprint(output, basePointer.name);
		fprint(output, ", [basestack + ");
		fprinti(output, block.depth * 8);
		fprint(output, "]\n");

		fprint(output, "	pop ");
		fprint(output, baseValue.name);
		fprint(output, "\n");

		fprint(output, "	mov [");
		fprint(output, basePointer.name);
		fprint(output, "], ");
		fprint(output, baseValue.name);
		fprint(output, " ;; restore base pointer\n");

		basePointer.used = (bool)0;
		baseValue.used = (bool)0;

		if (function.parameters.size != 0) {
			fprint(output, "	add rsp, ");
			fprinti(output, function.parameters.size * 8);
			fprint(output, " ;; pop parameters\n");
		}

		fprint(output, "	xchg rsp, [datarsp]\n");
		fprint(output, "	ret\n\n");
	}
}

func checkFiles(str fileName) -> Parser {
	var parser = createParser();

	parse(parser, fileName, (str)0);

	var numFilesNamesBound = 0;
	while (numFilesNamesBound < parser.files.size) {
		var fileName = parser.files.list[numFilesNamesBound].fileName;
		bindNames(parser, fileName);
		numFilesNamesBound = numFilesNamesBound + 1;
	}

	var numImportedVars = 0;
	var files = 1;
	while (files < parser.files.size) {
		numImportedVars = numImportedVars + parser.files.list[files].variables.size;
		files = files + 1;
	}

	var tree = parser.files.list[0];
	var i = 0;

	while (i < tree.variables.size) {
		var variable = tree.variables.list[i];
		variable.position = variable.position + numImportedVars;
		i = i + 1;
	}

	print("[FILE] parsed files\n");

	var numFilesTypeChecked = parser.files.size - 1;
	while (numFilesTypeChecked >= 0) {
		var tree = parser.files.list[numFilesTypeChecked];
		checkTypes(parser, tree);
		numFilesTypeChecked = numFilesTypeChecked - 1;
	}

	print("[FILE] type checked files\n");

	return parser;
}

func createChild(str name, str[] args) -> int {
	var child_pid = fork();
	if (child_pid < 0) {
		print("[ERROR] could not generate child process to call '");
		print(name);
		print("'\n");
		exit(1);
	}

	if (child_pid > 0) {
		print("[CMD]");
		var i = 0;
		while (args[i] != (str)0) {
			print(" ");
			print(args[i]);
			i = i + 1;
		}
		print(" \n");
	} else {
		var returnCode = execvp(name, args);
		print("[ERROR] problem occurred when trying to call ");
		print(name);
		print(": error code: ");
		printi(returnCode);
		print(" \n");
		exit(1);
	}

	return child_pid;
}

func CompileLinuxx86_nasm(str fileName, bool debug) {
	var parser = checkFiles(fileName);

	print("[FILE] checked file: '");
	print(fileName);
	print("'\n");

	const O_WRONLY = 1;
	const O_CREAT = 64;
	const O_TRUNC = 512;

	const ALLOW_ALL = 511;
	var output = open("output.asm", O_WRONLY | O_CREAT | O_TRUNC, ALLOW_ALL);

	var registers = initRegisters();

	var functions = listFunctions(parser);
	writeHeader(output);

	var i = parser.functions.size;
	while (i < functions.size) {
		var function = functions.list[i];
		var tree = findSyntaxTree(parser.files, function.region.file);

		writeFunctionDefinition(parser, tree, output, function, registers, functions, i);

		i = i + 1;
	}

	writeStart(output);

	// write all imported files in order of importing, then write main file
	// TODO: clean up how imports work, link: https://github.com/TheLazyDutchmen/Lumina/issues/40
	var filesWritten = 1;
	while (filesWritten < parser.files.size) {
		var tree = parser.files.list[filesWritten];

		fprint(output, ";; starting file: '");
		fprint(output, tree.fileName);
		fprint(output, "'\n");

		writeStatementList(parser, tree, (Block)0, output, tree.statements, registers, functions);

		filesWritten = filesWritten + 1;
	}

	var tree = parser.files.list[0];
	writeStatementList(parser, tree, (Block)0, output, tree.statements, registers, functions);

	writeFooter(output, parser.strings);

	var nasmDebugArgs = (str[])malloc(8 * 8); // ptr size is 8
	nasmDebugArgs[0] = "nasm";
	nasmDebugArgs[1] = "-f";
	nasmDebugArgs[2] = "elf64";
	nasmDebugArgs[3] = "-F";
	nasmDebugArgs[4] = "dwarf";
	nasmDebugArgs[5] = "-g";
	nasmDebugArgs[6] = "output.asm";
	nasmDebugArgs[7] = (str)0;

	var nasmArgs = (str[])malloc(8 * 5); // ptr size is 8
	nasmArgs[0] = "nasm";
	nasmArgs[1] = "-f";
	nasmArgs[2] = "elf64";
	nasmArgs[3] = "output.asm";
	nasmArgs[4] = (str)0;

	var nasm_pid = 0;
	if (debug) {
		nasm_pid = createChild("nasm", nasmDebugArgs);
	} else {
		nasm_pid = createChild("nasm", nasmArgs);
	}

	var nasmStatus = (int[])malloc(8); // pointer to int
	if (wait4(nasm_pid, nasmStatus, 0, (ptr)0) < 0) {
		print("[ERROR] wait4 failed\n");
		exit(1);
	}
	
	if (WIFEXITED(nasmStatus[0])) {
		var code = WIFEXITSTATUS(nasmStatus[0] & 127);
		if (code > 0) {
			print("[ERROR] in nasm, error code: ");
			printi(code);
			print(" \n");
			exit(code);
		}
	}

	var linkerArgs = (str[])malloc(8 * 5);
	linkerArgs[0] = "ld";
	linkerArgs[1] = "-o";
	linkerArgs[2] = "output";
	linkerArgs[3] = "output.o";
	linkerArgs[4] = (str)0;

	var linkerStatus = (int[])malloc(8); // pointer to int
	var linker_pid = createChild("ld", linkerArgs);

	if (wait4(linker_pid, linkerStatus, 0, (ptr)0) < 0) {
		print("[ERROR] wait4 failed\n");
		exit(1);
	}

	if (WIFEXITED(linkerStatus[0])) {
		var code = WIFEXITSTATUS(linkerStatus[0] & 127);
		if (code > 0) {
			print("[ERROR] in linker, error code: ");
			printi(code);
			print(" \n");
			exit(code);
		}
	}
}

if (argc < 2) {
	print("[ERROR] expected argument <filename>\n");
	exit(1);
}

var debug = (bool)0;

if (streq(argv[1], "-debug")) {
	debug = (bool)1;
}

if (argc > 3) {
	print("[ERROR] expected at max 3 arguments\n");
	exit(1);
}

var fileName = argv[1];
if (debug) {
	fileName = argv[2];
}

CompileLinuxx86_nasm(fileName, debug);
