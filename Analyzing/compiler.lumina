import "../std/io.lumina"
import "../std/syscalls.lumina"
import "../std/memory.lumina"
import "../std/string.lumina"

import "parser.lumina"
import "operation.lumina"
import "operator.lumina"
import "statement.lumina"
import "expression.lumina"
import "if.lumina"
import "while.lumina"
import "variable.lumina"
import "function.lumina"
import "value.lumina"
import "immediate.lumina"
import "lexer.lumina"
import "name.lumina"
import "block.lumina"
import "position.lumina"


type Register {
    str name;
    bool used;
}

type RegisterList {
    int size;
    int maxSize;
    Register[] list;
}

const CALLSTACKSIZE =  2048;

func createRegister(str name) -> Register {
    var reg = (Register)malloc(sizeof(Register));

    reg.name = name;
    reg.used = (bool)0;

    return reg;
}

func createRegisterList() -> RegisterList {
    var list = (RegisterList)malloc(sizeof(RegisterList));

    list.size = 0;
    list.maxSize = 8;
    list.list = (Register[])malloc(8 * 8);

    return list;
}

func addRegister(RegisterList list, Register reg) {
    list.list[list.size] = reg;
    list.size = list.size + 1;

    if (list.size == list.maxSize) {
	list.list = (Register[])realloc((ptr)list.list, list.maxSize * 8, list.maxSize * 8 * 2);
	list.maxSize = list.maxSize * 2;
    }
}

func findRegister(RegisterList list, str name) -> Register {
    var i = 0;
    while (i < list.size) {
	if (streq(list.list[i].name, name)) {
	    return list.list[i];
	}
	i = i + 1;
    }
    return (Register)0;
}

func getRegister(RegisterList list) -> Register {
    var i = 0;
    while (i < list.size) {
	if (list.list[i].used != (bool)1) {
	    list.list[i].used = (bool)1;
	    return list.list[i];
	}
	i = i + 1;
    }
    return (Register)0;
}

func initRegisters() -> RegisterList {
    var registers = createRegisterList();
    addRegister(registers, createRegister("r8"));
    addRegister(registers, createRegister("r9"));
    addRegister(registers, createRegister("r10"));
    addRegister(registers, createRegister("r11"));
    addRegister(registers, createRegister("r12"));
    addRegister(registers, createRegister("r13"));
    addRegister(registers, createRegister("r14"));
    addRegister(registers, createRegister("r15"));
    addRegister(registers, createRegister("rax"));
    addRegister(registers, createRegister("rbx"));
    addRegister(registers, createRegister("rcx"));
    addRegister(registers, createRegister("rdx"));

    return registers;
}

func writeHeader(int output) {
    fprint(output, "section .text\n");
    fprint(output, "global _start\n");
    fprint(output, "	;; -- syscall builtin --\n");
    fprint(output, "addr_func_syscall_0:\n");
    fprint(output, "	pop rbx ;; return address\n");
	fprint(output, "	pop r9\n");
	fprint(output, "	pop r8\n");
	fprint(output, "	pop r10\n");
	fprint(output, "	pop rdx\n");
	fprint(output, "	pop rsi\n");
	fprint(output, "	pop rdi\n");
	fprint(output, "	pop rax\n");
	fprint(output, "	syscall\n");

	fprint(output, "	push rbx\n");
	fprint(output, "	ret\n");
}

func writeStart(int output) {
    fprint(output, "_start:\n");
    fprint(output, "	lea rax, [datastack + ");
    fprinti(output, CALLSTACKSIZE);
    fprint(output, "]\n");
    fprint(output, "	mov [basestack], rax\n");
    fprint(output, "	xchg rsp, rax\n");
    fprint(output, "	add rax, 8\n");
    fprint(output, "	push rax\n");
    fprint(output, "	sub rax, 8\n");
    fprint(output, "	mov rbx, [rax]\n");
    fprint(output, "	push rbx\n");
    fprint(output, "	xchg rsp, rax\n");
    fprint(output, "	mov [datarsp], rax\n\n");
}

func writeFooter(int output) {
    fprint(output, "	mov rax, 60\n");
    fprint(output, "	xor rdi, rdi\n");
    fprint(output, "	syscall\n\n");

    fprint(output, "section .bss\n");

    fprint(output, "	basestack: resq ");
    fprinti(output, CALLSTACKSIZE);
    fprint(output, "\n");

    fprint(output, "	datarsp: resq 1\n");
    fprint(output, "	datastack: resq ");
    fprinti(output, CALLSTACKSIZE);
    fprint(output, "\n");
    
    fprint(output, "section .data\n");
    //TODO: write strings
}

func writeIdentifier(Parser parser, SyntaxTree tree, Block block, int output, Name name, str register, bool getValue) -> str {
    var variable = (VariableDefinition)0;
    if (block != (Block)0) {
	variable = findVariableInBlock(parser, tree, block, name.name);
    }

    if (variable == (VariableDefinition)0) {
	variable = findVariable(tree.variables, name.name);
    }

    if (variable == (VariableDefinition)0) {
	variable = findVariable(parser.variables, name.name);
    }

    if (variable == (VariableDefinition)0) {
	print("variable: '");
	print(name.name);
	print("' not found\n");
	return (str)0;
    }

    fprint(output, "	mov ");
    fprint(output, register);

    if (variable.depth == 0) {
	fprint(output, ", [basestack]\n");
    } else {
	fprint(output, ", [basestack + ");
	fprinti(output, 8 * variable.depth);
	fprint(output, "]\n");
    }

    if (variable.position != 0) {
	fprint(output, "	sub ");
	fprint(output, register);
	fprint(output, ", ");
	fprinti(output, 8 * variable.position);
	fprint(output, "\n");
    }

    if (getValue) {
	fprint(output, "	mov ");
	fprint(output, register);
	fprint(output, ", [");
	fprint(output, register);
	fprint(output, "] ;; variable\n");
    }

    return register;
}

func writeValue(Parser parser, SyntaxTree tree, Block block, int output, Value value, str register, bool getValue) -> str {
    if (value.number != (Number)0) {
	fprint(output, "	mov ");
	fprint(output, register);
	fprint(output, ", ");
	fprinti(output, value.number.value);
	fprint(output, " ;; number \n");
    } else if (value.character != (Character)0) {
	print("do not support characters yet\n");
    } else if (value.string != (String)0) {
	print("do not support strings yet\n");
    } else if (value.name != (Name)0) {
	writeIdentifier(parser, tree, block, output, value.name, register, getValue);
    }

    return register;
}

func writeBinaryOperation(int output, str operation, str registerA, str registerB) {
    fprint(output, "	");
    fprint(output, operation);
    fprint(output, " ");
    fprint(output, registerA);
    fprint(output, ", ");
    fprint(output, registerB);
    fprint(output, "\n");
}

func writeComparison(int output, str cmov, str registerA, str registerB) -> str {
    fprint(output, "	cmp ");
    fprint(output, registerA);
    fprint(output, ", ");
    fprint(output, registerB);
    fprint(output, "\n");
    
    fprint(output, "	mov ");
    fprint(output, registerA);
    fprint(output, ", 0\n");

    fprint(output, "	mov ");
    fprint(output, registerB);
    fprint(output, ", 1\n");

    fprint(output, "	");
    fprint(output, cmov);
    fprint(output, " ");
    fprint(output, registerA);
    fprint(output, ", ");
    fprint(output, registerB);
    fprint(output, " ;; comparison\n");

    return registerA;
}

func writeOperation(Parser parser, SyntaxTree tree, Block block, int output, Operation operation, RegisterList registers, Register registerA, bool getValue) -> str {
    if (operation == (Operation)0) {
	print("operation is null\n");
	return (str)0;
    }

    if (registerA == (Register)0) {
	printPosition(operation.region.start);
	print(" register is null\n");
	return (str)0;
    }

    //TODO: handle operations other than binary ones
    if (operation.value != (Value)0) {
	return writeValue(parser, tree, block, output, operation.value, registerA.name, getValue);
    }

    if (operation.operator == (Operator)0) {
	print("operator is null\n");
	return (str)0;
    }

    var registerB = getRegister(registers);

    writeOperation(parser, tree, block, output, operation.left, registers, registerA, getValue);
    writeOperation(parser, tree, block, output, operation.right, registers, registerB, getValue);

    var operationString = (str)0;
    if (isOperator(operation.operator, "==")) {
	registerB.used = (bool)0;
	return writeComparison(output, "move", registerA.name, registerB.name);
    } else if (isOperator(operation.operator, "!=")) {
	registerB.used = (bool)0;
	return writeComparison(output, "movne", registerA.name, registerB.name);
    } else if (isOperator(operation.operator, "<")) {
	registerB.used = (bool)0;
	return writeComparison(output, "movl", registerA.name, registerB.name);
    } else if (isOperator(operation.operator, ">")) {
	registerB.used = (bool)0;
	return writeComparison(output, "movg", registerA.name, registerB.name);
    } else if (isOperator(operation.operator, "<=")) {
	registerB.used = (bool)0;
	return writeComparison(output, "movle", registerA.name, registerB.name);
    } else if (isOperator(operation.operator, ">=")) {
	registerB.used = (bool)0;
	return writeComparison(output, "movge", registerA.name, registerB.name);
    } else if (isOperator(operation.operator, "+")) {
	operationString = "add";
    } else if (isOperator(operation.operator, "-")) {
	operationString = "sub";
    } else if (isOperator(operation.operator, "&")) {
	operationString = "and";
    } else if (isOperator(operation.operator, "|")) {
	operationString = "or";
    } else {
	print("do not support operator '");
	print(operation.operator.name);
	print("' yet\n");

	registerB.used = (bool)0;
	return (str)0;
    }

    writeBinaryOperation(output, operationString, registerA.name, registerB.name);
    registerB.used = (bool)0;

    return registerA.name;
}

func writeJumpNotEqual(int output, Register register, str addr, int id) {
    fprint(output, "	cmp ");
    fprint(output, register.name);
    fprint(output, ", 0\n");
    fprint(output, "	je ");
    fprint(output, addr);
    fprinti(output, id);
    fprint(output, "\n\n");

    register.used = (bool)0;
}

func writeJump(int output, str addr, int id) {
    fprint(output, "	jmp ");
    fprint(output, addr);
    fprinti(output, id);
    fprint(output, "\n\n");
}

func writeAddress(int output, str addr, int id) {
    fprint(output, addr);
    fprinti(output, id);
    fprint(output, ":\n\n");
}

func writePushData(int output, Register register) {
    fprint(output, "	xchg rsp, [datarsp]\n");

    fprint(output, "	push ");
    fprint(output, register.name);
    fprint(output, "\n");

    fprint(output, "	xchg rsp, [datarsp]\n\n");

    register.used = (bool)0;
}

func writeVariable(Parser parser, SyntaxTree tree, Block block, int output, VariableDefinition variable, RegisterList registers) {
    var register = getRegister(registers);
    writeOperation(parser, tree, block, output, variable.value, registers, register, (bool)1);
    writePushData(output, register);
}

func writeStatementList(Parser parser, SyntaxTree tree, Block block, int output, StatementList statements, RegisterList registers) {
    func writeBlock(Parser parser, SyntaxTree tree, Block outer, int output, Block block, RegisterList registers) {
	//TODO write block start
	writeStatementList(parser, tree, outer, output, block.statements, registers);
	//TODO write block end
    }

    func writeIf(Parser parser, SyntaxTree tree, Block block, int output, If ifStatement, RegisterList registers) {
	var conditionRegister = getRegister(registers);
	writeOperation(parser, tree, block, output, ifStatement.condition, registers, conditionRegister, (bool)1);
	writeJumpNotEqual(output, conditionRegister, "addr_if_", ifStatement.id);

	writeBlock(parser, tree, block, output, tree.blocks.list[ifStatement.blockId], registers);

	if (ifStatement.elseIfs.size != 0 || ifStatement.elseObj != (Else)0) {
	    writeJump(output, "addr_end_if_", ifStatement.id);
	}

	writeAddress(output, "addr_if_", ifStatement.id);
	var i = 0;
	while (i < ifStatement.elseIfs.size) {
	    var elseIf = ifStatement.elseIfs.list[i];
	    var conditionRegister = getRegister(registers);
	    writeOperation(parser, tree, block, output, elseIf.condition, registers, conditionRegister, (bool)1);
	    writeJumpNotEqual(output, conditionRegister, "addr_if_", elseIf.id);

	    writeBlock(parser, tree, block, output, tree.blocks.list[elseIf.blockId], registers);

	    writeJump(output, "addr_if_end_", ifStatement.id);
	    writeAddress(output, "addr_if_", elseIf.id);
	    i = i + 1;
	}

	if (ifStatement.elseObj != (Else)0) {
	    writeBlock(parser, tree, block, output, tree.blocks.list[ifStatement.elseObj.blockId], registers);
	}

	if (ifStatement.elseIfs.size != 0 || ifStatement.elseObj != (Else)0) {
	    writeAddress(output, "addr_end_if_", ifStatement.id);
	}
    }

    func writeWhile(Parser parser, SyntaxTree tree, Block block, int output, While whileStatement, RegisterList registers) {
	var conditionRegister = getRegister(registers);

	writeAddress(output, "addr_while_condition_", whileStatement.id);

	writeOperation(parser, tree, block, output, whileStatement.condition, registers, conditionRegister, (bool)1);
	writeJumpNotEqual(output, conditionRegister, "addr_while_end_", whileStatement.id);

	writeBlock(parser, tree, block, output, tree.blocks.list[whileStatement.blockId], registers);

	writeJump(output, "addr_while_condition_", whileStatement.id);
	writeAddress(output, "addr_while_end_", whileStatement.id);
    }

    func writeStatement(Parser parser, SyntaxTree tree, Block block, int output, Statement statement, RegisterList registers) {
	if (statement.expression != (Expression)0) {
	    var register = getRegister(registers);
	    writeOperation(parser, tree, block, output, statement.expression.operation, registers, register, (bool)1);
	    fprint(output, "\n");

	    register.used = (bool)0;
	} else if (statement.ifStatement != (If)0) {
	    writeIf(parser, tree, block, output, statement.ifStatement, registers);
	} else if (statement.whileStatement != (While)0) {
	    print("do not handle compiling while yet\n");
	} else if (statement.variable != (VariableDefinition)0) {
	    writeVariable(parser, tree, block, output, statement.variable, registers);
	} else if (statement.returnStatement != (Return)0) {
	    print("do not handle return yet\n");
	}
    }

    var i = 0;
    while (i < statements.size) {
	writeStatement(parser, tree, block, output, statements.list[i], registers);
	i = i + 1;
    }
}

func checkFiles(str fileName) -> Parser {
    var parser = createParser();

    parse(parser, fileName, (str)0);

    var numFilesNamesBound = 0;
    while (numFilesNamesBound < parser.files.size) {
	var fileName = parser.files.list[numFilesNamesBound].fileName;
	bindNames(parser, fileName);
	numFilesNamesBound = numFilesNamesBound + 1;
    }

    var numFilesTypeChecked = parser.files.size - 1;
    while (numFilesTypeChecked >= 0) {
	var tree = parser.files.list[numFilesTypeChecked];
	checkTypes(parser, tree);
	numFilesTypeChecked = numFilesTypeChecked - 1;
    }

    return parser;
}

func CompileLinuxx86_nasm(str fileName) {
    var parser = checkFiles(fileName);
    var tree = findSyntaxTree(parser.files, fileName);

    const O_WRONLY = 1;
    const O_CREAT = 64;
    const O_TRUNC = 512;

    const ALLOW_ALL = 511;
    var output = open("output.asm", O_WRONLY | O_CREAT | O_TRUNC, ALLOW_ALL);

    var registers = initRegisters();
    writeHeader(output);
    //TODO: write functions

    writeStart(output);
    writeStatementList(parser, tree, (Block)0, output, tree.statements, registers);
}

if (argc < 2) {
	print("[ERROR] expected argument <filename>\n");
	exit(1);
}

if (argc > 2) {
	print("[ERROR] expected a single argument\n");
	exit(1);
}

var fileName = argv[1];

CompileLinuxx86_nasm(fileName);
