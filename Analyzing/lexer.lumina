import "name.lumina"

// this is a type to hold the different possible tokens
type Token {
	Name name;
}

type Lexer {
	str file;
	str buffer;

	int index;
	int line;
	int column;
}

func readFile(str fileName) -> str {
	var flags = 0; //READONLY
	var mode = 0;

	var file = open(fileName, flags, mode);

	if (file < 0) {
		print("[ERROR] can not open file '");
		print(fileName);
		print("'\n");
		exit(1);
	}

	var SEEK_SET = 0;
	var SEEK_END = 2;

	var len = lseek(file, 0, SEEK_END);
	lseek(file, 0, SEEK_SET);

	var buffer = (str)malloc(len + 1);

	len = read(file, buffer, len);

	if (len < 0) {
		print("[ERROR] when reading file '");
		print(fileName);
		print("'\n");

		exit(1);
	}

	buffer[len] = '\0';

	close(file);

	return buffer;
}

func createLexer(str fileName) -> Lexer {
	var lexer = (Lexer)malloc(sizeof(Lexer));

	lexer.file = fileName;
	lexer.buffer = readFile(fileName);

	lexer.index = 0;
	lexer.line = 0;
	lexer.column = 0;

	return lexer;
}

func createToken() -> Token {
	var token = (Token)malloc(sizeof(Token));

	token.name = (Name)0;

	return token;
}

func current(Lexer lexer) -> char {
	return lexer.buffer[lexer.index];
}

func advance(Lexer lexer) {
	lexer.index = lexer.index + 1;
	lexer.column = lexer.column + 1;

	if (current(lexer) == '\n') {
		lexer.line = lexer.line + 1;
		lexer.column = 0;
	}
}

func handleComments(Lexer lexer) {
	if (current(lexer) != '\\') {
		return;
	}

	if (lexer.buffer[lexer.index + 1] != '\\') {
		return;
	}

	while (current(lexer) != '\n') {
		advance(lexer);
	}
}

func lexName(Lexer lexer, Token token) -> Token {
	var start = createPosition(lexer.file, lexer.buffer, lexer.index, lexer.line, lexer.column);

	while (isalnum(current(lexer)) || current(lexer) == '_') {
		advance(lexer);
	}

	var end = createPosition(lexer.file, lexer.buffer, lexer.index, lexer.line, lexer.column);

	token.name = createName(start, end);

	return token;
}

func nextToken(Lexer lexer) -> Token {
	var token = createToken();

	while (current(lexer) != '\0') {
		handleComments(lexer);

		if (isalpha(current(lexer)) || current(lexer) == '_') {
			return lexName(lexer, token);
		}

		advance(lexer);
	}

	return token;
}
