import "name.lumina"
import "immediate.lumina"

// this is a type to hold the different possible tokens
type Token {
	Name name;
	String string;
	Character character;
	Number number;
	bool isEOF;
}

type Lexer {
	str file;
	str buffer;

	int index;
	int line;
	int column;
}

func readFile(str fileName) -> str {
	var flags = 0; //READONLY
	var mode = 0;

	var file = open(fileName, flags, mode);

	if (file < 0) {
		print("[ERROR] can not open file '");
		print(fileName);
		print("'\n");
		exit(1);
	}

	var SEEK_SET = 0;
	var SEEK_END = 2;

	var len = lseek(file, 0, SEEK_END);
	lseek(file, 0, SEEK_SET);

	var buffer = (str)malloc(len + 1);

	len = read(file, buffer, len);

	if (len < 0) {
		print("[ERROR] when reading file '");
		print(fileName);
		print("'\n");

		exit(1);
	}

	buffer[len] = '\0';

	close(file);

	return buffer;
}

func createLexer(str fileName) -> Lexer {
	var lexer = (Lexer)malloc(sizeof(Lexer));

	lexer.file = fileName;
	lexer.buffer = readFile(fileName);

	lexer.index = 0;
	lexer.line = 0;
	lexer.column = 0;

	return lexer;
}

func createToken() -> Token {
	var token = (Token)malloc(sizeof(Token) * 2); // there is a bug with malloc, so we allocate more memory than needed

	token.name = (Name)0;
	token.string = (String)0;
	token.character = (Character)0;
	token.number = (Number)0;

	token.isEOF = (bool)0;

	return token;
}

func current(Lexer lexer) -> char {
	return lexer.buffer[lexer.index];
}

func advance(Lexer lexer) {
	lexer.index = lexer.index + 1;
	lexer.column = lexer.column + 1;

	if (current(lexer) == '\n') {
		lexer.line = lexer.line + 1;
		lexer.column = 0;
	}
}

func handleComments(Lexer lexer) {
	if (current(lexer) != '/') {
		return;
	}

	if (lexer.buffer[lexer.index + 1] != '/') {
		return;
	}

	while (current(lexer) != '\n') {
		advance(lexer);
	}
}

func createPositionFromLexer(Lexer lexer) -> Position {
	return createPosition(lexer.file, lexer.buffer, lexer.index, lexer.line, lexer.column);
}

func lexName(Lexer lexer, Token token) -> Token {
	var start = createPositionFromLexer(lexer);

	while (isalnum(current(lexer)) || current(lexer) == '_') {
		advance(lexer);
	}

	var end = createPositionFromLexer(lexer);

	token.name = createName(start, end);

	return token;
}

// TODO: add error handling for invalid character and string literals
func lexString(Lexer lexer, Token token) -> Token {
	var start = createPositionFromLexer(lexer);

	advance(lexer);

	while (current(lexer) != '"') {
		if (current(lexer) == '\\') {
			advance(lexer);
		}
		advance(lexer);
	}

	advance(lexer);

	var end = createPositionFromLexer(lexer);

	token.string = createString(start, end);

	return token;
}

func lexCharacter(Lexer lexer, Token token) -> Token {
	var start = createPositionFromLexer(lexer);

	advance(lexer);

	if (current(lexer) == '\\') {
		advance(lexer);
	}

	advance(lexer);

	advance(lexer);

	var end = createPositionFromLexer(lexer);

	token.character = createCharacter(start, end);

	return token;
}

func lexNumber(Lexer lexer, Token token) -> Token {
	var start = createPositionFromLexer(lexer);

	while (isnumeric(current(lexer))) {
		advance(lexer);
	}

	var end = createPositionFromLexer(lexer);

	token.number = createNumber(start, end);

	return token;
}

func nextToken(Lexer lexer) -> Token {
	var token = createToken();

	while (current(lexer) != '\0') {
		handleComments(lexer);

		if (isalpha(current(lexer)) || current(lexer) == '_') {
			return lexName(lexer, token);
		}

		if (current(lexer) == '"') {
			return lexString(lexer, token);
		}

		if (current(lexer) == '\'') {
			return lexCharacter(lexer, token);
		}

		if (isnumeric(current(lexer))) {
			return lexNumber(lexer, token);
		}

		advance(lexer);
	}

	token.isEOF = (bool)1;

	return token;
}

func isName(Token token) -> bool {
	return token.name != (Name)0;
}

func isString(Token token) -> bool {
	return token.string != (String)0;
}

func isCharacter(Token token) -> bool {
	return token.character != (Character)0;
}

func isNumber(Token token) -> bool {
	return token.number != (Number)0;
}
