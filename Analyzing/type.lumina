import "../std/string.lumina"
import "../std/memory.lumina"
import "../std/io.lumina"

import "name.lumina" 
import "operator.lumina"
import "position.lumina"
import "whitespace.lumina"


type Property {
	str name;
	PropertyDefinition definition;
	str typeName;

	Type propertyType;
	int offset;
}

type PropertyList {
	int size;
	int maxSize;
	Property[] list;
}

type Type {
	str name;
	TypeDefinition definition;
	int size;

	PropertyList properties;

	Type listOf;
	Type listType;
}

type TypeName {
	Region region;
	Name name;
	OperatorList brackets;
}

type PropertyDefinition {
	Region region;
	TypeName typeName;
	Name name;
	Operator semicolon;
}

type PropertyDefinitionList {
	int size;
	int maxSize;
	PropertyDefinition[] list;
}

type TypeDefinition {
	Region region;
	Name keyword;
	Name name;
	int size;

	Operator lbrace;

	PropertyDefinitionList properties;

	Operator rbrace;

	TypeDefinition listOf;
	TypeDefinition arrayType;
}

type TypeList {
	int size;
	int maxSize;
	Type[] list;
}

func createTypeName(Name name, OperatorList brackets) -> TypeName {
	if (isIdentifier(name) != (bool)1) {
		print("expected type name to be an identifier\n");
	}

	var value = (TypeName)malloc(sizeof(TypeName));
	
	if (brackets.size > 0) {
		value.region = createRegion(name.region.start, brackets.list[brackets.size - 1].position);
	} else {
		value.region = name.region;
	}

	value.name = name;
	value.brackets = brackets;

	return value;
}

func createTypeObjFromString(str typeName) -> TypeName {
	var typeObj = (TypeName)malloc(sizeof(TypeName));

	typeObj.name = createNameFromString(typeName);
	typeObj.brackets = createOperatorList();

	return typeObj;
}

func createPropertyDefinition(TypeName typeName, Name name, Operator semicolon) -> PropertyDefinition {
	if (isIdentifier(name) != (bool)1) {
		print("expected property name to be an identifier\n");
	}

	if (streq(semicolon.name, ";") == (bool)0) {
		print("expected ';' in property\n");
	}

	var property = (PropertyDefinition)malloc(sizeof(PropertyDefinition));

	property.typeName = typeName;
	property.name = name;
	property.semicolon = semicolon;

	property.region = createRegion(typeName.region.start, semicolon.position);

	return property;
}

func createPropertyDefinitionList() -> PropertyDefinitionList {
	var list = (PropertyDefinitionList)malloc(sizeof(PropertyDefinitionList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (PropertyDefinition[])malloc(8 * 8);

	return list;
}

func addPropertyDefinition(PropertyDefinitionList list, PropertyDefinition property) {
	list.list[list.size] = property;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (PropertyDefinition[])realloc((ptr)list.list, list.maxSize * 8, 8 * list.maxSize * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func findPropertyDefinition(PropertyDefinitionList list, str name) -> PropertyDefinition {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name.name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (PropertyDefinition)0;
}

func createTypeDefinition(Name keyword, Name name, Operator lbrace, PropertyDefinitionList properties, Operator rbrace) -> TypeDefinition {
	var typeDef = (TypeDefinition)malloc(sizeof(TypeDefinition));

	if (isIdentifier(name) != (bool)1) {
		print("expected type name to be an identifier\n");
	}

	if (isOperator(lbrace, "{") != (bool)1) {
		print("expected '{' after type name\n");
	}

	if (isOperator(rbrace, "}") != (bool)1) {
		print("expected '}' after type definition\n");
	}

	typeDef.keyword = keyword;
	typeDef.name = name;
	typeDef.size = 8;
	typeDef.lbrace = lbrace;
	typeDef.properties = properties;
	typeDef.rbrace = rbrace;
	typeDef.listOf = (TypeDefinition)0;
	typeDef.arrayType = (TypeDefinition)0;

	typeDef.region = createRegion(keyword.region.start, rbrace.position);

	return typeDef;
}

func createPropertyFromDefinition(PropertyDefinition definition) -> Property {
	var property = (Property)malloc(sizeof(Property));

	property.name = definition.name.name;
	property.definition = definition;
	property.typeName = definition.typeName.name.name;

	property.offset = -1;
	property.propertyType = (Type)0;

	return property;
}

func createPropertyFromString(str name, Type propertyType) -> Property {
	var property = (Property)malloc(sizeof(Property));

	property.name = name;
	property.definition = (PropertyDefinition)0;
	property.typeName = propertyType.name;

	property.offset = -1;
	property.propertyType = propertyType;

	return property;
}

func createPropertyList() -> PropertyList {
	var list = (PropertyList)malloc(sizeof(PropertyList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (Property[])malloc(8 * 8);

	return list;
}

func addProperty(PropertyList list, Property property) {
	list.list[list.size] = property;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (Property[])realloc((ptr)list.list, 8 * list.maxSize, list.maxSize * 8 * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func createTypeFromDefinition(TypeDefinition definition) -> Type {
	var typeObj = (Type)malloc(sizeof(Type));

	typeObj.name = definition.name.name;
	typeObj.definition = definition;
	typeObj.size = 8;

	typeObj.properties = createPropertyList();

	var i = 0;
	while (i < definition.properties.size) {
		addProperty(typeObj.properties, createPropertyFromDefinition(definition.properties.list[i]));
		i = i + 1;
	}
	
	typeObj.listOf = (Type)0;
	typeObj.listType = (Type)0;

	return typeObj;
}

func createTypeFromString(str name, int size) -> Type {
	var typeObj = (Type)malloc(sizeof(Type));

	typeObj.name = name;
	typeObj.definition = (TypeDefinition)0;
	typeObj.size = size;

	typeObj.properties = createPropertyList();

	typeObj.listOf = (Type)0;
	typeObj.listType = (Type)0;

	return typeObj;
}

func createListType(str name, Type typeObj) -> Type {
	if (typeObj.listOf != (Type)0) {
		return typeObj.listOf;
	}

	var listType = createTypeFromString(name, 8);
	listType.listType = typeObj;

	typeObj.listOf = listType;

	return listType;
}

func createTypeList() -> TypeList {
	var list = (TypeList)malloc(sizeof(TypeList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (Type[])malloc(8 * 8);

	return list;
}

func addType(TypeList list, Type typeObj) {
	list.list[list.size] = typeObj;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (Type[])realloc((ptr)list.list, list.maxSize * 8, 8 * list.maxSize * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func findType(TypeList list, str name) -> Type {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (Type)0;
}

func printType(Type typeObj) {
	if (typeObj == (Type)0) {
		print("type is null");
		return;
	}

	if (typeObj.name == (str)0) {
		print("type name is null");
	}

	print(typeObj.name);
}

func printTypeList(TypeList list) {
	var i = 0;
	print("[");
	while (i < list.size) {
		if (i != 0) {
			print(",");
		}
		printType(list.list[i]);
		i = i + 1;
	}
	print("]");
}
