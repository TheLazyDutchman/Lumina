import "../std/string.lumina"
import "../std/memory.lumina"
import "../std/io.lumina"

import "name.lumina" 
import "operator.lumina"
import "operation.lumina"
import "position.lumina"
import "whitespace.lumina"


type Property {
	str name;
	PropertyDefinition definition;
	str typeName;

	TypeObj propertyType;
	int offset;
}

type PropertyList {
	int size;
	int maxSize;
	Property[] list;
}

type Generic {
	str name;
	TypeObj typeObj;

	GenericDefinition definition;
}

type GenericList {
	int size;
	int maxSize;
	Generic[] list;
}

type TypeObj {
	str name;
	int nameId;
	TypeDefinition definition;
	int size;
	int objectSize;

	PropertyList properties;
	GenericList generics;

	TypeObj listOf;
	TypeObj listType;

	TypeList variants;
}

type PropertyDefinition {
	Region region;
	Operation propertyType;
	Name name;
	Operator semicolon;
}

type PropertyDefinitionList {
	int size;
	int maxSize;
	PropertyDefinition[] list;
}

type GenericDefinition {
	Region region;
	Name name;
	Operator comma;
}

type GenericDefinitionList {
	int size;
	int maxSize;
	GenericDefinition[] list;
}

type GenericsDefinition {
	Region region;

	Operator lesser;
	GenericDefinitionList generics;
	Operator greater;
}

type TypeDefinition {
	Region region;
	Name keyword;
	Name name;
	int size;

	Operator lbrace;

	PropertyDefinitionList properties;
	GenericsDefinition generics;

	Operator rbrace;

	TypeDefinition listOf;
	TypeDefinition arrayType;
}

type TypeList {
	int size;
	int maxSize;
	TypeObj[] list;
}

func createPropertyDefinition(Operation propertyType, Name name, Operator semicolon) -> PropertyDefinition {
	if (isIdentifier(name) != (bool)1) {
		print("expected property name to be an identifier\n");
	}

	if (streq(semicolon.name, ";") == (bool)0) {
		print("expected ';' in property\n");
	}

	var property = (PropertyDefinition)malloc(sizeof(PropertyDefinition));

	property.propertyType = propertyType;
	property.name = name;
	property.semicolon = semicolon;

	property.region = createRegion(propertyType.region.start, semicolon.position);

	return property;
}

func createPropertyDefinitionList() -> PropertyDefinitionList {
	var list = (PropertyDefinitionList)malloc(sizeof(PropertyDefinitionList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (PropertyDefinition[])malloc(8 * 8);

	return list;
}

func addPropertyDefinition(PropertyDefinitionList list, PropertyDefinition property) {
	list.list[list.size] = property;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (PropertyDefinition[])realloc((ptr)list.list, list.maxSize * 8, 8 * list.maxSize * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func findProperty(PropertyList list, str name) -> Property {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (Property)0;
}

func createGenericFromString(str name) -> Generic {
	var generic = (Generic)malloc(sizeof(Generic));

	generic.name = name;
	generic.typeObj = createTypeFromString(name, 8);

	generic.definition = (GenericDefinition)0;

	return generic;
}

func createGenericFromType(TypeObj typeObj) -> Generic {
	if (typeObj == (TypeObj)0) {
		return (Generic)0;
	}

	var generic = (Generic)malloc(sizeof(Generic));

	generic.name = typeObj.name;
	generic.typeObj = typeObj;
	generic.definition = (GenericDefinition)0;

	return generic;
}

func createGenericFromDefinition(GenericDefinition definition) -> Generic {
	var generic = createGenericFromString(definition.name.name);

	generic.definition = definition;

	return generic;
}

func createGenericList() -> GenericList {
	var list = (GenericList)malloc(sizeof(GenericList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (Generic[])malloc(8 * 8);

	return list;
}

func addGeneric(GenericList list, Generic generic) {
	list.list[list.size] = generic;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (Generic[])realloc((ptr)list.list, list.maxSize * 8, 8 * list.maxSize * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func findGeneric(GenericList list, str name) -> Generic {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (Generic)0;
}

func createGenericDefinition(Operator comma, Name name) -> GenericDefinition {
	var generic = (GenericDefinition)malloc(sizeof(GenericDefinition));

	generic.comma = comma;
	generic.name = name;

	if (comma != (Operator)0) {
		generic.region = createRegion(comma.position, name.region.end);
	} else {
		generic.region = name.region;
	}

	return generic;
}

func createGenericDefinitionList() -> GenericDefinitionList {
	var list = (GenericDefinitionList)malloc(sizeof(GenericDefinitionList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (GenericDefinition[])malloc(8 * 8);

	return list;
}

func addGenericDefinition(GenericDefinitionList list, GenericDefinition generic) {
	list.list[list.size] = generic;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (GenericDefinition[])realloc((ptr)list.list, list.maxSize * 8, 8 * list.maxSize * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func createGenericsDefinition(Operator lesser, GenericDefinitionList generics, Operator greater) -> GenericsDefinition {
	var definition = (GenericsDefinition)malloc(sizeof(GenericsDefinition));

	if (lesser != (Operator)0 && greater != (Operator)0) {
		definition.region = createRegion(lesser.position, greater.position);
	}

	definition.lesser = lesser;
	definition.generics = generics;
	definition.greater = greater;

	return definition;
}

func createTypeDefinition(Name keyword, Name name, Operator lbrace, GenericsDefinition generics, PropertyDefinitionList properties, Operator rbrace) -> TypeDefinition {
	var typeDef = (TypeDefinition)malloc(sizeof(TypeDefinition));

	if (isIdentifier(name) != (bool)1) {
		print("expected type name to be an identifier\n");
	}

	if (isOperator(lbrace, "{") != (bool)1) {
		print("expected '{' after type name\n");
	}

	if (isOperator(rbrace, "}") != (bool)1) {
		print("expected '}' after type definition\n");
	}

	typeDef.keyword = keyword;
	typeDef.name = name;
	typeDef.size = 8;
	typeDef.generics = generics;
	typeDef.lbrace = lbrace;
	typeDef.properties = properties;
	typeDef.rbrace = rbrace;
	typeDef.listOf = (TypeDefinition)0;
	typeDef.arrayType = (TypeDefinition)0;

	typeDef.region = createRegion(keyword.region.start, rbrace.position);

	return typeDef;
}

func createPropertyFromDefinition(PropertyDefinition definition) -> Property {
	var property = (Property)malloc(sizeof(Property));

	property.name = definition.name.name;
	property.definition = definition;

	property.typeName = (str)0; // TODO: find a way to get this type

	property.offset = -1;
	property.propertyType = (TypeObj)0;

	return property;
}

func createPropertyFromString(str name, TypeObj propertyType) -> Property {
	var property = (Property)malloc(sizeof(Property));

	property.name = name;
	property.definition = (PropertyDefinition)0;
	property.typeName = propertyType.name;

	property.offset = -1;
	property.propertyType = propertyType;

	return property;
}

func copyProperty(Property original) -> Property {
	var property = (Property)malloc(sizeof(Property));

	property.name = original.name;
	property.definition = original.definition;

	property.typeName = original.typeName;
	property.offset = original.offset;
	property.propertyType = original.propertyType;
	
	return property;
}

func createPropertyList() -> PropertyList {
	var list = (PropertyList)malloc(sizeof(PropertyList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (Property[])malloc(8 * 8);

	return list;
}

func copyPropertyList(PropertyList original) -> PropertyList {
	var list = (PropertyList)malloc(sizeof(PropertyList));

	list.size = original.size;
	list.maxSize = original.maxSize;
	list.list = (Property[])malloc(8 * list.maxSize);

	var i = 0;
	while (i < original.size) {
		list.list[i] = copyProperty(original.list[i]);
		i = i + 1;
	}

	return list;
}

func addProperty(PropertyList list, Property property) {
	list.list[list.size] = property;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (Property[])realloc((ptr)list.list, 8 * list.maxSize, list.maxSize * 8 * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func createTypeFromDefinition(TypeDefinition definition) -> TypeObj {
	var typeObj = (TypeObj)malloc(sizeof(TypeObj));

	typeObj.name = definition.name.name;
	typeObj.definition = definition;
	typeObj.size = 8;

	typeObj.generics = createGenericList();

	var i = 0;
	while (i < definition.generics.generics.size) {
		addGeneric(typeObj.generics, createGenericFromDefinition(definition.generics.generics.list[i]));
		i = i + 1;
	}

	typeObj.properties = createPropertyList();

	i = 0;
	while (i < definition.properties.size) {
		addProperty(typeObj.properties, createPropertyFromDefinition(definition.properties.list[i]));
		i = i + 1;
	}
	
	typeObj.listOf = (TypeObj)0;
	typeObj.listType = (TypeObj)0;

	typeObj.variants = createTypeList();
	addType(typeObj.variants, typeObj);

	return typeObj;
}

func createTypeFromString(str name, int size) -> TypeObj {
	var typeObj = (TypeObj)malloc(sizeof(TypeObj));

	typeObj.name = name;
	typeObj.definition = (TypeDefinition)0;
	typeObj.size = size;
	typeObj.objectSize = size;

	typeObj.generics = createGenericList();
	typeObj.properties = createPropertyList();

	typeObj.listOf = (TypeObj)0;
	typeObj.listType = (TypeObj)0;

	typeObj.variants = createTypeList();
	addType(typeObj.variants, typeObj);

	return typeObj;
}

func createNewTypeVariant(TypeObj typeObj, TypeList newGenerics) -> TypeObj {
	var newType = (TypeObj)malloc(sizeof(TypeObj));

	newType.name = typeObj.name;
	newType.definition = typeObj.definition;
	newType.size = typeObj.size;
	newType.objectSize = typeObj.objectSize;

	newType.generics = createGenericList();
	var i = 0;
	while (i < newGenerics.size) {
		addGeneric(newType.generics, createGenericFromType(newGenerics.list[i]));
		i = i + 1;
	}

	newType.properties = copyPropertyList(typeObj.properties);
	i = 0;
	while (i < newType.properties.size) {
		var j = 0;
		while (j < typeObj.generics.size) {
			newType.properties.list[i].propertyType = applyGeneric(newType.properties.list[i].propertyType, typeObj.generics.list[j].typeObj, newGenerics.list[j]);
			j = j + 1;
		}
		i = i + 1;
	}


	newType.listOf = (TypeObj)0;
	newType.listType = (TypeObj)0;

	newType.variants = typeObj.variants;
	addType(typeObj.variants, newType);

	return newType;
}

func createListType(str name, TypeObj typeObj) -> TypeObj {
	if (typeObj.listOf != (TypeObj)0) {
		return typeObj.listOf;
	}

	var listType = createTypeFromString(name, 8);
	listType.listType = typeObj;

	typeObj.listOf = listType;

	return listType;
}

func getVariantType(TypeObj typeObj, TypeList generics) -> TypeObj {
	if (typeObj.generics.size != generics.size) {
		print("expected ");
		printi(typeObj.generics.size);
		print(" generics, got ");
		printi(generics.size);
		print(" instead\n");
		return (TypeObj)0;
	}

	var i = 0;
	while (i < typeObj.variants.size) {
		var variant = typeObj.variants.list[i];
		var j = 0;
		var isEqual = (bool)1;
		while (j < generics.size) {
			if (variant.generics.list[j] == (Generic)0 || variant.generics.list[j].typeObj != generics.list[j]) {
				isEqual = (bool)0;
			}
			j = j + 1;
		}

		if (isEqual) {
			return variant;
		}
		i = i + 1;
	}

	return createNewTypeVariant(typeObj, generics);
}

func applyGeneric(TypeObj value, TypeObj old, TypeObj new) -> TypeObj {
	if (value == old) { return new; }
	if (value == (TypeObj)0) {
		return (TypeObj)0;
	}

	if (value.listOf == old) { return new.listType; }
	if (value.listType == old) { 
		if (new == (TypeObj)0) {
			return (TypeObj)0;
		}

		if (new.listOf == (TypeObj)0) {
			createListType((str)0, new);
		}

		return new.listOf; 
	}

	if (value.generics.size != 0) {
		var generics = createTypeList();
		var i = 0;
		while (i < value.generics.size) {
			var original = value.generics.list[i].typeObj;
			addType(generics, applyGeneric(original, old, new));
			i = i + 1;
		}

		return getVariantType(value, generics);
	}

	return value;
}

func createTypeList() -> TypeList {
	var list = (TypeList)malloc(sizeof(TypeList));

	list.size = 0;
	list.maxSize = 8;
	list.list = (TypeObj[])malloc(8 * 8);

	return list;
}

func addType(TypeList list, TypeObj typeObj) {
	list.list[list.size] = typeObj;
	list.size = list.size + 1;

	if (list.size == list.maxSize) {
		list.list = (TypeObj[])realloc((ptr)list.list, list.maxSize * 8, 8 * list.maxSize * 2);
		list.maxSize = list.maxSize * 2;
	}
}

func findType(TypeList list, str name) -> TypeObj {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (TypeObj)0;
}

func extendTypeList(TypeList destination, TypeList source) {
	if (source == (TypeList)0) {
		print("source was zero in 'extendTypeList'\n");
		return;
	}

	var i = 0;

	while (i < source.size) {
		addType(destination, source.list[i]);
		i = i + 1;
	}
}

func printType(TypeObj typeObj) {
	if (typeObj == (TypeObj)0) {
		print("type is null");
		return;
	}

	if (typeObj.generics.size != 0) {
		print(typeObj.name);
		print("<");
		var i = 0;
		while (i < typeObj.generics.size) {
			if (i != 0) {
				print(",");
			}
			printType(typeObj.generics.list[i].typeObj);
			i = i + 1;
		}
		print(">");
		return;
	}

	if (typeObj.listType != (TypeObj)0 && typeObj.name == (str)0) {
		printType(typeObj.listType);
		print("[]");
		return;
	}

	if (typeObj.name == (str)0) {
		print("type name is null");
		return;
	}

	print(typeObj.name);
}

func printTypeList(TypeList list) {
	var i = 0;
	print("[");
	while (i < list.size) {
		if (i != 0) {
			print(",");
		}
		printType(list.list[i]);
		i = i + 1;
	}
	print("]");
}
