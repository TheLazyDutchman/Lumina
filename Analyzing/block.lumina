import "../std/collections.lumina"

import "position.lumina"
import "operator.lumina"
import "statement.lumina"
import "type.lumina"
import "function.lumina"
import "variable.lumina"
import "name.lumina"
import "whitespace.lumina"
import "definition.lumina"


type Block {
	Region region;

	Operator lbrace;
	Array<Statement> statements;

	Array<Definition> definitions;
	Array<TypeObj> types;
	Array<FunctionDefinition> functions;
	Array<Variable> variables;
	Operator rbrace;
	int depth;

	Block outer;
	FunctionDefinition function;
}

func createBlock(Operator lbrace, Array<Statement> statements, Array<Definition> definitions, Array<TypeObj> types, Array<FunctionDefinition> functions, Array<Variable> variables, Block outer, FunctionDefinition function) -> Block {
	var block = new Block();

	block.region = (Region)0;

	block.lbrace = lbrace;
	block.statements = statements;

	block.definitions = definitions;
	block.types = types;
	block.functions = functions;
	block.variables = variables;
	block.rbrace = (Operator)0;

	block.outer = outer;

	if (outer != (Block)0) {
		block.depth = outer.depth;
	} else {
		block.depth = 0;
	}

	block.function = function;

	return block;
}

func setEnd(Block block, Operator rbrace) {
	block.region = createRegion(block.lbrace.position, rbrace.position);

	block.rbrace = rbrace;

	if (block.function != (FunctionDefinition)0) {
		block.function.region = createRegion(
			block.function.keyword.region.start,
			block.region.end);
	}
}

func findFunctionInBlock(Block block, str name) -> FunctionDefinition {
	var function = findFunction(block.functions, name);

	if (function == (FunctionDefinition)0 && block.outer != (Block)0) {
		return findFunctionInBlock(block.outer, name);
	}

	return function;
}

func getBlockFunction(Block block) -> FunctionDefinition {
	if (block.function != (FunctionDefinition)0) {
	return block.function;
	}

	return getBlockFunction(block.outer);
}
