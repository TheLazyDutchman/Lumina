import "syscalls.lumina"

// DISCLAIMER this is not an actual malloc implementation
// the previous one just had a lot of bugs, so this is a quick (hopefully) in between "solution", before I create an actual garbage collector

var PAGESIZE = 4096;

var _heapHead = brk((ptr)0);

var curEnd = brk((ptr)((int)_heapHead + PAGESIZE * 4));

func expandHeap(int size) -> int {
    var totalSize = PAGESIZE;

    while (totalSize < size) {
	totalSize = totalSize + PAGESIZE;
    }

    curEnd = brk((ptr)((int)curEnd + totalSize));
    return totalSize;
}

func malloc(int size) -> ptr {
    if ((int)curEnd - (int)_heapHead < size * 3) {
	expandHeap(size);
    }

    var oldPtr = _heapHead;
    _heapHead = (ptr)((int)_heapHead + size * 2);
    return oldPtr;
}

func realloc(ptr addr, int oldSize, int newSize) -> ptr {
    if (oldSize >= newSize) {
	return addr;
    }

    var newAddr = malloc(newSize);

    var i = 0;
    while (i < oldSize) {
	((char[])newAddr)[i] = ((char[])addr)[i];
	i = i + 1;
    }

    return newAddr;
}

func free(ptr addr) {
    // this hack of a heap can not free memory
}
