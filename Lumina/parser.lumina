import "lexer.lumina"
import "compiler.lumina"

type Parser {
	Lexer lexer;
	Token last;
	Token current;

	Compiler compiler;
	int outputFile; // int here is a file descriptor

	int numIfs;
	int numElses;
	int numAnds;
	int numOrs;
	int numWhiles;
	int numFuncs;

	bool hadError;
	bool isChecking;
}

func initParser(str inputName, str outputName, bool isChecking) -> Parser {
	var parser = (Parser)malloc(sizeof(Parser));

	parser.lexer = initLexer(inputName, (Lexer)0);
	parser.last = (Token)0;
	parser.current = nextToken(parser.lexer);

	parser.outputFile = open(outputName, 577, 0);

	if (parser.outputFile < 0) {
		print("could not open/create file '");
		print(outputName);
		print("'\n");
		exit(1);
	}

	parser.compiler = initCompiler(parser.outputFile, (Compiler)0);

	parser.numIfs = 0;
	parser.numElses = 0;
	parser.numAnds = 0;
	parser.numOrs = 0;
	parser.numWhiles = 0;

	var anyType = defineType(parser.compiler, "any", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var intType = defineType(parser.compiler, "int", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	defineType(parser.compiler, "ptr", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var charType = defineType(parser.compiler, "char", 4, 1, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var strType = defineType(parser.compiler, "str", 3, 8, (PropertyList)0, (Type[])0, (bool)1, charType);
	defineType(parser.compiler, "bool", 4, 1, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	defineType(parser.compiler, "null", 4, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);

	var name = "syscall";
	var nameLen = strlen(name);
	var id = 0;
	
	var parameters = initVariableList();
	var i = 0;
	while (i < 7) {
		addVariable(parameters, "  ", i, 0, anyType);
		i = i + 1;
	}

	parser.compiler.currentStackSize = parser.compiler.currentStackSize + 1;
	defineVariable(parser.compiler, "argc", 4, intType);
	parser.compiler.currentStackSize = parser.compiler.currentStackSize + 1;
	defineVariable(parser.compiler, "argv", 4, initType("  ", 8, (PropertyList)0, (Type[])0, (bool)1, strType));

	defineFunction(parser.compiler, name, nameLen, 0, anyType, parameters);

	parser.numFuncs = 1;

	parser.hadError = (bool)0;
	parser.isChecking = isChecking;

	return parser;
}

func freeParser(Parser parser) {
	freeLexer(parser.lexer);

	if (parser.last != (Token)0) {
		free((ptr)(parser.last));
	}

	if (parser.current != (Token)0) {
		free((ptr)(parser.current));
	}

	close(parser.outputFile);
	freeCompiler(parser.compiler);

	free((ptr)parser);
}

func next(Parser parser) -> Token {
	if (parser.last != (Token)0) {
		free((ptr)(parser.last));
	}

	parser.last = parser.current;
	parser.current = nextToken(parser.lexer);

	return parser.current;
}

func parseError(Parser parser, Token token, str message) {
	parser.hadError = (bool)1;

	print(token.fileName);
	print(": ");
	printi(token.line);
	print(": ");
	printi(token.column);

	print(":error: at '");
	printn(token.word, token.wordLen);
	print("', ");

	print(message);
	print(" \n");

	while (parser.current.tokenType != TOKEN_SEMICOLON && parser.current.tokenType != TOKEN_END_OF_FILE) {
		next(parser);
	}
}

func consumeToken(Parser parser, int tokenType, str message) -> Token{
	var token = parser.current;
	if (token.tokenType != tokenType) {
		parseError(parser, parser.current, message);
		token.tokenType = TOKEN_ERROR;
		return token;
	}

	next(parser);
	return token;
}


func expression(Parser parser) {
}

func importStatement(Parser parser) {
	next(parser);
	var nameToken = consumeToken(parser, TOKEN_STR, "expected name of import file");
	var name = strndup(nameToken.word, nameToken.wordLen);

	// check if file was imported before

	parser.lexer = initLexer(name, parser.lexer);
	parser.current = nextToken(parser.lexer);

	free((ptr)name);
}

func variableDefinition(Parser parser) {
	next(parser);

	var nameToken = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of variable");

	if (nameToken.tokenType == TOKEN_ERROR) {
		return;
	}

	if (consumeToken(parser, TOKEN_EQUAL, "expected '=' in variable definition").tokenType == TOKEN_ERROR) { return; }

	expression(parser);

	consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after variable definition");
}

func statement(Parser parser) {
	if (parser.current.tokenType == TOKEN_IMPORT) {
		importStatement(parser);
	} else if (parser.current.tokenType == TOKEN_VAR) {
		variableDefinition(parser);
	} else {
		expression(parser);

		consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after expression");
	}
}

func parse(Parser parser) {
	writeHeader(parser.compiler);

	while (parser.current.tokenType != TOKEN_END_OF_FILE) {
		statement(parser);
	}

	writeFooter(parser.compiler);
}
