import "lexer.lumina"
import "compiler.lumina"

import "luminaStrings.lumina"

type Parser {
	Lexer lexer;
	Token last;
	Token current;

	Compiler compiler;
	int outputFile; // int here is a file descriptor

	int numIfs;
	int numElses;
	int numAnds;
	int numOrs;
	int numWhiles;
	int numFuncs;

	StringList stringList;

	bool hasError;
	bool isChecking;
}

func initParser(str inputName, str outputName, bool isChecking) -> Parser {
	var parser = (Parser)malloc(sizeof(Parser));

	parser.lexer = initLexer(inputName, (Lexer)0);
	parser.last = (Token)0;
	parser.current = nextToken(parser.lexer);

	if (isChecking) {
		parser.outputFile = open("/dev/null", 1, 0);
	} else {
		parser.outputFile = open(outputName, 577, 511);
	}

	if (parser.outputFile < 0) {
		print("could not open/create file '");
		print(outputName);
		print("'\n");

		print("error code: ");
		printi(parser.outputFile);
		print(" \n");

		exit(1);
	}

	parser.compiler = initCompiler(parser.outputFile, (Compiler)0);

	parser.numIfs = 0;
	parser.numElses = 0;
	parser.numAnds = 0;
	parser.numOrs = 0;
	parser.numWhiles = 0;

	var anyType = defineType(parser.compiler, "any", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var intType = defineType(parser.compiler, "int", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	defineType(parser.compiler, "ptr", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var charType = defineType(parser.compiler, "char", 4, 1, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var strType = defineType(parser.compiler, "str", 3, 8, (PropertyList)0, (Type[])0, (bool)1, charType);
	defineType(parser.compiler, "bool", 4, 1, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	defineType(parser.compiler, "null", 4, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);

	var name = "syscall";
	var nameLen = strlen(name);
	var id = 0;
	
	var parameters = initVariableList();
	var i = 0;
	while (i < 7) {
		addVariable(parameters, "  ", i, 0, anyType);
		i = i + 1;
	}

	parser.compiler.currentStackSize = parser.compiler.currentStackSize + 1;
	defineVariable(parser.compiler, "argc", 4, intType);
	parser.compiler.currentStackSize = parser.compiler.currentStackSize + 1;
	defineVariable(parser.compiler, "argv", 4, initType("  ", 8, (PropertyList)0, (Type[])0, (bool)1, strType));

	defineFunction(parser.compiler, name, nameLen, 0, anyType, parameters);

	parser.numFuncs = 1;

	parser.stringList = initStringList();

	parser.hasError = (bool)0;
	parser.isChecking = isChecking;

	return parser;
}

func freeParser(Parser parser) {
	freeLexer(parser.lexer);

	if (parser.last != (Token)0) {
		free((ptr)(parser.last));
	}

	if (parser.current != (Token)0) {
		free((ptr)(parser.current));
	}

	freeStringList(parser.stringList);

	close(parser.outputFile);
	freeCompiler(parser.compiler);

	free((ptr)parser);
}

func next(Parser parser) -> Token {
	if (parser.last != (Token)0) {
		free((ptr)(parser.last));
	}

	parser.last = parser.current;
	parser.current = nextToken(parser.lexer);

	if (parser.current.tokenType == TOKEN_END_OF_FILE && parser.lexer.outer != (Lexer)0) {
		var current = parser.lexer;
		parser.lexer = parser.lexer.outer;
		freeLexer(current);

		parser.current = next(parser);
	}

	return parser.current;
}

func parseError(Parser parser, Token token, str message) {
	parser.hasError = (bool)1;

	print(token.fileName);
	print(": ");
	printi(token.line);
	print(": ");
	printi(token.column);

	print(":error: at '");
	printn(token.word, token.wordLen);
	print("', ");

	print(message);
	print(" \n");

	while (parser.current.tokenType != TOKEN_SEMICOLON && parser.current.tokenType != TOKEN_END_OF_FILE) {
		next(parser);
	}
}

func consumeToken(Parser parser, int tokenType, str message) -> Token{
	var token = parser.current;
	if (token.tokenType != tokenType) {
		parseError(parser, parser.current, message);

		if (token.tokenType != TOKEN_END_OF_FILE) {
			token.tokenType = TOKEN_ERROR;
		}
		return token;
	}

	next(parser);
	return token;
}


func expression(Parser parser) {
	func functionCall(Parser parser, Function function) {
		next(parser);

		consumeToken(parser, TOKEN_LPAREN, "expected '(' after function name");

		if (function.parameters.size == 0) {
			consumeToken(parser, TOKEN_RPAREN, "function does not expect parameters");
		} else {
			expression(parser);

			var i = 1;
			while (i < function.parameters.size) {
				consumeToken(parser, TOKEN_COMMA, "expected ',' between arguments");

				expression(parser);

				i = i + 1;
			}

			// TODO: add type checking to this

			consumeToken(parser, TOKEN_RPAREN, "expected ')' after arguments");
		}
		
		writeCall(parser.compiler, function.id, function.numCalls);
		function.numCalls = function.numCalls + 1;
	}

	func identifier(Parser parser) {
		var token = parser.current;

		var function = findFunction(parser.compiler, token.word, token.wordLen);

		if (function != (Function)0) {
			functionCall(parser, function);
			return;
		}
	}

	func number(Parser parser) {
		var numberString = strndup(parser.current.word, parser.current.wordLen);
		writeNumber(parser.compiler, numberString);

		free((ptr)numberString);

		next(parser);
	}

	func string(Parser parser) {
		var id = parser.stringList.size;

		addString(parser.stringList, strndup(parser.current.word, parser.current.wordLen));
		writeString(parser.compiler, id);

		next(parser);
	}

	func unary(Parser parser) {
		var currentType = parser.current.tokenType;

		if (currentType == TOKEN_IDENTIFIER) {
			identifier(parser);
		} else if (currentType == TOKEN_NUMBER) {
			number(parser);
		} else if (currentType == TOKEN_STR) {
			string(parser);
		} else {
			parseError(parser, parser.current, "this token is not recognised as a unary");
		}
	}

	unary(parser);
}

func importStatement(Parser parser) {
	next(parser);
	var nameToken = parser.current;
	if (nameToken.tokenType != TOKEN_STR) { parseError(parser, parser.current, "expected name of import file"); }

	var name = strndup(nameToken.word, nameToken.wordLen);

	// check if file was imported before

	parser.lexer = initLexer(name, parser.lexer);
	next(parser);

	free((ptr)name);
}

func variableDefinition(Parser parser) {
	next(parser);

	var nameToken = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of variable");

	if (nameToken.tokenType == TOKEN_ERROR) {
		return;
	}

	if (consumeToken(parser, TOKEN_EQUAL, "expected '=' in variable definition").tokenType == TOKEN_ERROR) { return; }

	expression(parser);

	consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after variable definition");
}

func statement(Parser parser) {
	if (parser.current.tokenType == TOKEN_IMPORT) {
		importStatement(parser);
	} else if (parser.current.tokenType == TOKEN_VAR) {
		variableDefinition(parser);
	} else {
		expression(parser);

		consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after expression");
	}
}

func parse(Parser parser) {
	writeHeader(parser.compiler);

	while (parser.current.tokenType != TOKEN_END_OF_FILE) {
		statement(parser);
	}

	writeFooter(parser.compiler, parser.stringList);
}
