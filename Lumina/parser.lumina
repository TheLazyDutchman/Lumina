import "lexer.lumina"
import "scope.lumina"
import "compiler.lumina"

import "luminaStrings.lumina"

type Parser {
	Lexer lexer;
	Token last;
	Token current;

	StringList fileList;

	Type lastType;

	Scope scope;

	Compiler compiler;
	int outputFile; // int here is a file descriptor

	int numIfs;
	int numElses;
	int numAnds;
	int numOrs;
	int numWhiles;
	int numFuncs;

	StringList stringList;

	bool hasError;
	bool isChecking;
}

func initParser(str inputName, str outputName, bool isChecking) -> Parser {
	var parser = (Parser)malloc(sizeof(Parser));

	parser.lexer = initLexer(inputName, (Lexer)0);
	parser.last = (Token)0;
	parser.current = nextToken(parser.lexer);

	parser.fileList = initStringList();

	if (isChecking) {
		parser.outputFile = open("/dev/null", 1, 0);
	} else {
		parser.outputFile = open(outputName, 577, 511);
	}

	if (parser.outputFile < 0) {
		print("could not open/create file '");
		print(outputName);
		print("'\n");

		print("error code: ");
		printi(parser.outputFile);
		print(" \n");

		exit(1);
	}

	parser.scope = initScope((Scope)0);

	parser.compiler = initCompiler(parser.outputFile);

	parser.numIfs = 0;
	parser.numElses = 0;
	parser.numAnds = 0;
	parser.numOrs = 0;
	parser.numWhiles = 0;

	var anyType = defineType(parser.scope, "any", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var intType = defineType(parser.scope, "int", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	defineType(parser.scope, "ptr", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var charType = defineType(parser.scope, "char", 4, 1, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var strType = defineType(parser.scope, "str", 3, 8, (PropertyList)0, (Type[])0, (bool)1, charType);
	defineType(parser.scope, "bool", 4, 1, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	defineType(parser.scope, "null", 4, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);

	var name = "syscall";
	var nameLen = strlen(name);
	var id = 0;
	
	var parameters = initVariableList();
	var i = 0;
	while (i < 7) {
		addVariable(parameters, strdup("  "), i, 0, anyType);
		i = i + 1;
	}

	defineVariable(parser.scope, "argc", 4, 1, intType);
	defineVariable(parser.scope, "argv", 4, 2, initType("  ", 8, (PropertyList)0, (Type[])0, (bool)1, strType));
	parser.compiler.currentStackSize = 2;

	defineFunction(parser.scope, name, nameLen, 0, anyType, parameters);

	parser.numFuncs = 1;

	parser.stringList = initStringList();

	parser.hasError = (bool)0;
	parser.isChecking = isChecking;

	return parser;
}

func freeParser(Parser parser) {
	freeLexer(parser.lexer);

	if (parser.last != (Token)0) {
		free((ptr)(parser.last));
	}

	if (parser.current != (Token)0) {
		free((ptr)(parser.current));
	}

	freeStringList(parser.fileList);

	freeStringList(parser.stringList);

	freeScope(parser.scope);

	close(parser.outputFile);
	freeCompiler(parser.compiler);

	free((ptr)parser);
}

func next(Parser parser) -> Token {
	if (parser.last != (Token)0) {
		free((ptr)(parser.last));
	}

	parser.last = parser.current;
	parser.current = nextToken(parser.lexer);

	while (parser.current.tokenType == TOKEN_END_OF_FILE && parser.lexer.outer != (Lexer)0) {
		var current = parser.lexer;
		parser.lexer = parser.lexer.outer;
		freeLexer(current);

		free((ptr)(parser.current));
		parser.current = nextToken(parser.lexer);
	}

	return parser.current;
}

func parseError(Parser parser, Token token, str message) {
	parser.hasError = (bool)1;

	print(token.fileName);
	print(": ");
	printi(token.line);
	print(": ");
	printi(token.column);

	print(":error: at '");
	printn(token.word, token.wordLen);
	print("', ");

	print(message);
	print(" \n");

	while (parser.current.tokenType != TOKEN_SEMICOLON &&
		parser.current.tokenType != TOKEN_COMMA && 
		parser.current.tokenType != TOKEN_RPAREN &&
		parser.current.tokenType != TOKEN_RBRACE &&
		parser.current.tokenType != TOKEN_END_OF_FILE) {
		next(parser);
	}
}

func consumeToken(Parser parser, int tokenType, str message) -> Token {
	var token = parser.current;
	next(parser);

	if (token.tokenType != tokenType) {
		parseError(parser, token, message);

		if (token.tokenType != TOKEN_END_OF_FILE) {
			token.tokenType = TOKEN_ERROR;
		}
	}
	return token;
}

func consumeType(Parser parser, str message) -> Type {
	var token = consumeToken(parser, TOKEN_IDENTIFIER, message);
	if (token.tokenType == TOKEN_ERROR) {
		return (Type)0;
	}

	var tokenType = findType(parser.scope, token.word, token.wordLen, (bool)0);
	if (tokenType == (Type)0) {
		parseError(parser, token, "can not find a type with this name");
	}

	while (parser.current.tokenType == TOKEN_LBRACKET) {
		next(parser);
		consumeToken(parser, TOKEN_RBRACKET, "expected ']' after '[' to define an array");

		tokenType = findArrayType(parser.scope, tokenType);
	}

	return tokenType;
}

func expression(Parser parser, bool isConstant) -> int {
	func parseVariable(Parser parser, Variable variable) -> int {
		next(parser);
		var regId = 0;

		if (parser.current.tokenType == TOKEN_EQUAL) {
			next(parser);

			var regId = expression(parser, (bool)0);

			if (parser.lastType != variable.varType) {
				parseError(parser, parser.current, "cannot assign a value with a different type");
				print("[NOTE] expected type: '");
				print(variable.varType.name);
				print("', got: '");
				print(parser.lastType.name);
				print("'\n");
			}

			regId = writeAssignment(parser.compiler, variable.position, variable.functionDepth, regId);
		} else {
			regId = writeIdentifier(parser.compiler, variable.position, variable.functionDepth);
		}

		parser.lastType = variable.varType;

		return regId;
	}

	func functionCall(Parser parser, Function function) -> int {
		next(parser);

		consumeToken(parser, TOKEN_LPAREN, "expected '(' after function name");

		if (function.parameters.size == 0) {
			consumeToken(parser, TOKEN_RPAREN, "function does not expect parameters");
		} else {
			var register = expression(parser, (bool)0);
			writePush(parser.compiler, register);

			var params = function.parameters.variables;
			if (params[0].varType != parser.lastType && streq(params[0].varType.name, "any") == (bool)0) {
				parseError(parser, parser.current, "parameter is not of the right type");
			}

			var i = 1;
			while (i < function.parameters.size) {
				if (parser.current.tokenType == TOKEN_RPAREN) {
					parseError(parser, parser.current, "not enough arguments to function");
					i = function.parameters.size;
				} else { // TODO: use break keyword
					consumeToken(parser, TOKEN_COMMA, "expected ',' between arguments");

					var register = expression(parser, (bool)0);
					writePush(parser.compiler, register);

					if (params[i].varType != parser.lastType && streq(params[i].varType.name, "any") == (bool)0) {
						parseError(parser, parser.current, "parameter is not of the right type");
					}

					i = i + 1;
				}
			}

			// TODO: add type checking to this

			consumeToken(parser, TOKEN_RPAREN, "expected ')' after arguments");
		}
		
		var regId = writeCall(parser.compiler, function.name, function.id, function.parameters.size, function.numCalls);
		function.numCalls = function.numCalls + 1;

		parser.lastType = function.returnType;
		return regId;
	}

	func identifier(Parser parser, bool isConstant) -> int {
		var token = parser.current;

		var constant = findConstant(parser.scope, token.word, token.wordLen, (bool)0);

		if (constant != (Constant)0) {
			if (isConstant) {
				return constant.value;
			}

			var regId = 0;
			var intType = findType(parser.scope, "int", 3, (bool)0);
			var charType = findType(parser.scope, "char", 4, (bool)0);
			var strType = findType(parser.scope, "str", 3, (bool)0);
			
			// parsing constant
			if (constant.constType == intType) {
				var numValue = intToString(constant.value);
				regId = writeNumber(parser.compiler, numValue);
				free((ptr)numValue);
				parser.lastType = intType;
			} else if (constant.constType == charType) {
				var charString = (str)malloc(2);
				charString[0] = (char)constant.value;
				charString[1] = '\0';

				regId = writeCharacter(parser.compiler, charString);
				free((ptr)charString);

				parser.lastType = charType;
			} else if (constant.constType == strType) {
				regId = writeString(parser.compiler, constant.value);
				parser.lastType = strType;
			} else {
				parseError(parser, parser.current, "Lumina currently does not support constants of this type");
				print("[NOTE] type whas: '");
				print(constant.constType.name);
				print("', expected 'int', 'char', or 'str'\n");
			}

			next(parser);
			return regId;
		}

		var variable = findVariable(parser.scope, token.word, token.wordLen, (bool)0);

		if (variable != (Variable)0) {
			return parseVariable(parser, variable);
		}

		var function = findFunction(parser.scope, token.word, token.wordLen, (bool)0);

		if (function != (Function)0) {
			return functionCall(parser, function);
		}

		parseError(parser, token, "can not find a value with this name");
		return 0;
	}

	func number(Parser parser, bool isConstant) -> int {
		var numberString = strndup(parser.current.word, parser.current.wordLen);
		var numberStringLen = parser.current.wordLen;

		next(parser);

		parser.lastType = findType(parser.scope, "int", 3, (bool)0);

		if (isConstant) {
			var value = strToInt(numberString, numberStringLen);
			free((ptr)numberString);
			return value;
		}

		var register = writeNumber(parser.compiler, numberString);

		free((ptr)numberString);

		return register;
	}

	func character(Parser parser, bool isConstant) -> int {
		var string = parser.current.word;
		next(parser);

		parser.lastType = findType(parser.scope, "char", 4, (bool)0);

		if (isConstant) {
			return (int)unEscapeCharacter(string);
		} else {
			var register = writeCharacter(parser.compiler, string);
			return register;
		}
		return 0;
	}

	func string(Parser parser, bool isConstant) -> int {
		var id = parser.stringList.size;

		addString(parser.stringList, strndup(parser.current.word, parser.current.wordLen));

		next(parser);

		parser.lastType = findType(parser.scope, "str", 3, (bool)0);

		if (isConstant) {
			return id;
		}

		return writeString(parser.compiler, id);
	}

	func parseSize(Parser parser, bool isConstant) -> int {
		next(parser);

		consumeToken(parser, TOKEN_LPAREN, "expected '(' after 'sizeof'");

		var typeObj = consumeType(parser, "expected type in 'sizeof'");

		if (typeObj == (Type)0) { return 0; }

		consumeToken(parser, TOKEN_RPAREN, "expected ')' after type in sizeof");

		var size = 0;
		if (typeObj.properties == (PropertyList)0) {
			size = typeObj.size;
		} else {
			size = typeObj.properties.totalTypeSize;
		}

		parser.lastType = findType(parser.scope, "int", 3, (bool)0);

		if (isConstant) {
			return size;
		}

		var numString = intToString(size);
		var regId = writeNumber(parser.compiler, numString);

		free((ptr)numString);

		return regId;
	}

	func property(Parser parser, bool isConstant) -> int {
		func unary(Parser parser, bool isConstant) -> int {
			var currentType = parser.current.tokenType;

			if (currentType == TOKEN_IDENTIFIER) {
				return identifier(parser, isConstant);
			} else if (currentType == TOKEN_NUMBER) {
				return number(parser, isConstant);
			} else if (currentType == TOKEN_CHAR) {
				return character(parser, isConstant);
			} else if (currentType == TOKEN_STR) {
				return string(parser, isConstant);
			} else if (currentType == TOKEN_MINUS) {
				next(parser);

				var value = unary(parser, isConstant);

				if (isConstant) {
					return -value;
				} else {
					return writeNegative(parser.compiler, value);
				}
			} else if (currentType == TOKEN_LPAREN) {
				next(parser);

				var current = parser.current;
				if (current.tokenType == TOKEN_IDENTIFIER) {
					var castType = findType(parser.scope, current.word, current.wordLen, (bool)0);
					if (castType != (Type)0) {
						castType = consumeType(parser, "expected type in typecast");
						
						consumeToken(parser, TOKEN_RPAREN, "expected ')' after casting type");

						var registerId = property(parser, isConstant);

						parser.lastType = castType;
						return registerId;
					}
				}

				var value = expression(parser, isConstant);

				consumeToken(parser, TOKEN_RPAREN, "expected ')' after group");

				return value;
			} else if (currentType == TOKEN_SIZEOF) {
				return parseSize(parser, isConstant);
			} else {
				parseError(parser, parser.current, "this token is not recognised as a unary");
			}

			return 0;
		}

		var value = unary(parser, isConstant);

		func parseIndex(Parser parser) -> int {
			if (parser.lastType.isArray == (bool)0) {
				parseError(parser, parser.current, "can not index from a value that is not an array");
				return -1;
			}

			var arrayType = parser.lastType.arrayType;

			next(parser);

			var indexReg = expression(parser, (bool)0);

			if (parser.lastType != findType(parser.scope, "int", 3, (bool)0)) {
				parseError(parser, parser.current, "expected array index to be of type 'int'");
				return -1;
			}

			consumeToken(parser, TOKEN_RBRACKET, "expected ']' after array index");

			var retReg = 0;
			if (parser.current.tokenType == TOKEN_EQUAL) {
				next(parser);

				var valReg = expression(parser, (bool)0);

				if (arrayType != parser.lastType) {
					parseError(parser, parser.current, "can not set a value of an array to a value of a different type");
				}

				retReg = writeWriteIndex(parser.compiler, arrayType.size, value, indexReg, valReg);
			} else {
				retReg = writeReadIndex(parser.compiler, arrayType.size, value, indexReg);
			}

			parser.lastType = arrayType;
			return retReg;
		}

		func parseProperty(Parser parser, int pointerReg) -> int {
			next(parser);

			var typeObj = parser.lastType;
			var nameToken = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of property");

			if (typeObj == (Type)0) {
				parseError(parser, nameToken, "problem in type when reading property");
				return -1;
			}

			var propertyObj = findProperty(typeObj.properties, nameToken.word, nameToken.wordLen);

			if (propertyObj == (Property)0) {
				parseError(parser, nameToken, "can not find property");
				return -1;
			}

			var newType = typeObj.propertyTypes[propertyObj.index];

			var regId = 0;

			if (parser.current.tokenType == TOKEN_EQUAL) {
				next(parser);

				regId = expression(parser, (bool)0);

				if (parser.lastType != newType) {
					parseError(parser, parser.current, "expected different type when writing property");
				}

				regId = writeWriteProperty(parser.compiler, propertyObj.offset, newType.size, pointerReg, regId);
			} else {
				regId = writeReadProperty(parser.compiler, propertyObj.offset, newType.size, pointerReg);
			}

			parser.lastType = newType;

			return regId;
		}

		while (parser.current.tokenType == TOKEN_LBRACKET ||
			parser.current.tokenType == TOKEN_PERIOD) {

			if (isConstant) {
				parseError(parser, parser.current, "lists and properties are currently not supported in constant evaluation");
				return 0;
			}

			if (parser.current.tokenType == TOKEN_LBRACKET) {
				value = parseIndex(parser);
			}

			if (parser.current.tokenType == TOKEN_PERIOD) {
				value = parseProperty(parser, value);
			}
		}

		return value;
	}

	func bitWise(Parser parser, bool isConstant) -> int {
		var value = property(parser, isConstant);

		var currentType = parser.lastType;
		var intType = findType(parser.scope, "int", 3, (bool)0);

		var tokenType = parser.current.tokenType;
		while (tokenType == TOKEN_AND ||
			tokenType == TOKEN_PIPE) {
			next(parser);

			var value2 = property(parser, isConstant);

			if (currentType != intType || parser.lastType != intType) {
				parseError(parser, parser.current, "can not use '&' or '|' on values that are not of type 'int'");
				return 0;
			}

			if (tokenType == TOKEN_AND) {
				if (isConstant) {
					value = value & value2;
				} else {
					value = writeBitAnd(parser.compiler, value, value2);
				}
			}
			if (tokenType == TOKEN_PIPE) {
				if (isConstant) {
					value = value | value2;
				} else {
					value = writeBitOr(parser.compiler, value, value2);
				}
			}

			tokenType = parser.current.tokenType;
		}

		return value;
	}

	func factor(Parser parser, bool isConstant) -> int {
		var value = bitWise(parser, isConstant);

		var tokenType = parser.current.tokenType;
		while (tokenType == TOKEN_STAR) {
			next(parser);

			var value2 = bitWise(parser, isConstant);

			if (isConstant) {
				value = value * value2;
			} else {
				value = writeMult(parser.compiler, value, value2);
			}

			tokenType = parser.current.tokenType;
		}

		return value;
	}

	func term(Parser parser, bool isConstant) -> int {
		var value = factor(parser, isConstant);

		var currentType = parser.lastType;
		var intType = findType(parser.scope, "int", 3, (bool)0);
		var charType = findType(parser.scope, "char", 4, (bool)0);

		var tokenType = parser.current.tokenType;
		while (tokenType == TOKEN_PLUS ||
			tokenType == TOKEN_MINUS) {
			next(parser);

			var value2 = factor(parser, isConstant);

			if (tokenType == TOKEN_PLUS) {
				if (currentType == intType) {
					if (parser.lastType != intType && parser.lastType != charType) {
						parseError(parser, parser.current, "right hand side of addition is not of type 'int' or 'char'");
					}
				} else if (currentType == charType) {
					if (parser.lastType == intType) {
						parser.lastType = charType;
					} else if (parser.lastType == charType) {
						parseError(parser, parser.current, "can not add two characters");
					} else {
						parseError(parser, parser.current, "right hand side of addition is not of type 'int' or 'char'");
					}
				} else {
					parseError(parser, parser.current, "left hand side of addition is not of type 'int' or 'char'");
				}

				if (isConstant) {
					value = value + value2;
				} else {
					value = writeAdd(parser.compiler, value, value2);
				}
			}

			if (tokenType == TOKEN_MINUS) {
				if (currentType == intType) {
					if (parser.lastType != intType) {
						if (parser.lastType != charType) {
							parseError(parser, parser.current, "can not subtract a character from an integer");
						} else {
							parseError(parser, parser.current, "right hand side of subtraction is not of type 'int' or 'char'");
						}
					}
				} else if (currentType == charType) {
					if (parser.lastType == charType) {
						parser.lastType = intType;
					} else if (parser.lastType == intType) {
						parser.lastType = charType;
					} else {
						parseError(parser, parser.current, "right hand side of subtraction is not of type 'int' or 'char'");
					}
				} else {
					parseError(parser, parser.current, "left hand side of subtraction is not of type 'int' or 'char'");
				}

				if (isConstant) {
					value = value - value2;
				} else {
					value = writeSubtract(parser.compiler, value, value2);
				}
			}

			tokenType = parser.current.tokenType;
			currentType = parser.lastType;
		}

		return value;
	}

	func bitShift(Parser parser, bool isConstant) -> int {
		var value = term(parser, isConstant);
		
		var intType = findType(parser.scope, "int", 3, (bool)0);

		var tokenType = parser.current.tokenType;
		while (tokenType == TOKEN_LESSLESS ||
			tokenType == TOKEN_GREATERGREATER) {
			if (parser.lastType != intType) {
				parseError(parser, parser.current, "left hand side of a bitshift operation is expected to be of type `int`");
				return 0;
			}

			next(parser);

			var value2 = term(parser, isConstant);

			if (parser.lastType != intType) {
				parseError(parser, parser.current, "left hand side of a bitshift operation is expected to be of type `int`");
				return 0;
			}

			if (tokenType == TOKEN_LESSLESS) {
				if (isConstant) {
					value = value << value2;
				} else {
					value = writeShiftLeft(parser.compiler, value, value2);
				}
			} else if (tokenType == TOKEN_GREATERGREATER) {
				if (isConstant) {
					value = value >> value2;
				} else {
					value = writeShiftRight(parser.compiler, value, value2);
				}
			}

			tokenType = parser.current.tokenType;
		}

		return value;
	}

	func comparison(Parser parser, bool isConstant) -> int {
		var value = bitShift(parser, isConstant);

		var firstType = parser.lastType;

		var tokenType = parser.current.tokenType;
		if (tokenType == TOKEN_EQUALEQUAL ||
			tokenType == TOKEN_BANGEQUAL ||
			tokenType == TOKEN_LESS ||
			tokenType == TOKEN_LESSEQUAL ||
			tokenType == TOKEN_GREATER ||
			tokenType == TOKEN_GREATEREQUAL) {
			next(parser);

			var value2 = bitShift(parser, isConstant);

			if (firstType != parser.lastType) {
				parseError(parser, parser.current, "cannot make a comparison between values of different types");
			}

			if (tokenType == TOKEN_EQUALEQUAL) {
				if (isConstant) {
					value = (int)(value == value2);
				} else {
					value = writeEqual(parser.compiler, value, value2);
				}
			}

			if (tokenType == TOKEN_BANGEQUAL) {
				if (isConstant) {
					value = (int)(value != value2);
				} else {
					value = writeNotEqual(parser.compiler, value, value2);
				}
			}

			if (tokenType == TOKEN_LESS) {
				if (isConstant) {
					value = (int)(value < value2);
				} else {
					value = writeLess(parser.compiler, value, value2);
				}
			}

			if (tokenType == TOKEN_LESSEQUAL) {
				if (isConstant) {
					value = (int)(value <= value2);
				} else {
					value = writeLessEqual(parser.compiler, value, value2);
				}
			}

			if (tokenType == TOKEN_GREATER) {
				if (isConstant) {
					value = (int)(value > value2);
				} else {
					value = writeGreater(parser.compiler, value, value2);
				}
			}

			if (tokenType == TOKEN_GREATEREQUAL) {
				if (isConstant) {
					value = (int)(value >= value2);
				} else {
					value = writeGreaterEqual(parser.compiler, value, value2);
				}
			}

			parser.lastType = findType(parser.scope, "bool", 4, (bool)0);
		}

		return value;
	}

	func logicAnd(Parser parser, bool isConstant) -> int {
		var value = comparison(parser, isConstant);

		var tokenType = parser.current.tokenType;
		while (tokenType == TOKEN_ANDAND) {
			next(parser);

			var andId = parser.numAnds;
			parser.numAnds = andId + 1;

			if (parser.lastType != findType(parser.scope, "bool", 4, (bool)0)) {
				parseError(parser, parser.current, "left hand side of '&&' operation is not of type 'bool'");
				return 0;
			}

			writeCondition(parser.compiler, value);
			writeJumpNotEqual(parser.compiler, "addr_and_", andId);

			var value2 = comparison(parser, isConstant);
			if (isConstant) {
				value = value & value2;
			}

			if (parser.lastType != findType(parser.scope, "bool", 4, (bool)0)) {
				parseError(parser, parser.current, "right hand side of '&&' operation is not of type 'bool'");
				return 0;
			}

			writeJump(parser.compiler, "addr_end_and_", andId);
			writeAddress(parser.compiler, "addr_and_", andId);

			writeNumberInRegister(parser.compiler, "0", value); // false

			writeAddress(parser.compiler, "addr_end_and_", andId);

			tokenType = parser.current.tokenType;
		}

		return value;
	}

	func logicOr(Parser parser, bool isConsant) -> int {
		var value = logicAnd(parser, isConstant);

		var tokenType = parser.current.tokenType;
		while (tokenType == TOKEN_PIPEPIPE) {
			next(parser);

			var orId = parser.numOrs;
			parser.numOrs = orId + 1;

			if (parser.lastType != findType(parser.scope, "bool", 4, (bool)0)) {
				parseError(parser, parser.current, "left hand side of '||' operation is not of type 'bool'");
				return 0;
			}

			writeCondition(parser.compiler, value);
			writeJumpEqual(parser.compiler, "addr_or_", orId);

			var value2 = logicAnd(parser, isConstant);
			if (isConstant) {
				value = value | value2;
			} else {
				value = value2;
			}

			if (parser.lastType != findType(parser.scope, "bool", 4, (bool)0)) {
				parseError(parser, parser.current, "right hand side of '||' operation is not of type 'bool'");
				return 0;
			}

			writeJump(parser.compiler, "addr_end_or_", orId);
			writeAddress(parser.compiler, "addr_or_", orId);

			writeNumberInRegister(parser.compiler, "1", value); // false

			writeAddress(parser.compiler, "addr_end_or_", orId);

			tokenType = parser.current.tokenType;
		}

		return value;
	}

	return logicOr(parser, isConstant);
}

func importStatement(Parser parser) {
	next(parser);
	var nameToken = parser.current;
	if (nameToken.tokenType != TOKEN_STR) { parseError(parser, parser.current, "expected name of import file"); }

	var name = strndup(nameToken.word, nameToken.wordLen);

	var filePath = getLocalFilePath(parser.lexer.fileName, name);
	var fileName = getFullPathString(filePath);

	var i = 0;
	while (i < parser.fileList.size) {
		if (streq(parser.fileList.strings[i], fileName)) {
			free((ptr)fileName);
			free((ptr)name);

			next(parser);
			return;
		}
		i = i + 1;
	}

	addString(parser.fileList, fileName);
	parser.lexer = initLexer(strdup(fileName), parser.lexer);
	next(parser);

	free((ptr)name);
}

func variableDefinition(Parser parser) {
	next(parser);

	var nameToken = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of variable");

	var varName = nameToken.word;
	var varNameLen = nameToken.wordLen;

	if (nameToken.tokenType == TOKEN_ERROR) {
		return;
	}

	if (findVariable(parser.scope, nameToken.word, nameToken.wordLen, (bool)1) != (Variable)0) {
		parseError(parser, nameToken, "a variable with this name already exists in this scope");
		return;
	}

	if (findType(parser.scope, nameToken.word, nameToken.wordLen, (bool)0) != (Type)0) {
		parseError(parser, nameToken, "a type with this name already exists");
		return;
	}

	if (findFunction(parser.scope, nameToken.word, nameToken.wordLen, (bool)0) != (Function)0) {
		parseError(parser, nameToken, "a function with this name already exists");
		return;
	}
	
	if (consumeToken(parser, TOKEN_EQUAL, "expected '=' in variable definition").tokenType == TOKEN_ERROR) { return; }

	var regId = expression(parser, (bool)0);
	writePush(parser.compiler, regId);

	defineVariable(parser.scope, varName, varNameLen, parser.compiler.currentStackSize, parser.lastType);

	consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after variable definition");
}

func constantDefinition(Parser parser) {
	next(parser);

	var nameToken = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of constant");

	var constName = nameToken.word;
	var constNameLen = nameToken.wordLen;

	if (nameToken.tokenType == TOKEN_ERROR) {
		return;
	}

	if (findVariable(parser.scope, nameToken.word, nameToken.wordLen, (bool)0) != (Variable)0) {
		parseError(parser, nameToken, "a variable with this name already exists");
		return;
	}

	if (findType(parser.scope, nameToken.word, nameToken.wordLen, (bool)0) != (Type)0) {
		parseError(parser, nameToken, "a type with this name already exists");
		return;
	}

	if (findFunction(parser.scope, nameToken.word, nameToken.wordLen, (bool)0) != (Function)0) {
		parseError(parser, nameToken, "a function with this name already exists");
		return;
	}

	if (consumeToken(parser, TOKEN_EQUAL, "expected '=' in variable definition").tokenType == TOKEN_ERROR) { return; }

	var value = expression(parser, (bool)1);

	defineConstant(parser.scope, constName, constNameLen, value, parser.lastType);

	consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after constant definition");
}

func typeDefinition(Parser parser) {
	next(parser);

	var nameToken = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of variable");

	var typeName = nameToken.word;
	var typeNameLen = nameToken.wordLen;

	if (nameToken.tokenType == TOKEN_ERROR) {
		return;
	}

	if (findVariable(parser.scope, nameToken.word, nameToken.wordLen, (bool)0) != (Variable)0) {
		parseError(parser, nameToken, "a variable with this name already exists");
		return;
	}

	if (findType(parser.scope, nameToken.word, nameToken.wordLen, (bool)1) != (Type)0) {
		parseError(parser, nameToken, "a type with this name already exists in this scope");
		return;
	}

	if (findFunction(parser.scope, nameToken.word, nameToken.wordLen, (bool)0) != (Function)0) {
		parseError(parser, nameToken, "a function with this name already exists");
		return;
	}

	var typeObj = defineType(parser.scope, typeName, typeNameLen, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	
	if (consumeToken(parser, TOKEN_LBRACE, "expected '{' in type definition").tokenType == TOKEN_ERROR) { return; }

	var i = 0;
	var properties = initPropertyList();
	var types = initTypeList();

	while (parser.current.tokenType != TOKEN_RBRACE && parser.current.tokenType != TOKEN_END_OF_FILE) {
		var propertyType = consumeType(parser, "expected type property to start with type");
		var propertyName = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of type property");

		if (propertyType == (Type)0 || propertyName.tokenType == TOKEN_ERROR) { return; }

		addProperty(properties, strndup(propertyName.word, propertyName.wordLen), i, propertyType.size);
		addType(types, propertyType);
		i = i + 1;

		consumeToken(parser, TOKEN_SEMICOLON, "expected property to end with ';'");
	}

	typeObj.properties = properties;
	typeObj.propertyTypes = types.types;
	free((ptr)types);

	consumeToken(parser, TOKEN_RBRACE, "expected '}' after type definition");
}

func statement(Parser parser) {
	func block(Parser parser, Function function) {
		var scope = initScope(parser.scope);
		var outerStackSize = parser.compiler.currentStackSize;

		parser.scope = scope;

		if (function != (Function)0) {
			scope.function = function;
			scope.functionDepth = scope.functionDepth + 1;
			parser.compiler.functionDepth = scope.functionDepth;

			var i = 0;
			while (i < function.parameters.size) {
				var variable = function.parameters.variables[i];

				i = i + 1;
				defineVariable(scope, variable.name, strlen(variable.name), i, variable.varType);
			}

			parser.compiler.currentStackSize = i + 10;
		}

		while (parser.current.tokenType != TOKEN_RBRACE && parser.current.tokenType != TOKEN_END_OF_FILE) {
			statement(parser);
		}

		if (scope.function != scope.outer.function) {
			if (scope.hasReturned == (bool)0) {
				if (streq(scope.function.returnType.name, "null")) {
					var numVars = (parser.compiler.currentStackSize - scope.function.parameters.size) - 10;
					writeReturnEmpty(parser.compiler, numVars, scope.function.parameters.size);
				} else {
					parseError(parser, parser.current, "not all code paths return a value");
				}
			}
			parser.compiler.currentStackSize = outerStackSize;
		} else {
			var numLocalVariables = scope.variableList.size;
			writePop(parser.compiler, numLocalVariables);
		}

		
		if (consumeToken(parser, TOKEN_RBRACE, "expected '}' after block").tokenType == TOKEN_ERROR && function != (Function)0) {
			print("[NOTE] this was in function: '");
			print(function.name);
			print("'\n");
		}

		parser.scope = scope.outer;
		parser.compiler.functionDepth = parser.scope.functionDepth;

		freeScope(scope);
	}

	func functionDefinition(Parser parser) {
		var funcId = parser.numFuncs;
		parser.numFuncs = funcId + 1;

		next(parser);

		var nameToken = consumeToken(parser, TOKEN_IDENTIFIER, "expected function name in definition");
		var name = nameToken.word;
		var nameLen = nameToken.wordLen;

		if (findVariable(parser.scope, nameToken.word, nameToken.wordLen, (bool)0) != (Variable)0) {
			parseError(parser, nameToken, "can not define a function with the same name as a variable");
		}

		if (findType(parser.scope, nameToken.word, nameToken.wordLen, (bool)0) != (Type)0) {
			parseError(parser, nameToken, "can not define a function with the same name as a type");
		}

		if (findFunction(parser.scope, nameToken.word, nameToken.wordLen, (bool)1) != (Function)0) {
			parseError(parser, nameToken, "there already exists a function with this name in this scope");
		}

		consumeToken(parser, TOKEN_LPAREN, "expected '(' after function name");

		var parameters = initVariableList();

		var i = 0;
		var depth = parser.scope.functionDepth + 1;

		if (parser.current.tokenType != TOKEN_RPAREN) {
			var varType = consumeType(parser, "expected type of function argument");

			var argName = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of function argument");

			addVariable(parameters, strndup(argName.word, argName.wordLen), i, depth, varType);

			i = i + 1;
		}

		while (parser.current.tokenType == TOKEN_COMMA) {
			next(parser);

			var varType = consumeType(parser, "expected type of function argument");

			var argName = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of function argument");

			addVariable(parameters, strndup(argName.word, argName.wordLen), i, depth, varType);

			i = i + 1;
		}

		consumeToken(parser, TOKEN_RPAREN, "expected ')' after function arguments");

		var returnType = findType(parser.scope, "null", 4, (bool)0);

		if (parser.current.tokenType == TOKEN_RARROW) {
			next(parser);

			returnType = consumeType(parser, "expected return type");
		}

		var function = defineFunction(parser.scope, name, nameLen, funcId, returnType, parameters);

		consumeToken(parser, TOKEN_LBRACE, "expected '{' before function block");

		writeBeginFunction(parser.compiler, function.name, funcId, parameters.size);

		block(parser, function);

		writeAddress(parser.compiler, "addr_func_end_", funcId);
	}

	func returnStatement(Parser parser) {
		if (parser.scope.function == (Function)0) {
			parseError(parser, parser.current, "can not return from outside a function");
			consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after a return statement");
			return;
		}

		next(parser);

		var function = parser.scope.function;

		var numVars = parser.compiler.currentStackSize - function.parameters.size - 10;

		if (function.returnType == findType(parser.scope, "null", 4, (bool)0)) {
			consumeToken(parser, TOKEN_SEMICOLON, "expected an empty return in a 'null' function");
			writeReturnEmpty(parser.compiler, numVars, function.parameters.size);
		} else {
			var regId = expression(parser, (bool)0);

			if (parser.lastType != function.returnType) {
				parseError(parser, parser.current, "incorrect return type");
			}

			consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after return statement");

			writeReturnValue(parser.compiler, numVars, function.parameters.size, regId);
		}

		parser.scope.hasReturned = (bool)1;
	}

	func ifStatement(Parser parser) {
		var ifId = parser.numIfs;
		parser.numIfs = ifId + 1;

		next(parser);

		consumeToken(parser, TOKEN_LPAREN, "expected '(' before 'if' condition");

		var regId = expression(parser, (bool)0);

		if (parser.lastType != findType(parser.scope, "bool", 4, (bool)0)) {
			parseError(parser, parser.current, "expected 'if' condition to be of type 'bool'");
		}

		writeCondition(parser.compiler, regId);

		consumeToken(parser, TOKEN_RPAREN, "expected ')' after 'if' condition");

		writeJumpNotEqual(parser.compiler, "addr_if_", ifId);

		consumeToken(parser, TOKEN_LBRACE, "expected '{' before 'if' block");

		block(parser, (Function)0);

		var hadElse = (bool)0;
		var hadFinalElse = (bool)0;
		
		var elseId = parser.numElses;

		while (parser.current.tokenType == TOKEN_ELSE && hadFinalElse == (bool)0) {
			writeJump(parser.compiler, "addr_else_", elseId);
			writeAddress(parser.compiler, "addr_if_", ifId);

			if (hadElse == (bool)0) {
				parser.numElses = elseId + 1;
			}

			next(parser);

			if (parser.current.tokenType == TOKEN_IF) {
				ifId = parser.numIfs;
				parser.numIfs = ifId + 1;

				next(parser);

				consumeToken(parser, TOKEN_LPAREN, "expected '(' before 'else if' condition");

				var regId = expression(parser, (bool)0);

				if (parser.lastType != findType(parser.scope, "bool", 4, (bool)0)) {
					parseError(parser, parser.current, "expected 'else if' condition to be of type 'bool'");
				}

				writeCondition(parser.compiler, regId);

				consumeToken(parser, TOKEN_RPAREN, "expected ')' after 'else if' condition");
				writeJumpNotEqual(parser.compiler, "addr_if_", ifId);

				consumeToken(parser, TOKEN_LBRACE, "expected '{' before 'else if' block");

				block(parser, (Function)0);
			} else {
				consumeToken(parser, TOKEN_LBRACE, "expected '{' before 'else' block");

				block(parser, (Function)0);

				hadFinalElse = (bool)1;
			}

			hadElse = (bool)1;
		}

		if (hadFinalElse == (bool)0) {
			writeAddress(parser.compiler, "addr_if_", ifId);
		}

		if (hadElse) {
			writeAddress(parser.compiler, "addr_else_", elseId);
		}
	}

	func whileStatement(Parser parser) {
		var whileId = parser.numWhiles;
		parser.numWhiles = whileId + 1;

		next(parser);

		consumeToken(parser, TOKEN_LPAREN, "expected '(' before 'while' condition");

		writeAddress(parser.compiler, "addr_while_condition_", whileId);

		var regId = expression(parser, (bool)0);

		if (parser.lastType != findType(parser.scope, "bool", 4, (bool)0)) {
			parseError(parser, parser.current, "expected 'while' condition to be of type 'bool'");
		}

		writeCondition(parser.compiler, regId);

		consumeToken(parser, TOKEN_RPAREN, "expected ')' after 'while' condition");

		writeJumpNotEqual(parser.compiler, "addr_while_end_", whileId);

		consumeToken(parser, TOKEN_LBRACE, "expected '{' before 'if' block");

		block(parser, (Function)0);

		writeJump(parser.compiler, "addr_while_condition_", whileId);
		writeAddress(parser.compiler, "addr_while_end_", whileId);
	}

	if (parser.current.tokenType == TOKEN_IMPORT) {
		importStatement(parser);
	} else if (parser.current.tokenType == TOKEN_VAR) {
		variableDefinition(parser);
	} else if (parser.current.tokenType == TOKEN_CONST) {
		constantDefinition(parser);
	} else if (parser.current.tokenType == TOKEN_TYPE) {
		typeDefinition(parser);
	} else if (parser.current.tokenType == TOKEN_FUNC) {
		functionDefinition(parser);
	} else if (parser.current.tokenType == TOKEN_RETURN) {
		returnStatement(parser);
	} else if (parser.current.tokenType == TOKEN_IF) {
		ifStatement(parser);
	} else if (parser.current.tokenType == TOKEN_WHILE) {
		whileStatement(parser);
	} else {
		var regId = expression(parser, (bool)0);

		consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after expression");
		freeRegister(parser.compiler, regId);
	}
}

func parse(Parser parser) {
	writeHeader(parser.compiler);

	while (parser.current.tokenType != TOKEN_END_OF_FILE) {
		statement(parser);
	}

	writeFooter(parser.compiler, parser.stringList);
}
