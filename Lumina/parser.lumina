import "lexer.lumina"
import "compiler.lumina"

import "luminaStrings.lumina"

type Parser {
	Lexer lexer;
	Token last;
	Token current;

	Type lastType;

	Compiler compiler;
	int outputFile; // int here is a file descriptor

	int numIfs;
	int numElses;
	int numAnds;
	int numOrs;
	int numWhiles;
	int numFuncs;

	StringList stringList;

	bool hasError;
	bool isChecking;
}

func initParser(str inputName, str outputName, bool isChecking) -> Parser {
	var parser = (Parser)malloc(sizeof(Parser));

	parser.lexer = initLexer(inputName, (Lexer)0);
	parser.last = (Token)0;
	parser.current = nextToken(parser.lexer);

	if (isChecking) {
		parser.outputFile = open("/dev/null", 1, 0);
	} else {
		parser.outputFile = open(outputName, 577, 511);
	}

	if (parser.outputFile < 0) {
		print("could not open/create file '");
		print(outputName);
		print("'\n");

		print("error code: ");
		printi(parser.outputFile);
		print(" \n");

		exit(1);
	}

	parser.compiler = initCompiler(parser.outputFile, (Compiler)0);

	parser.numIfs = 0;
	parser.numElses = 0;
	parser.numAnds = 0;
	parser.numOrs = 0;
	parser.numWhiles = 0;

	var anyType = defineType(parser.compiler, "any", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var intType = defineType(parser.compiler, "int", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	defineType(parser.compiler, "ptr", 3, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var charType = defineType(parser.compiler, "char", 4, 1, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	var strType = defineType(parser.compiler, "str", 3, 8, (PropertyList)0, (Type[])0, (bool)1, charType);
	defineType(parser.compiler, "bool", 4, 1, (PropertyList)0, (Type[])0, (bool)0, (Type)0);
	defineType(parser.compiler, "null", 4, 8, (PropertyList)0, (Type[])0, (bool)0, (Type)0);

	var name = "syscall";
	var nameLen = strlen(name);
	var id = 0;
	
	var parameters = initVariableList();
	var i = 0;
	while (i < 7) {
		addVariable(parameters, strdup("  "), i, 0, anyType);
		i = i + 1;
	}

	parser.compiler.currentStackSize = parser.compiler.currentStackSize + 1;
	defineVariable(parser.compiler, "argc", 4, intType);
	parser.compiler.currentStackSize = parser.compiler.currentStackSize + 1;
	defineVariable(parser.compiler, "argv", 4, initType("  ", 8, (PropertyList)0, (Type[])0, (bool)1, strType));

	defineFunction(parser.compiler, name, nameLen, 0, anyType, parameters);

	parser.numFuncs = 1;

	parser.stringList = initStringList();

	parser.hasError = (bool)0;
	parser.isChecking = isChecking;

	return parser;
}

func freeParser(Parser parser) {
	freeLexer(parser.lexer);

	if (parser.last != (Token)0) {
		free((ptr)(parser.last));
	}

	if (parser.current != (Token)0) {
		free((ptr)(parser.current));
	}

	freeStringList(parser.stringList);

	close(parser.outputFile);
	freeCompiler(parser.compiler);

	free((ptr)parser);
}

func next(Parser parser) -> Token {
	if (parser.last != (Token)0) {
		free((ptr)(parser.last));
	}

	parser.last = parser.current;
	parser.current = nextToken(parser.lexer);

	if (parser.current.tokenType == TOKEN_END_OF_FILE && parser.lexer.outer != (Lexer)0) {
		var current = parser.lexer;
		parser.lexer = parser.lexer.outer;
		freeLexer(current);

		parser.current = next(parser);
	}

	return parser.current;
}

func parseError(Parser parser, Token token, str message) {
	parser.hasError = (bool)1;

	print(token.fileName);
	print(": ");
	printi(token.line);
	print(": ");
	printi(token.column);

	print(":error: at '");
	printn(token.word, token.wordLen);
	print("', ");

	print(message);
	print(" \n");

	while (parser.current.tokenType != TOKEN_SEMICOLON &&
		parser.current.tokenType != TOKEN_COMMA && 
		parser.current.tokenType != TOKEN_END_OF_FILE) {
		next(parser);
	}
}

func consumeToken(Parser parser, int tokenType, str message) -> Token{
	var token = parser.current;
	next(parser);

	if (token.tokenType != tokenType) {
		parseError(parser, token, message);

		if (token.tokenType != TOKEN_END_OF_FILE) {
			token.tokenType = TOKEN_ERROR;
		}
		return token;
	}
	return token;
}

func expression(Parser parser) {
	func parseVariable(Parser parser, Variable variable) {
		next(parser);

		if (parser.current.tokenType == TOKEN_EQUAL) {
			next(parser);

			expression(parser);

			if (parser.lastType != variable.varType) {
				parseError(parser, parser.current, "cannot assign a value with a different type");
			}

			writeAssignment(parser.compiler, variable.position, parser.compiler.functionDepth);
		} else {
			writeIdentifier(parser.compiler, variable.position, parser.compiler.functionDepth);
		}

		parser.lastType = variable.varType;
	}

	func functionCall(Parser parser, Function function) {
		next(parser);

		consumeToken(parser, TOKEN_LPAREN, "expected '(' after function name");

		if (function.parameters.size == 0) {
			consumeToken(parser, TOKEN_RPAREN, "function does not expect parameters");
		} else {
			expression(parser);

			var i = 1;
			while (i < function.parameters.size) {
				consumeToken(parser, TOKEN_COMMA, "expected ',' between arguments");

				expression(parser);

				i = i + 1;
			}

			// TODO: add type checking to this

			consumeToken(parser, TOKEN_RPAREN, "expected ')' after arguments");
		}
		
		writeCall(parser.compiler, function.id, function.numCalls);
		function.numCalls = function.numCalls + 1;

		parser.lastType = function.returnType;
	}

	func identifier(Parser parser) {
		var token = parser.current;

		var variable = findVariable(parser.compiler, token.word, token.wordLen, (bool)0);

		if (variable != (Variable)0) {
			parseVariable(parser, variable);
			return;
		}

		var function = findFunction(parser.compiler, token.word, token.wordLen, (bool)0);

		if (function != (Function)0) {
			functionCall(parser, function);
			return;
		}

		parseError(parser, token, "can not find a value with this name");
	}

	func number(Parser parser) {
		var numberString = strndup(parser.current.word, parser.current.wordLen);
		writeNumber(parser.compiler, numberString);

		free((ptr)numberString);

		next(parser);

		parser.lastType = findType(parser.compiler, "int", 3, (bool)0);
	}

	func string(Parser parser) {
		var id = parser.stringList.size;

		addString(parser.stringList, strndup(parser.current.word, parser.current.wordLen));
		writeString(parser.compiler, id);

		next(parser);

		parser.lastType = findType(parser.compiler, "str", 3, (bool)0);
	}

	func property(Parser parser) {
		func unary(Parser parser) {
			var currentType = parser.current.tokenType;

			if (currentType == TOKEN_IDENTIFIER) {
				identifier(parser);
			} else if (currentType == TOKEN_NUMBER) {
				number(parser);
			} else if (currentType == TOKEN_STR) {
				string(parser);
			} else if (currentType == TOKEN_MINUS) {
				next(parser);

				unary(parser);

				writeNegative(parser.compiler);
			} else if (currentType == TOKEN_LPAREN) {
				next(parser);

				var current = parser.current;
				if (current.tokenType == TOKEN_IDENTIFIER) {
					var castType = findType(parser.compiler, current.word, current.wordLen, (bool)0);
					if (castType != (Type)0) {
						next(parser);
						
						consumeToken(parser, TOKEN_RPAREN, "expected ')' after casting type");

						property(parser);

						parser.lastType = castType;
						return;
					}
				}

				expression(parser);

				consumeToken(parser, TOKEN_RPAREN, "expected ')' after group");
			} else {
				parseError(parser, parser.current, "this token is not recognised as a unary");
			}
		}

		unary(parser);
	}

	func factor(Parser parser) {
		property(parser);

		var tokenType = parser.current.tokenType;
		while (tokenType == TOKEN_STAR) {
			next(parser);

			property(parser);

			writeMult(parser.compiler);

			tokenType = parser.current.tokenType;
		}
	}

	func term(Parser parser) {
		factor(parser);

		var tokenType = parser.current.tokenType;
		while (tokenType == TOKEN_PLUS ||
			tokenType == TOKEN_MINUS) {
			next(parser);

			factor(parser);

			if (tokenType == TOKEN_PLUS) {
				writeAdd(parser.compiler);
			}

			if (tokenType == TOKEN_MINUS) {
				writeSubtract(parser.compiler);
			}

			tokenType = parser.current.tokenType;
		}
	}

	func comparison(Parser parser) {
		term(parser);

		var firstType = parser.lastType;

		var tokenType = parser.current.tokenType;
		if (tokenType == TOKEN_EQUALEQUAL ||
			tokenType == TOKEN_BANGEQUAL ||
			tokenType == TOKEN_LESS ||
			tokenType == TOKEN_LESSEQUAL ||
			tokenType == TOKEN_GREATER ||
			tokenType == TOKEN_GREATEREQUAL) {
			next(parser);

			term(parser);

			if (firstType != parser.lastType) {
				parseError(parser, parser.current, "cannot make a comparison between values of different types");
			}

			if (tokenType == TOKEN_EQUALEQUAL) {
				writeEqual(parser.compiler);
			}

			if (tokenType == TOKEN_BANGEQUAL) {
				writeNotEqual(parser.compiler);
			}

			if (tokenType == TOKEN_LESS) {
				writeLess(parser.compiler);
			}

			if (tokenType == TOKEN_LESSEQUAL) {
				writeLessEqual(parser.compiler);
			}

			if (tokenType == TOKEN_GREATER) {
				writeGreater(parser.compiler);
			}

			if (tokenType == TOKEN_GREATEREQUAL) {
				writeGreaterEqual(parser.compiler);
			}
		}
	}

	comparison(parser);
}

func importStatement(Parser parser) {
	next(parser);
	var nameToken = parser.current;
	if (nameToken.tokenType != TOKEN_STR) { parseError(parser, parser.current, "expected name of import file"); }

	var name = strndup(nameToken.word, nameToken.wordLen);

	// check if file was imported before

	parser.lexer = initLexer(name, parser.lexer);
	next(parser);

	free((ptr)name);
}

func variableDefinition(Parser parser) {
	next(parser);

	var nameToken = consumeToken(parser, TOKEN_IDENTIFIER, "expected name of variable");

	var varName = nameToken.word;
	var varNameLen = nameToken.wordLen;

	if (nameToken.tokenType == TOKEN_ERROR) {
		return;
	}

	if (findVariable(parser.compiler, nameToken.word, nameToken.wordLen, (bool)1) != (Variable)0) {
		parseError(parser, nameToken, "a variable with this name already exists in this scope");
		return;
	}

	if (findFunction(parser.compiler, nameToken.word, nameToken.wordLen, (bool)0) != (Function)0) {
		parseError(parser, nameToken, "a function with this name already exists");
		return;
	}
	
	if (consumeToken(parser, TOKEN_EQUAL, "expected '=' in variable definition").tokenType == TOKEN_ERROR) { return; }

	expression(parser);

	defineVariable(parser.compiler, varName, varNameLen, parser.lastType);

	consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after variable definition");
}

func statement(Parser parser) {
	func block(Parser parser) {
		var scopeCompiler = initCompiler(parser.outputFile, parser.compiler);

		while (parser.current.tokenType != TOKEN_RBRACE && parser.current.tokenType != TOKEN_END_OF_FILE) {
			statement(parser);
		}

		consumeToken(parser, TOKEN_RBRACE, "expected '}' after block");

		parser.compiler = scopeCompiler.outer;
		freeCompiler(scopeCompiler);
	}

	func ifStatement(Parser parser) {
		var ifId = parser.numIfs;
		parser.numIfs = ifId + 1;

		next(parser);

		consumeToken(parser, TOKEN_LPAREN, "expected '(' before 'if' condition");

		expression(parser);

		if (parser.lastType != findType(parser.compiler, "bool", 4, (bool)0)) {
			parseError(parser, parser.current, "expected 'if' condition to be of type 'bool'");
		}

		writeCondition(parser.compiler);

		consumeToken(parser, TOKEN_RPAREN, "expected ')' after 'if' condition");

		writeJumpNotEqual(parser.compiler, "addr_if", ifId);

		consumeToken(parser, TOKEN_LBRACE, "expected '{' before 'if' block");

		block(parser);

		var hadElse = (bool)0;
		var hadFinalElse = (bool)0;
		
		var elseId = parser.numElses;

		while (parser.current.tokenType == TOKEN_ELSE && hadFinalElse == (bool)0) {
			writeJump(parser.compiler, "addr_else", elseId);
			writeAddress(parser.compiler, "addr_if", ifId);

			if (hadElse == (bool)0) {
				parser.numElses = elseId + 1;
			}

			next(parser);

			if (parser.current.tokenType == TOKEN_IF) {
				ifId = parser.numIfs;
				parser.numIfs = ifId + 1;

				next(parser);

				consumeToken(parser, TOKEN_LPAREN, "expected '(' before 'else if' condition");

				expression(parser);

				if (parser.lastType != findType(parser.compiler, "bool", 4, (bool)0)) {
					parseError(parser, parser.current, "expected 'else if' condition to be of type 'bool'");
				}

				writeCondition(parser.compiler);

				consumeToken(parser, TOKEN_RPAREN, "expected ')' after 'else if' condition");
				writeJumpNotEqual(parser.compiler, "addr_if", ifId);

				consumeToken(parser, TOKEN_LBRACE, "expected '{' before 'else if' block");

				block(parser);
			} else {
				consumeToken(parser, TOKEN_LBRACE, "expected '{' before 'else' block");

				block(parser);

				hadFinalElse = (bool)1;
			}

			hadElse = (bool)1;
		}

		if (hadFinalElse == (bool)0) {
			writeAddress(parser.compiler, "addr_if", ifId);
		}

		if (hadElse) {
			writeAddress(parser.compiler, "addr_else", elseId);
		}
	}

	if (parser.current.tokenType == TOKEN_IMPORT) {
		importStatement(parser);
	} else if (parser.current.tokenType == TOKEN_VAR) {
		variableDefinition(parser);
	} else if (parser.current.tokenType == TOKEN_IF) {
		ifStatement(parser);
	} else {
		expression(parser);

		consumeToken(parser, TOKEN_SEMICOLON, "expected ';' after expression");
	}
}

func parse(Parser parser) {
	writeHeader(parser.compiler);

	while (parser.current.tokenType != TOKEN_END_OF_FILE) {
		statement(parser);
	}

	writeFooter(parser.compiler, parser.stringList);
}
