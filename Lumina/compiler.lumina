import "luminaStrings.lumina"

var CALLSTACKSIZE = 2048;

type Register {
	str name;
	bool free;
}

type Compiler {
	int output;
	int currentStackSize;
	int functionDepth;

	Register[] registers;
}

func initRegisters() -> Register[] {
	var list = (Register[])malloc(8 * 8); // 8 register pointers of size 8

	var i = 0;
	while (i < 8) {
		list[i] = (Register)malloc(sizeof(Register) + 5);
		list[i].free = (bool)1;
		i = i + 1;
	}

	list[0].name = "r8";
	list[1].name = "r9";
	list[2].name = "r10";
	list[3].name = "r11";
	list[4].name = "r12";
	list[5].name = "r13";
	list[6].name = "r14";
	list[7].name = "r15";

	return list;
}

func initCompiler(int output) -> Compiler {
	var compiler = (Compiler)malloc(sizeof(Compiler));

	compiler.output = output;
	compiler.currentStackSize = 0;
	compiler.functionDepth = 0;
	compiler.registers = initRegisters();

	return compiler;
}

func freeCompiler(Compiler compiler) {
	var i = 0;
	while (i < 8) {
		free((ptr)compiler.registers[i]);
		i = i + 1;
	}
	free((ptr)compiler.registers);
	free((ptr)compiler);
}

func getRegisterId(Compiler compiler) -> int {
	var i = 0;
	while (i < 8) {
		if (compiler.registers[i].free) {
			compiler.registers[i].free = (bool)0;
			return i;
		}
		i = i + 1;
	}
	print("Lumina currently does not support this many registers, consider refactoring your code to use more variables\n");
	//TODO: handle this error, instead of exiting
	exit(1);
	return 0;
}

func freeRegister(Compiler compiler, int regId) {
	compiler.registers[regId].free = (bool)1;
}

func printEscapedCharacter(Compiler compiler, str charPtr) -> int {
	var length = 1;
	if (charPtr[0] == '\\') {
		length = 2;
	}

	var chr = unEscapeCharacter(charPtr);

	//split the higher and lower 4 bits of the character
	var lower = (int)chr;

	var higher = 0;
	while (lower >= 16) {
		higher = higher + 1;
		lower = lower - 16;
	}

	if (higher >= 16) {
		return -1;
	}

	var charString = (str)malloc(5);

	charString[0] = '0';
	charString[1] = 'x';

	if (0 <= higher && higher <= 9) {
		charString[2] = '0' + higher;
	} else {
		charString[2] = 'A' + (higher - 10);
	}

	if (0 <= lower && lower <= 9) {
		charString[3] = '0' + lower;
	} else {
		charString[3] = 'A' + (lower - 10);
	}

	charString[4] = '\0';

	fprint(compiler.output, charString);

	free((ptr)charString);

	return length;
}


func writeHeader(Compiler compiler) {
	fprint(compiler.output, "section .text\n");
	fprint(compiler.output, "global _start\n");
	fprint(compiler.output, "_start:\n");
	fprint(compiler.output, "	mov rax, rsp\n");
	fprint(compiler.output, "	add rax, 8\n"); // this is where argc and argv are stored
	fprint(compiler.output, "	push rax\n");
	fprint(compiler.output, "	mov [basestack], rax\n");

	fprint(compiler.output, "	;; -- syscall builtin --\n");
	fprint(compiler.output, "	jmp addr_func_end_0\n");
	fprint(compiler.output, "addr_func_syscall_0:\n");
	fprint(compiler.output, "	pop rbx ;; return address\n");
	fprint(compiler.output, "	pop r9\n");
	fprint(compiler.output, "	pop r8\n");
	fprint(compiler.output, "	pop r10\n");
	fprint(compiler.output, "	pop rdx\n");
	fprint(compiler.output, "	pop rsi\n");
	fprint(compiler.output, "	pop rdi\n");
	fprint(compiler.output, "	pop rax\n");
	fprint(compiler.output, "	syscall\n");

	fprint(compiler.output, "	push rbx\n");
	fprint(compiler.output, "	ret\n");

	fprint(compiler.output, "addr_func_end_0:\n");
}

func writePop(Compiler compiler, int amount) {
	fprint(compiler.output, "	add rsp, ");
	fprinti(compiler.output, amount * 8);
	fprint(compiler.output, " ;; pop\n");

	compiler.currentStackSize = compiler.currentStackSize - amount;
}

func writePush(Compiler compiler, int reg) {
	var register = compiler.registers[reg];

	fprint(compiler.output, "	push ");
	fprint(compiler.output, register.name);
	fprint(compiler.output, " ;; push\n");

	register.free = (bool)1;

	compiler.currentStackSize = compiler.currentStackSize + 1;
}

func writeAddress(Compiler compiler, str address, int id) {
	fprint(compiler.output, address);
	fprinti(compiler.output, id);
	fprint(compiler.output, ":\n");
}

func writeBeginFunction(Compiler compiler, str name, int id, int numParams) {
	fprint(compiler.output, "	;; -- function --\n");
	fprint(compiler.output, "	jmp addr_func_end_");
	fprinti(compiler.output, id);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "addr_func_");
	fprint(compiler.output, name);
	fprint(compiler.output, "_");
	fprinti(compiler.output, id);
	fprint(compiler.output, ":\n");
	fprint(compiler.output, "	mov rax, rsp\n");
	fprint(compiler.output, "	add rax, 8 * "); 
	fprinti(compiler.output, numParams + 1);
	fprint(compiler.output, "\n\n");

	fprint(compiler.output, "	;; -- save current stack frame --\n");
	fprint(compiler.output, "	mov rbx, [basestack + 8 * ");
	fprinti(compiler.output, compiler.functionDepth + 1);
	fprint(compiler.output, "]\n");
	fprint(compiler.output, "	push rbx\n\n");

	fprint(compiler.output, "	;; -- create new stack frame --\n");
	fprint(compiler.output, "	mov [basestack + 8 * ");
	fprinti(compiler.output, compiler.functionDepth + 1);
	fprint(compiler.output, "], rax\n\n");

	fprint(compiler.output, "	;; -- store values from registers outside this function --\n");
	fprint(compiler.output, "	push r8\n");
	fprint(compiler.output, "	push r9\n");
	fprint(compiler.output, "	push r10\n");
	fprint(compiler.output, "	push r11\n");
	fprint(compiler.output, "	push r12\n");
	fprint(compiler.output, "	push r13\n");
	fprint(compiler.output, "	push r14\n");
	fprint(compiler.output, "	push r15\n");
}

func writeCall(Compiler compiler, str name, int id, int numParameters, int numCalls) -> int {
	var regId = getRegisterId(compiler);

	fprint(compiler.output, "	call addr_func_");
	fprint(compiler.output, name);
	fprint(compiler.output, "_");
	fprinti(compiler.output, id);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[regId].name);
	fprint(compiler.output, ", rax ;; return value\n");

	compiler.currentStackSize = compiler.currentStackSize - numParameters;

	return regId;
}

func writeReturnEmpty(Compiler compiler, int numVars, int numParameters) {
	fprint(compiler.output, "	;; -- return --\n");

	fprint(compiler.output, "	;; -- pop local variables --\n");
	fprint(compiler.output, "	add rsp, ");
	fprinti(compiler.output, 8 * numVars);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	;; -- restore outside register values --\n");
	fprint(compiler.output, "	pop r15\n");
	fprint(compiler.output, "	pop r14\n");
	fprint(compiler.output, "	pop r13\n");
	fprint(compiler.output, "	pop r12\n");
	fprint(compiler.output, "	pop r11\n");
	fprint(compiler.output, "	pop r10\n");
	fprint(compiler.output, "	pop r9\n");
	fprint(compiler.output, "	pop r8\n");

	fprint(compiler.output, "	;; -- restore stackframe --\n");
	fprint(compiler.output, "	pop rax\n");
	fprint(compiler.output, "	mov [basestack + 8 * ");
	fprinti(compiler.output, compiler.functionDepth);
	fprint(compiler.output, "], rax\n");

	fprint(compiler.output, "	pop rbx ;; return address\n");

	fprint(compiler.output, "	;; -- pop parameters --\n");
	fprint(compiler.output, "	add rsp, ");
	fprinti(compiler.output, 8 * numParameters);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	;; -- return empty --\n");
	fprint(compiler.output, "	mov rax, 0\n");

	fprint(compiler.output, "	push rbx\n");
	
	fprint(compiler.output, "	ret\n");
}

func writeReturnValue(Compiler compiler, int numVars, int numParameters, int regId) {
	var register = compiler.registers[regId];

	fprint(compiler.output, "	;; -- return --\n");

	fprint(compiler.output, "	;; -- return value --\n");
	fprint(compiler.output, "	mov rax, ");
	fprint(compiler.output, register.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	;; -- pop local variables --\n");
	fprint(compiler.output, "	add rsp, ");
	fprinti(compiler.output, 8 * numVars);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	;; -- restore outside register values --\n");
	fprint(compiler.output, "	pop r15\n");
	fprint(compiler.output, "	pop r14\n");
	fprint(compiler.output, "	pop r13\n");
	fprint(compiler.output, "	pop r12\n");
	fprint(compiler.output, "	pop r11\n");
	fprint(compiler.output, "	pop r10\n");
	fprint(compiler.output, "	pop r9\n");
	fprint(compiler.output, "	pop r8\n");

	fprint(compiler.output, "	;; -- restore stackframe --\n");
	fprint(compiler.output, "	pop rbx\n");
	fprint(compiler.output, "	mov [basestack + 8 * ");
	fprinti(compiler.output, compiler.functionDepth);
	fprint(compiler.output, "], rbx\n");

	fprint(compiler.output, "	pop rbx ;; return address\n");

	fprint(compiler.output, "	;; -- pop parameters --\n");
	fprint(compiler.output, "	add rsp, ");
	fprinti(compiler.output, 8 * numParameters);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	push rbx\n");

	fprint(compiler.output, "	ret\n");

	register.free = (bool)1;
}

func writeBitAnd(Compiler compiler, int id1, int id2) -> int {
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	and ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, " ;; bit and\n");
	reg2.free = (bool)1;

	return id1;
}

func writeBitOr(Compiler compiler, int id1, int id2) -> int {
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	or ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, " ;; bit or\n");
	reg2.free = (bool)1;

	return id1;
}

func writeBitNot(Compiler compiler, int regId) -> int {
	fprint(compiler.output, "	not ");
	fprint(compiler.output, compiler.registers[regId].name);
	fprint(compiler.output, " ;; not\n");

	return regId;
}

func writeShiftLeft(Compiler compiler, int id1, int id2) -> int {
	var reg1 = compiler.registers[id1];
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	mov rcx, ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");
	fprint(compiler.output, "	shl ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", cl ;; shl\n");

	reg2.free = (bool)1;
	return id1;
}

func writeShiftRight(Compiler compiler, int id1, int id2) -> int {
	var reg1 = compiler.registers[id1];
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	mov rcx, ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");
	fprint(compiler.output, "	shr ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", cl ;; shr\n");

	reg2.free = (bool)1;
	return id1;
}

func writeLess(Compiler compiler, int id1, int id2) -> int {
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	mov rcx, 0\n");
	fprint(compiler.output, "	mov rdx, 1\n");

	fprint(compiler.output, "	cmp ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	cmovl rcx, rdx\n");
	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", rcx ;; less\n");

	reg2.free = (bool)1;
	return id1;
}

func writeLessEqual(Compiler compiler, int id1, int id2) -> int {
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	mov rcx, 0\n");
	fprint(compiler.output, "	mov rdx, 1\n");

	fprint(compiler.output, "	cmp ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	cmovle rcx, rdx\n");
	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", rcx ;; less equal\n");

	reg2.free = (bool)1;
	return id1;
}

func writeGreater(Compiler compiler, int id1, int id2) -> int {
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	mov rcx, 0\n");
	fprint(compiler.output, "	mov rdx, 1\n");

	fprint(compiler.output, "	cmp ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	cmovg rcx, rdx\n");
	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", rcx ;; greater\n");

	reg2.free = (bool)1;
	return id1;
}

func writeGreaterEqual(Compiler compiler, int id1, int id2) -> int {
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	mov rcx, 0\n");
	fprint(compiler.output, "	mov rdx, 1\n");

	fprint(compiler.output, "	cmp ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	cmovge rcx, rdx\n");
	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", rcx ;; greater equal\n");

	reg2.free = (bool)1;
	return id1;
}

func writeEqual(Compiler compiler, int id1, int id2) -> int {
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	mov rcx, 0\n");
	fprint(compiler.output, "	mov rdx, 1\n");

	fprint(compiler.output, "	cmp ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	cmove rcx, rdx\n");
	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", rcx ;; equal\n");

	reg2.free = (bool)1;
	return id1;
}

func writeNotEqual(Compiler compiler, int id1, int id2) -> int {
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	mov rcx, 0\n");
	fprint(compiler.output, "	mov rdx, 1\n");

	fprint(compiler.output, "	cmp ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	cmovne rcx, rdx\n");
	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[id1].name);
	fprint(compiler.output, ", rcx ;; not equal\n");

	reg2.free = (bool)1;
	return id1;
}

func writeCondition(Compiler compiler, int regId) {
	fprint(compiler.output, "	cmp ");
	fprint(compiler.output, compiler.registers[regId].name);
	fprint(compiler.output, ", 1 ;; condition\n");

	compiler.registers[regId].free = (bool)1;
}

func writeJump(Compiler compiler, str address, int id) {
	fprint(compiler.output, "	;; -- jump --\n");
	fprint(compiler.output, "	jmp "); 
	fprint(compiler.output, address);
	fprinti(compiler.output, id);
	fprint(compiler.output, "\n\n");
}

func writeJumpEqual(Compiler compiler, str address, int id) {
	fprint(compiler.output, "	;; -- jump --\n");
	fprint(compiler.output, "	je ");
	fprint(compiler.output, address);
	fprinti(compiler.output, id);
	fprint(compiler.output, "\n\n");
}

func writeJumpNotEqual(Compiler compiler, str address, int id) {
	fprint(compiler.output, "	;; -- jump if not equal --\n");
	fprint(compiler.output, "	jne ");
	fprint(compiler.output, address);
	fprinti(compiler.output, id);
	fprint(compiler.output, "\n\n");
}

func writeNumber(Compiler compiler, str value) -> int {
	var regId = getRegisterId(compiler);

	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[regId].name);
	fprint(compiler.output, ", ");

	fprint(compiler.output, value);
	fprint(compiler.output, " ;; number\n");

	return regId;
}

func writeNumberInRegister(Compiler compiler, str value, int regId) -> int {
	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[regId].name);
	fprint(compiler.output, ", ");

	fprint(compiler.output, value);
	fprint(compiler.output, " ;; number\n");

	return regId;
}

func writeCharacter(Compiler compiler, str value) -> int {
	var regId = getRegisterId(compiler);

	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[regId].name);
	fprint(compiler.output, ", ");

	printEscapedCharacter(compiler, value);
	fprint(compiler.output, ";; char\n");

	return regId;
}

func writeString(Compiler compiler, int id) -> int {
	var regId = getRegisterId(compiler);

	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[regId].name);
	fprint(compiler.output, ", string_");
	fprinti(compiler.output, id);
	fprint(compiler.output, ";; string\n");

	return regId;
}

func writeReadIndex(Compiler compiler, int size, int id1, int id2) -> int {
	var reg1 = compiler.registers[id1]; // pointer
	var reg2 = compiler.registers[id2]; // index

	fprint(compiler.output, "	;; -- read at index --\n");
	fprint(compiler.output, "	mov rax, ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mov rbx, ");
	fprinti(compiler.output, size);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mul rbx\n");

	fprint(compiler.output, "	add ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", rax\n");

	fprint(compiler.output, "	mov ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", [");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, "]\n");

	fprint(compiler.output, "	;; create bit mask\n");
	if (size < 8) {
		fprint(compiler.output, "	mov rcx, 1\n");
		fprint(compiler.output, "	shl rcx, ");
		fprinti(compiler.output, 8 * size);
		fprint(compiler.output, ";; size\n");
	} else {
		fprint(compiler.output, "	mov rcx, 0\n");
	}
	fprint(compiler.output, "	sub rcx, 1\n");

	fprint(compiler.output, "	and ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", rcx\n");

	reg2.free = (bool)1;
	return id1;
}

func writeWriteIndex(Compiler compiler, int size, int id1, int id2, int id3) -> int {
	var reg1 = compiler.registers[id1]; // pointer
	var reg2 = compiler.registers[id2]; // index
	var reg3 = compiler.registers[id3]; // value

	fprint(compiler.output, "	;; -- write at index --\n");
	fprint(compiler.output, "	mov rax, ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mov rbx, ");
	fprinti(compiler.output, size);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mul rbx\n");

	fprint(compiler.output, "	add ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", rax\n");

	fprint(compiler.output, "	mov rax, [");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, "]\n");

	fprint(compiler.output, "	;; create bit mask\n");
	if (size < 8) {
		fprint(compiler.output, "	mov rbx, 1\n");
		fprint(compiler.output, "	shl rbx, ");
		fprinti(compiler.output, 8 * size);
		fprint(compiler.output, ";; size\n");
	} else {
		fprint(compiler.output, "	mov rbx, 0\n");
	}
	fprint(compiler.output, "	sub rbx, 1\n");
	fprint(compiler.output, "	and ");
	fprint(compiler.output, reg3.name);
	fprint(compiler.output, ", rbx\n");

	fprint(compiler.output, "	not rbx\n");

	fprint(compiler.output, "	and rax, rbx\n");
	fprint(compiler.output, "	add rax, ");
	fprint(compiler.output, reg3.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mov [");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, "], rax\n");

	reg1.free = (bool)1;
	reg2.free = (bool)1;

	return id3;
}

func writeReadProperty(Compiler compiler, int offset, int size, int regId) -> int {
	var register = compiler.registers[regId];

	fprint(compiler.output, "	;; -- read property --\n");
	fprint(compiler.output, "	add ");
	fprint(compiler.output, register.name);
	fprint(compiler.output, ", ");
	fprinti(compiler.output, offset);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mov ");
	fprint(compiler.output, register.name);
	fprint(compiler.output, ", [");
	fprint(compiler.output, register.name);
	fprint(compiler.output, "]\n");

	fprint(compiler.output, "	;; create bit mask\n");
	if (size < 8) {
		fprint(compiler.output, "	mov rbx, 1\n");
		fprint(compiler.output, "	shl rbx, ");
		fprinti(compiler.output, 8 * size);
		fprint(compiler.output, ";; size\n");
	} else {
		fprint(compiler.output, "	mov rbx, 0\n");
	}
	fprint(compiler.output, "	sub rbx, 1\n");
	fprint(compiler.output, "	and ");
	fprint(compiler.output, register.name);
	fprint(compiler.output, ", rbx\n");

	return regId;
}

func writeWriteProperty(Compiler compiler, int offset, int size, int id1, int id2) -> int {
	var reg1 = compiler.registers[id1]; // pointer
	var reg2 = compiler.registers[id2]; // value

	fprint(compiler.output, "	;; -- write property --\n");
	fprint(compiler.output, "	add ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", ");
	fprinti(compiler.output, offset);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mov rcx, [");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, "]\n");

	fprint(compiler.output, "	;; create bit mask\n");
	if (size < 8) {
		fprint(compiler.output, "	mov rax, 1\n");
		fprint(compiler.output, "	shl rax, ");
		fprinti(compiler.output, 8 * size);
		fprint(compiler.output, ";; size\n");
	} else {
		fprint(compiler.output, "	mov rax, 0\n");
	}
	fprint(compiler.output, "	sub rax, 1\n");
	fprint(compiler.output, "	and ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, ", rax\n");

	fprint(compiler.output, "	not rax\n");
	fprint(compiler.output, "	and rcx, rax\n");
	fprint(compiler.output, "	add rcx, ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mov [");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, "], rcx\n");

	reg1.free = (bool)1;
	return id2;
}

func writeIdentifier(Compiler compiler, int offset, int currentDepth) -> int {
	var register = getRegisterId(compiler);

	fprint(compiler.output, "	;; -- identifier --\n");
	fprint(compiler.output, "	mov rax, [basestack + 8 * ");
	fprinti(compiler.output, currentDepth);
	fprint(compiler.output, "]\n");
	fprint(compiler.output, "	mov rbx, ");
	fprinti(compiler.output, 8 * offset);
	fprint(compiler.output, "\n");
	fprint(compiler.output, "	sub rax, rbx\n");
	fprint(compiler.output, "	mov ");
	fprint(compiler.output, compiler.registers[register].name);
	fprint(compiler.output, ", [rax]\n");

	return register;
}

func writeAssignment(Compiler compiler, int offset, int currentDepth, int regId) -> int {
	var register = compiler.registers[regId];

	fprint(compiler.output, "	;; -- assignment --\n");
	fprint(compiler.output, "	mov rax, [basestack + 8 * ");
	fprinti(compiler.output, currentDepth);
	fprint(compiler.output, "]\n");
	fprint(compiler.output, "	mov rbx, ");
	fprinti(compiler.output, 8 * offset);
	fprint(compiler.output, "\n");
	fprint(compiler.output, "	sub rax, rbx\n");
	fprint(compiler.output, "	mov [rax], ");
	fprint(compiler.output, register.name);
	fprint(compiler.output, "\n");

	return regId;
}

func writeAdd(Compiler compiler, int id1, int id2) -> int {
	var reg1 = compiler.registers[id1];
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	add ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, " ;; add\n");

	reg2.free = (bool)1;
	return id1;
}

func writeSubtract(Compiler compiler, int id1, int id2) -> int {
	var reg1 = compiler.registers[id1];
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	sub ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, " ;; subtract\n");

	reg2.free = (bool)1;
	return id1;
}

func writeNegative(Compiler compiler, int regId) -> int {
	var register = compiler.registers[regId];

	fprint(compiler.output, "	neg ");
	fprint(compiler.output, register.name);
	fprint(compiler.output, " ;; negative\n");

	return regId;
}

func writeMult(Compiler compiler, int id1, int id2) -> int {
	var reg1 = compiler.registers[id1];
	var reg2 = compiler.registers[id2];

	fprint(compiler.output, "	mov rax, ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "	mul ");
	fprint(compiler.output, reg2.name);
	fprint(compiler.output, "\n");
	reg2.free = (bool)1;

	fprint(compiler.output, "	mov ");
	fprint(compiler.output, reg1.name);
	fprint(compiler.output, ", rax ;; mult\n");

	return id1;
}

func writeFooter(Compiler compiler, StringList strings) {
	fprint(compiler.output, "	mov rax, 60\n");
	fprint(compiler.output, "	xor rdi, rdi\n");
	fprint(compiler.output, "	syscall\n\n");

	fprint(compiler.output, "section .bss\n");
	fprint(compiler.output, "	basestack: resq ");
	fprinti(compiler.output, CALLSTACKSIZE);
	fprint(compiler.output, "\n");

	fprint(compiler.output, "section .data\n");
	var i = 0;
	while (i < strings.size) {
		fprint(compiler.output, "	string_");
		fprinti(compiler.output, i);
		fprint(compiler.output, ": db ");
		var j = 0;
		var string = strings.strings[i];
		var len = strlen(string);
		while (j < len) {
			var chr = (str)((int)string + j);

			var length = printEscapedCharacter(compiler, chr);
			
			j = j + length; 

			fprint(compiler.output, ", ");

			if (length == -1) {
				j = len;
			}
		}

		fprint(compiler.output, "0x00\n");

		i = i + 1;
	}
}
