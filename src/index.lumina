import "../std/collections.lumina"
import "../std/io.lumina"

import "parser.lumina"
import "lexer.lumina"
import "position.lumina"
import "operator.lumina"
import "term.lumina"
import "call.lumina"


type PropertyPart {
	Operator operator;
	Call property;
}

type ListPart {
	Operator left;
	Term index;
	Operator right;
}

type IndexPart {
	PropertyPart propertyPart;
	ListPart indexPart;
}

type Index {
	Region region;

	Call value;
	Array<IndexPart> parts;

	func parse(Index self, Parser parser, Lexer lexer) -> Index {
		self.region = lexer.startRegion();

		self.value = new Call();
		self.value.parse(parser, lexer);

		while (lexer.current.operator.precedence == PREC_index) {
			var part = new IndexPart();

			if (isOperator(lexer.current.operator, ".")) {
				part.propertyPart = new PropertyPart();
				part.propertyPart.operator = lexer.consumeOperator(".");

				part.propertyPart.property = new Call();
				part.propertyPart.property.parse(parser, lexer);
			} else if (isOperator(lexer.current.operator, "[")) {
				part.indexPart = new ListPart();
				part.indexPart.left = lexer.consumeOperator("[");

				if (!isOperator(lexer.current.operator, "]")) {
					part.indexPart.index = new Term();
					part.indexPart.index.parse(parser, lexer);
				}

				part.indexPart.right = lexer.consumeOperator("]");

				if (part.indexPart.right == (Operator)0) {
					parser.error(lexer.here(), " expected ']' after list index\n");
				}
			} else {
				parser.error(lexer.here(), " did not expect operator: '");
				print(lexer.current.operator.name);
				print("', in precedence index\n");
			}

			self.parts.push(part);
		}

		lexer.endRegion(self.region);

		return self;
	}
}
