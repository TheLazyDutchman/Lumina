import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "position.lumina"
import "assignment.lumina"
import "if.lumina"
import "while.lumina"
import "import.lumina"
import "variable.lumina"
import "function.lumina"
import "name.lumina"
import "type.lumina"
import "block.lumina"
import "operator.lumina"
import "definition.lumina"


type Statement {
	Region region;

	Assignment assignment;
	If ifStatement;
	While whileStatement;
	Import importStatement;
	Variable variable;
	FunctionDefinition function;
	TypeObj typeStatement;
	Return returnStatement;
	Block blockStatement;

	func parse(Statement self, Parser parser, Lexer lexer, SyntaxTree tree,
		Array<Definition> definitions,
		Array<Variable> variables,
		Array<TypeObj> types,
		Array<FunctionDefinition> functions,
		Array<Import> imports,
		Block block) -> Statement {

		self.region = lexer.startRegion();

		if (isKeyword(lexer.current.name, KEYWORD_if)) {
			self.ifStatement = new If();
			self.ifStatement.parse(parser, lexer);
		} else if (isKeyword(lexer.current.name, KEYWORD_while)) {
			self.whileStatement = new While();
			self.whileStatement.parse(parser, lexer);
		} else if (isKeyword(lexer.current.name, KEYWORD_import)) {
			self.importStatement = new Import();
			self.importStatement.parse(parser, lexer);
			imports.push(self.importStatement);
		} else if (isKeyword(lexer.current.name, KEYWORD_var)) {
			var depth = 0;
			if (block != (Block)0) {
				depth = block.depth;
			}

			var position = 0;
			if (depth == 0) {
				position = position + getNumVariables(parser.variables) + 1;

				var i = 1;
				while (i < parser.files.size) {
					var tree = parser.files.get(i);
					position = position + getNumVariables(tree.variables);

					i = i + 1;
				}

				position = position + getNumVariables(tree.variables);
			}

			if (block != (Block)0) {
				position = position + getNumVariables(block.variables);

				var outerBlock = block;
				while (outerBlock.outer != (Block)0 && outerBlock.outer.depth == depth) {
					outerBlock = outerBlock.outer;
					position = position + getNumVariables(outerBlock.variables);
				}

				if (outerBlock.function != (FunctionDefinition)0) {
					position = position + outerBlock.function.numGenerics;
					position = position + outerBlock.function.parameters.size + 1;
				}
			}

			var variable = new VariableDefinition();
			variable.parse(parser, lexer);
			self.variable = createVariableFromDefinition(variable, depth, position);
			variables.push(self.variable);
			definitions.push(createDefinitionFromVariable(self.variable));
		} else if (isKeyword(lexer.current.name, KEYWORD_const)) {
			var constant = new VariableDefinition();
			constant.parse(parser, lexer);
			self.variable = createConstantFromDefinition(constant);

			variables.push(self.variable);
			definitions.push(createDefinitionFromVariable(self.variable));
		} else if (isKeyword(lexer.current.name, KEYWORD_func)) {
			self.function = new FunctionDefinition();
			self.function.parse(parser, lexer);
			functions.push(self.function);
		} else if (isKeyword(lexer.current.name, KEYWORD_type)) {
			var typeObj = new TypeDefinition();
			typeObj.parse(parser, lexer);
			self.typeStatement = createTypeFromDefinition(typeObj);
			types.push(self.typeStatement);
		} else if (isKeyword(lexer.current.name, KEYWORD_return)) {
			self.returnStatement = new Return();
			self.returnStatement.parse(parser, lexer);
		} else if (isOperator(lexer.current.operator, "{")) {
			self.blockStatement = new Block();
			self.blockStatement.parse(parser, lexer);
		} else {
			self.assignment = new Assignment();
			self.assignment.parse(parser, lexer);
		}

		lexer.endRegion(self.region);
		return self;
	}
}
