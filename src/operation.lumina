import "../std/collections.lumina"

import "position.lumina"
import "operator.lumina"
import "value.lumina"
import "type.lumina"
import "name.lumina"
import "whitespace.lumina"


type SizeOf {
	Region region;

	Name keyword;
	Operator lparen;
	Operation typeObj;
	Operator rparen;
}

type NewOperation {
	Region region;
	
	Name keyword;
	Operation typeObj;

	Operator left;
	Operation num;
	Operator right;
}

type Operation {
	Region region;
	Operation left;
	Operator operator;
	Operation right;
	Operator end;
	Value value;
	SizeOf sizeOf;
	Operation castType;
	NewOperation newOperation;

	TypeObj operationType;
}

func createSizeOf(Name keyword, Operator lparen, Operation typeObj, Operator rparen) -> SizeOf {
	var sizeOf = new SizeOf();

	sizeOf.region = createRegion(keyword.region.start, rparen.position);

	sizeOf.keyword = keyword;
	sizeOf.lparen = lparen;
	sizeOf.typeObj = typeObj;
	sizeOf.rparen = rparen;

	return sizeOf;
}

func createNewOperation(Name keyword, Operation typeObj, Operator left, Operation num, Operator right) -> NewOperation {
	var newOperation = new NewOperation();

	newOperation.region = createRegion(keyword.region.start, right.position);

	newOperation.keyword = keyword;
	newOperation.typeObj = typeObj;

	newOperation.left = left;
	newOperation.num = num;
	newOperation.right = right;

	return newOperation;
}

func createOperation(Operation left, Operator operator, Operation right, Operator end) -> Operation {
	var operation = new Operation();

	if (end == (Operator)0) {
		operation.region = createRegion(left.region.start, right.region.end);
	} else {
		operation.region = createRegion(left.region.start, end.position);
	}

	operation.left = left;
	operation.operator = operator;
	operation.right = right;
	operation.end = end;

	return operation;
}

func createUnaryOperation(Operator operator, Operation right, Operator end) -> Operation {
	var operation = new Operation();

	if (end == (Operator)0) {
		operation.region = createRegion(operator.position, right.region.end);
	} else {
		operation.region = createRegion(operator.position, end.position);
	}

	operation.operator = operator;
	operation.right = right;
	operation.end = end;

	return operation;
}

func createOperationFromValue(Value value) -> Operation {
	var operation = new Operation();

	operation.region = value.region;
	operation.value = value;

	return operation;
}

func createTypeCast(Operator lparen, Operation castType, Operator rparen, Operation castOperation) -> Operation {
	var operation = new Operation();

	operation.region = createRegion(lparen.position, castOperation.region.end);

	operation.operator = lparen;
	operation.right = castOperation;
	operation.end = rparen;
	operation.castType = castType;

	return operation;
}

func createOperationFromSizeOf(SizeOf sizeOf) -> Operation {
	var operation = new Operation();

	operation.region = sizeOf.region;
	operation.sizeOf = sizeOf;

	return operation;
}

func createOperationFromNew(NewOperation newOperation) -> Operation {
	var operation = new Operation();

	operation.region = newOperation.region;
	operation.newOperation = newOperation;

	return operation;
}

func isVariable(Operation operation) -> bool {
	if (isName(operation.value)) {
		return true;
	}

	if (isOperator(operation.operator, ".")) {
		return isVariable(operation.left) && isVariable(operation.right);
	}

	if (isOperator(operation.operator, "[")) {
		return isVariable(operation.left);
	}

	if (isOperator(operation.operator, "(")) {
		if (operation.left == (Operation)0) {
			return isVariable(operation.right);
		}

		return isVariable(operation.left);
	}

	if (isOperator(operation.operator, "<") &&
		isOperator(operation.end, ">")) {
		return isVariable(operation.left);
	}

	return false;
}

func getArguments(Array<Operation> list, Operation operation) {
	if (isOperator(operation.operator, ",")) {
		getArguments(list, operation.left);
		list.push(operation.right);
		return;
	}

	list.push(operation);
}
