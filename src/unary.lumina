import "parser.lumina"
import "lexer.lumina"
import "position.lumina"
import "name.lumina"
import "value.lumina"
import "operator.lumina"
import "term.lumina"
import "identifier.lumina"
import "block.lumina"


type New {
	Region region;

	Name keyword;
	Identifier objectType;
	Operator lparen;
	Term value;
	Operator rparen;

	func parseNew(New self, Parser parser, Lexer lexer, Block block) -> New {
		self.region = lexer.startRegion();

		self.keyword = lexer.consumeKeyword(KEYWORD_new);

		self.objectType = new Identifier();
		self.objectType.parseIdentifier(parser, lexer, block);
		
		self.lparen = lexer.consumeOperator("(");
		if (self.lparen == (Operator)0) {
			parser.error(lexer.here(), " expected '(' in 'new' operation\n");
		}

		if (!isOperator(lexer.current.operator, ")")) {
			self.value = new Term();
			self.value.parseTerm(parser, lexer, block);
		}

		self.rparen = lexer.consumeOperator(")");
		if (self.rparen == (Operator)0) {
			parser.error(lexer.here(), " expected ')' after 'new' operation\n");
		}

		lexer.endRegion(self.region);

		return self;
	}

	func bindNew(New self, Parser parser) {
		self.objectType.bindIdentifier(parser);

		if (self.value != (Term)0) {
			self.value.bindTerm(parser);
		}
	}
}

type Sizeof {
	Region region;

	Name keyword;
	Operator lparen;
	Identifier value;
	Operator rparen;

	func parseSizeof(Sizeof self, Parser parser, Lexer lexer, Block block) -> Sizeof {
		self.region = lexer.startRegion();

		self.keyword = lexer.consumeKeyword(KEYWORD_sizeof);

		self.lparen = lexer.consumeOperator("(");
		if (self.lparen == (Operator)0) {
			parser.error(lexer.here(), " expected '(' in 'sizeof' operation\n");
		}

		self.value = new Identifier();
		self.value.parseIdentifier(parser, lexer, block);

		self.rparen = lexer.consumeOperator(")");
		if (self.rparen == (Operator)0) {
			parser.error(lexer.here(), " expected ')' after 'sizeof' operation\n");
		}

		lexer.endRegion(self.region);
		return self;
	}

	func bindSizeof(Sizeof self, Parser parser) {
		self.value.bindIdentifier(parser);
	}
}

type TypeCast {
	Operator lparen;
	Identifier value;
	Operator rparen;

	func parseTypeCast(TypeCast self, Parser parser, Lexer lexer, Block block) -> bool {
		self.lparen = lexer.consumeOperator("(");

		self.value = new Identifier();
		self.value.parseIdentifier(parser, lexer, block);

		self.rparen = lexer.consumeOperator(")");
		if (self.rparen == (Operator)0) {
			return false;
		}

		if (lexer.current.operator != (Operator)0 &&
			!isOperator(lexer.current.operator, "(")) {
			return false;
		}

		return true;
	}

	func bindTypeCast(TypeCast self, Parser parser) {
		self.value.bindIdentifier(parser);
	}
}

type Unary {
	Region region;

	TypeCast typeCast;
	New newOperation;
	Sizeof sizeOperation;

	Operator operator;
	Unary unary;
	Value value;

	func parseUnary(Unary self, Parser parser, Lexer lexer, Block block) -> Unary {
		if (isKeyword(lexer.current.name, KEYWORD_new)) {
			self.newOperation = new New();
			self.newOperation.parseNew(parser, lexer, block);
			self.region = self.newOperation.region;
			return self;
		}

		if (isKeyword(lexer.current.name, KEYWORD_sizeof)) {
			self.sizeOperation = new Sizeof();
			self.sizeOperation.parseSizeof(parser, lexer, block);
			self.region = self.sizeOperation.region;
			return self;
		}

		self.region = lexer.startRegion();
		
		if (isOperator(lexer.current.operator, "-")) {
			self.operator = lexer.consumeOperator("-");
		} else if (isOperator(lexer.current.operator, "!")) {
			self.operator = lexer.consumeOperator("!");
		} else if (isOperator(lexer.current.operator, "~")) {
			self.operator = lexer.consumeOperator("~");
		} else if (isOperator(lexer.current.operator, "(")) {
			self.typeCast = new TypeCast();
			if (!self.typeCast.parseTypeCast(parser, lexer, block)) {
				lexer.returnTo(self.region.start);
				self.typeCast = (TypeCast)0;
			}
		}

		if (self.operator == (Operator)0 || self.typeCast == (TypeCast)0) {
			self.value = new Value();
			self.value.parseValue(parser, lexer, block);
		} else {
			self.unary = new Unary();
			self.unary.parseUnary(parser, lexer, block);
		}

		lexer.endRegion(self.region);

		return self;
	}

	func bindUnary(Unary self, Parser parser) {
		if (self.typeCast != (TypeCast)0) {
			self.typeCast.bindTypeCast(parser);
		}

		if (self.newOperation != (New)0) {
			self.newOperation.bindNew(parser);
		}

		if (self.sizeOperation != (Sizeof)0) {
			self.sizeOperation.bindSizeof(parser);
		}

		if (self.unary != (Unary)0) {
			self.unary.bindUnary(parser);
		}

		if (self.value != (Value)0) {
			self.value.bindValue(parser);
		}
	}
}
