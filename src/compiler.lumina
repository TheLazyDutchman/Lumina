import "../std/collections.lumina"
import "../std/string.lumina"
import "../std/io.lumina"

import "type.lumina"
import "immediate.lumina"


const CALLSTACKSIZE = 2048;
const DATASTACKSIZE = 40960;

type Register {
	str name;
	bool used;

	func use(Register self) {
		self.used = true;
	}

	func free(Register self) {
		self.used = false;
	}
}

type Compiler {
	Array<Register> registers;
	int target;

	func getRegister(Compiler self) -> Register {
		var i = 0;
		while (i < self.registers.size) {
			if (!self.registers.get(i).used) {
				self.registers.get(i).used = true;
				return self.registers.get(i);
			}
			i = i + 1;
		}
		print("all registers are in use\n");
		return (Register)0;
	}

	func findRegister(Compiler self, str name) -> Register {
		var i = 0;
		while (i < self.registers.size) {
			if (streq(self.registers.get(i).name, name)) {
				return self.registers.get(i);
			}
			i = i + 1;
		}
		print("can not find register with name: ");
		print(name);
		print("\n");
		return (Register)0;
	}

	func writeOutput(Compiler self, str value) {
		fprint(self.target, value);
	}

	func writeInt(Compiler self, int value) {
		fprinti(self.target, value);
	}

	func writeChar(Compiler self, char chr) {
		var lower = (int)chr & 15; // get lower 4 bits
		var higher = (int)chr >> 4; // get higher 4 bits

		var value = new str(5);
		value[0] = '0';
		value[1] = 'x';

		if (0 <= higher && higher <= 9) {
			value[2] = '0' + higher;
		} else {
			value[3] = 'A' + higher - 10;
		}

		if (0 <= lower && lower <= 9) {
			value[3] = '0' + lower;
		} else {
			value[3] = 'A' + lower - 10;
		}

		value[4] = '\0';
		self.writeOutput(value);
	}

	func writeStringLiteral(Compiler self, str value, int id) {
		self.writeOutput("	str_");
		self.writeInt(id);
		self.writeOutput(": db ");

		var i = 0;
		var size = strlen(value);
		while (i < size) {
			var character = value[i];
			if (character == '\\') {
				character = unescapeChar(value[i + 1]);
			}

			self.writeChar(character);
			self.writeOutput(", ");
			i = i + 1;
		}

		self.writeChar('\0');
		self.writeOutput("\n");
	}

	func swapStacks(Compiler self) {
		self.writeOutput("	xchg rsp, [datarsp]\n");
	}

	func writeRegister(Compiler self, Register register) {
		self.writeOutput(register.name);
	}

	func writeUnaryOperation(Compiler self, str value, Register register) {
		self.writeOutput("	");
		self.writeOutput(value);
		self.writeOutput(" ");
		self.writeRegister(register);
		self.writeOutput("\n");
	}

	func writePush(Compiler self, Register register) {
		self.swapStacks();
		self.writeUnaryOperation("push", register);
		self.swapStacks();
		register.free();
	}

	func writeMov(Compiler self, Register register) {
		self.writeOutput("	mov ");
		self.writeRegister(register);
		self.writeOutput(", ");
	}

	func writeMovInt(Compiler self, Register register, int value) {
		self.writeMov(register);
		self.writeInt(value);
		self.writeOutput(" ;; number\n");
	}

	func writeMovChar(Compiler self, Register register, char value) {
		self.writeMov(register);
		self.writeChar(value);
		self.writeOutput(" ;; character\n");
	}

	func writeMovStr(Compiler self, Register register, StringLiteral value) {
		self.writeMov(register);
		self.writeOutput("str_");
		self.writeInt(value.id);
		self.writeOutput(" ;; string literal\n");
	}

	func writeFindBlockBuiltin(Compiler self) {
		self.writeOutput("__find_block__:\n");

		self.writeOutput("	;; finds the first memory block after a given pointer\n");
		self.writeOutput("	;; or null if there are none\n\n");
		self.swapStacks();
		self.writeOutput("	pop rbx ;; pointer\n");
		self.swapStacks();

		self.writeOutput("	mov rcx, [lastblock]\n");
		self.writeOutput("	mov rax, 0\n");

		self.writeOutput(".loop_condition:\n");
		self.writeOutput("	cmp rcx, rbx\n");
		self.writeOutput("	jl .loop_end\n");

		self.writeOutput("	mov rax, rcx\n");
		self.writeOutput("	mov rcx, [rcx] ;; last block\n");
		self.writeOutput("	jmp .loop_condition\n");
		self.writeOutput(".loop_end:\n");

		self.writeOutput("	ret\n\n");
	}

	func writeGetBlockBuiltin(Compiler self) {
		self.writeOutput("__get_block__:\n");
		self.swapStacks();
		self.writeOutput("	pop rbx ;; size\n");
		self.writeOutput("	add rbx, 24 ;; block header\n");
		self.swapStacks();

		self.writeOutput("	mov rax, [lastblock]\n");
		self.writeOutput("	mov r8, 0\n");
		self.writeOutput("	mov rcx, 1\n");

		self.writeOutput(".loop_condition:\n");
		self.writeOutput("	cmp rcx, 0\n");
		self.writeOutput("	je .loop_end\n");

		self.writeOutput("	cmp [rax + 16], rbx\n");
		self.writeOutput("	cmovl rax, [rax]\n");
		self.writeOutput("	cmovge rcx, r8\n");

		self.writeOutput("	cmp rax, 0\n");
		self.writeOutput("	cmove rcx, r8\n");

		self.writeOutput("	jmp .loop_condition\n");

		self.writeOutput(".loop_end:\n");

		self.writeOutput("	ret\n\n");
	}

	func writeCreateBlockBuiltin(Compiler self) {
		self.writeOutput("__create_block__:\n");
		self.swapStacks();
		self.writeOutput("	pop rbx ;; size\n");
		self.writeOutput("	pop rcx ;; pointer\n");

		self.writeOutput("	;; store values\n");
		self.writeOutput("	push rbx\n");
		self.writeOutput("	push rcx\n");
		self.writeOutput("	;; push arguments\n");
		self.writeOutput("	push rcx\n");
		self.swapStacks();

		self.writeOutput("	call __find_block__\n");

		self.swapStacks();
		self.writeOutput("	pop rcx ;; pointer\n");
		self.writeOutput("	pop rbx ;; size\n");
		self.swapStacks();

		self.writeOutput("	;; set block before this one\n");
		self.writeOutput("	cmp rax, 0\n");
		self.writeOutput("	cmove r8, [lastblock]\n");
		self.writeOutput("	cmovg r8, [rax]\n");

		self.writeOutput("	mov r9, r8\n");
		self.writeOutput("	add r9, [r8 + 16] ;; size\n");
		self.writeOutput("	cmp r9, rcx\n");
		self.writeOutput("	jne .joined_before\n");

		self.writeOutput("	add [r8 + 16], rbx\n");
		self.writeOutput("	mov rax, r8\n");
		self.writeOutput("	ret\n");
		self.writeOutput(".joined_before:\n");

		self.writeOutput("	mov r9, rcx\n");
		self.writeOutput("	add r9, rbx\n");
		self.writeOutput("	cmp r9, rax\n");
		self.writeOutput("	jne .joined_after\n");

		self.writeOutput("	add rbx, [rax + 16]\n");
		self.writeOutput("	mov [rcx + 16], rbx\n");
		self.writeOutput("	mov rax, [rax + 8]\n");
		self.writeOutput(".joined_after:\n");

		self.writeOutput("	mov [rcx], r8\n");
		self.writeOutput("	mov [rcx + 8], rax\n");

		self.writeOutput("	mov r9, r8\n");
		self.writeOutput("	cmp r8, 0\n");
		self.writeOutput("	cmovg r9, [heapstart]\n");
		self.writeOutput("	cmovg r8, rcx\n");
		self.writeOutput("	add r9, 8\n");
		self.writeOutput("	mov [r9], r8\n");

		self.writeOutput("	cmp rax, 0\n");
		self.writeOutput("	cmove rax, [lastblock]\n");
		self.writeOutput("	mov [rax], rcx\n");

		self.writeOutput("	mov rax, rcx\n");
		self.writeOutput("	ret\n\n");
	}

	func writeExpandHeapBuiltin(Compiler self) {
		self.writeOutput("__expand_heap__:\n");
		self.swapStacks();
		self.writeOutput("	pop rbx ;; size\n");
		self.swapStacks();

		self.writeOutput("	mov r8, 4096\n");
		self.writeOutput(".loop_condition:\n");
		self.writeOutput("	cmp r8, rbx\n");
		self.writeOutput("	jg .loop_end\n");

		self.writeOutput("	add r8, 4096\n");
		self.writeOutput("	jmp .loop_condition\n");
		self.writeOutput(".loop_end:\n");

		self.writeOutput("	mov rbx, [heapend]\n");

		self.writeOutput("	mov rax, 12 ;; sysbrk\n");
		self.writeOutput("	mov rdi, rbx\n");
		self.writeOutput("	add rdi, r8\n");
		self.writeOutput("	mov [heapend], rdi\n");
		self.writeOutput("	syscall\n");

		self.writeOutput("	sub rbx, 8\n");
		self.writeOutput("	mov r9, [lastblock]\n");
		self.writeOutput("	mov [rbx], r9\n");
		self.writeOutput("	mov [rbx + 16], r8\n");
		self.writeOutput("	mov [lastblock], rbx\n");

		self.writeOutput("	ret\n\n");
	}

	func writeAllocateBuiltin(Compiler self) {
		self.writeOutput("__allocate__:\n");
		self.swapStacks();
		self.writeOutput("	pop rbx ;; size\n");
		self.writeOutput("	push rbx\n");
		self.writeOutput("	push rbx\n");
		self.swapStacks();

		self.writeOutput("	call __get_block__\n");

		self.writeOutput("	cmp rax, 0\n");
		self.writeOutput("	jg .setup\n");

		self.swapStacks();
		self.writeOutput("	push rbx\n");
		self.writeOutput("	push rbx\n");
		self.swapStacks();

		self.writeOutput("	call __expand_heap__\n");
		self.writeOutput("	call __get_block__\n");

		self.writeOutput(".setup:\n");

		self.swapStacks();
		self.writeOutput("	pop rbx\n");
		self.swapStacks();

		self.writeOutput("	sub [rax + 16], rbx\n");
		self.writeOutput("	add rax, [rax + 16] ;; block size\n");
		self.writeOutput("	mov r8, rax\n");

		self.writeOutput("	mov rcx, rax\n");

		self.writeOutput(".init_condition:\n");
		self.writeOutput("	cmp rcx, r8\n");
		self.writeOutput("	jg .return\n");
		self.writeOutput("	mov qword [rcx], 0 ;; zero-initialize allocated memory\n");
		self.writeOutput("	add rcx, 8\n");
		self.writeOutput("	jmp .init_condition\n");

		self.writeOutput(".return:\n");

		self.writeOutput("	sub rax, [heapstart]\n");

		self.writeOutput("	ret\n\n");
	}

	func writeNewBuiltin(Compiler self) {
		self.writeOutput("__new__:\n");
		self.swapStacks();
		self.writeOutput("	pop rax ;; type\n");
		self.swapStacks();

		self.writeOutput("	mov rbx, [rax + 16] ;; size\n");
		self.writeOutput("	add rbx, 16 ;; header size\n");

		self.swapStacks();
		self.writeOutput("	push rax ;; type\n");

		self.writeOutput("	push rbx\n");
		self.swapStacks();

		self.writeOutput("	call __allocate__\n");

		self.swapStacks();
		self.writeOutput("	pop rbx ;; type\n");
		self.swapStacks();

		self.writeOutput("	mov rcx, rax\n");
		self.writeOutput("	add rcx, [heapstart]\n");
		self.writeOutput("	add rax, 16\n");

		self.writeOutput("	mov [rcx + 8], rbx\n");

		self.writeOutput("	ret\n\n");
	}

	func writeNewListBuiltin(Compiler self) {
		self.writeOutput("__new_list__:\n");
		self.swapStacks();
		self.writeOutput("	pop rax ;; size\n");
		self.writeOutput("	pop rbx ;; type\n");
		self.writeOutput("	push rax\n");
		self.swapStacks();

		self.writeOutput("	mov rcx, [rbx + 16] ;; item size\n");
		self.writeOutput("	mul rcx\n");

		self.swapStacks();
		self.writeOutput("	push rbx ;; type\n");
		self.swapStacks();

		self.writeOutput("	mov rbx, rax\n");
		self.writeOutput("	add rbx, 24 ;; header size\n");

		self.swapStacks();
		self.writeOutput("	push rbx ;; size\n");
		self.swapStacks();

		self.writeOutput("	call __allocate__\n");

		self.swapStacks();
		self.writeOutput("	pop rbx ;; type\n");
		self.writeOutput("	pop rcx ;; size\n");
		self.swapStacks();

		self.writeOutput("	mov r8, rax\n");
		self.writeOutput("	add r8, [heapstart]\n");
		self.writeOutput("	add rax, 24\n");

		self.writeOutput("	mov [r8 + 8], rcx\n");
		self.writeOutput("	mov [r8 + 16], rbx\n");

		self.writeOutput("	ret\n\n");
	}

	func writeSyscallBuiltin(Compiler self) {
		self.writeOutput("	;; -- syscall builtin --\n");
		self.writeOutput("func_syscall0:\n");
		self.swapStacks();
		self.writeOutput("	pop r9\n");
		self.writeOutput("	pop r8\n");
		self.writeOutput("	pop r10\n");
		self.writeOutput("	pop rdx\n");
		self.writeOutput("	pop rsi\n");
		self.writeOutput("	pop rdi\n");
		self.writeOutput("	pop rax\n");
		self.swapStacks();
		self.writeOutput("	syscall\n");
		self.writeOutput("	ret\n\n");
	}

	func writeHeader(Compiler self) {
		self.writeOutput("section .text\n");
		self.writeOutput("global _start\n");

		self.writeFindBlockBuiltin();
		self.writeGetBlockBuiltin();
		self.writeCreateBlockBuiltin();
		self.writeExpandHeapBuiltin();
		self.writeAllocateBuiltin();
		self.writeNewBuiltin();
		self.writeNewListBuiltin();
		self.writeSyscallBuiltin();
	}

	func writeStart(Compiler self) {
		self.writeOutput("_start:\n");

		self.writeOutput("	mov rax, 12 ;; sysbrk\n");
		self.writeOutput("	mov rdi, 0 ;; find start of heap\n");
		self.writeOutput("	syscall\n");
		self.writeOutput("	mov [heapstart], rax\n");

		self.writeOutput("	mov rax, 12 ;; sysbrk\n");
		self.writeOutput("	mov rdi, [heapstart]\n");
		self.writeOutput("	add rdi, 8192\n");
		self.writeOutput("	mov [heapend], rdi\n");

		self.writeOutput("	syscall ;; allocate 1 page of null space and a first memory block of 1 pagesize\n");

		self.writeOutput("	mov rax, [heapstart]\n");
		self.writeOutput("	add rax, 4096\n");
		self.writeOutput("	mov qword [rax], 0\n");
		self.writeOutput("	mov qword [rax + 8], 0\n");
		self.writeOutput("	mov qword [rax + 16], 4096 - 8\n");
		self.writeOutput("	mov [lastblock], rax\n");

		self.writeOutput("	lea rax, [datastack + ");
		self.writeInt(DATASTACKSIZE);
		self.writeOutput("]\n");

		self.writeOutput("	mov [basestack], rax\n");
		self.writeOutput("	xchg rsp, rax\n");

		self.writeOutput("	push qword [heapstart]\n");

		self.writeOutput("	mov rbx, [rax]\n");
		self.writeOutput("	push rbx;; argc\n");

		self.writeOutput("	mov rbx, rax\n");
		self.writeOutput("	add rbx, 8\n");
		self.writeOutput("	mov rcx, rbx\n");
		self.writeOutput("	sub rcx, [heapstart]\n");
		self.writeOutput("	push rcx;; argv\n");

		self.writeOutput(".argv_condition:\n");
		self.writeOutput("	mov rcx, [rbx]\n");
		self.writeOutput("	cmp rcx, 0\n");
		self.writeOutput("	je .argv_end\n");
		self.writeOutput("	sub rcx, [heapstart]\n");
		self.writeOutput("	mov [rbx], rcx\n");
		self.writeOutput("	add rbx, 8\n");
		self.writeOutput("	jmp .argv_condition\n");
		self.writeOutput(".argv_end:\n");

		self.writeOutput("	add rbx, 8\n");
		self.writeOutput("	mov rcx, rbx\n");
		self.writeOutput("	sub rcx, [heapstart]\n");
		self.writeOutput("	push rcx;; envp\n");

		self.writeOutput(".envp_condition:\n");
		self.writeOutput("	mov rcx, [rbx]\n");
		self.writeOutput("	cmp rcx, 0\n");
		self.writeOutput("	je .envp_end\n");
		self.writeOutput("	sub rcx, [heapstart]\n");
		self.writeOutput("	mov [rbx], rcx\n");
		self.writeOutput("	add rbx, 8\n");
		self.writeOutput("	jmp .envp_condition\n");
		self.writeOutput(".envp_end:\n");

		self.writeOutput("	xchg rsp, rax\n");
		self.writeOutput("	mov [datarsp], rax\n\n");
	}

	func writeFooter(Compiler self, Array<str> strings, Array<TypeObj> types) {
		self.writeOutput("	mov rax, 60\n");
		self.writeOutput("	xor rdi, rdi\n");
		self.writeOutput("	syscall\n\n");

		self.writeOutput("section .bss\n");

		self.writeOutput("	heapstart: resq 1\n");
		self.writeOutput("	heapend: resq 1\n");
		self.writeOutput("	lastblock: resq 1\n");

		self.writeOutput("	basestack: resq ");
		self.writeInt(CALLSTACKSIZE);
		self.writeOutput("\n");

		self.writeOutput("	datarsp: resq 1\n");
		self.writeOutput("	datastack: resq ");
		self.writeInt(DATASTACKSIZE);
		self.writeOutput("\n");

		self.writeOutput("section .data\n");

		var i = 0;
		while (i < types.size) {
			//types.get(i).writeLiteralType(self);
			i = i + 1;
		}

		self.writeOutput("\n\n");

		i = 0;
		while (i < strings.size) {
			self.writeStringLiteral(strings.get(i), i);
			i = i + 1;
		}
	}
}

func createRegister(str name) -> Register {
	var reg = new Register();

	reg.name = name;
	reg.used = false;

	return reg;
}

func initRegisters() -> Array<Register> {
	var registers = createArray<Register>();
	registers.push(createRegister("r8"));
	registers.push(createRegister("r9"));
	registers.push(createRegister("r10"));
	registers.push(createRegister("r11"));
	registers.push(createRegister("rax"));
	registers.push(createRegister("rcx"));
	registers.push(createRegister("rdx"));

	return registers;
}

func createCompiler(int target) -> Compiler {
	var compiler = new Compiler();
	compiler.registers = initRegisters();
	compiler.target = target;
	return compiler;
}
