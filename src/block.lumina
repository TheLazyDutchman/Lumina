import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "position.lumina"
import "operator.lumina"
import "statement.lumina"
import "type.lumina"
import "function.lumina"
import "variable.lumina"
import "name.lumina"
import "whitespace.lumina"
import "definition.lumina"


import "../std/syscalls.lumina"
type Block {
	Region region;

	Operator lbrace;
	Array<Statement> statements;

	Array<Definition> definitions;
	Array<TypeObj> types;
	Array<Function> functions;
	Array<Variable> variables;
	Operator rbrace;
	int depth;

	Block outer;
	Function function;

	func parseBlock(Block self, Parser parser, Lexer lexer, SyntaxTree tree) -> Block {
		self.region = lexer.startRegion();

		self.lbrace = lexer.consumeOperator("{");
		if (self.lbrace == (Operator)0) {
			parser.error(self.region.start, " expected '{' before block\n");
			exit(1);
		}

		self.definitions = createArray<Definition>();
		self.types = createArray<TypeObj>();
		self.functions = createArray<Function>();
		self.variables = createArray<Variable>();

		while (!isOperator(lexer.current.operator, "}") && !lexer.current.isEOF) {
			var statement = new Statement();
			statement.parseStatement(parser, lexer, tree,
				self.definitions,
				self.variables,
				self.types,
				self.functions,
				tree.imports,
				self);
			self.statements.push(statement);
		}

		self.rbrace = lexer.consumeOperator("}");
		if (self.rbrace == (Operator)0) {
			parser.error(lexer.here(), " expected '}' after block\n");
		}

		lexer.endRegion(self.region);
		return self;
	}
}

func findFunctionInBlock(Block block, str name) -> Function {
	var function = findFunction(block.functions, name);

	if (function == (Function)0 && block.outer != (Block)0) {
		return findFunctionInBlock(block.outer, name);
	}

	return function;
}

func getBlockFunction(Block block) -> Function {
	if (block.function != (Function)0) {
	return block.function;
	}

	return getBlockFunction(block.outer);
}
