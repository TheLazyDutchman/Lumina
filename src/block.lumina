import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "position.lumina"
import "operator.lumina"
import "statement.lumina"
import "type.lumina"
import "function.lumina"
import "variable.lumina"
import "name.lumina"
import "whitespace.lumina"
import "definition.lumina"


type Block {
	Region region;

	Operator lbrace;
	Array<Statement> statements;

	Array<Definition> definitions;
	Array<TypeObj> types;
	Array<Function> functions;
	Array<Variable> variables;
	Operator rbrace;
	int depth;

	Block outer;
	SyntaxTree tree;
	Function function;

	func parseBlock(Block self, Parser parser, Lexer lexer, SyntaxTree tree) -> Block {
		self.tree = tree;
		self.region = lexer.startRegion();

		self.lbrace = lexer.consumeOperator("{");
		if (self.lbrace == (Operator)0) {
			parser.error(self.region.start, " expected '{' before block\n");
		}

		while (!isOperator(lexer.current.operator, "}") && !lexer.current.isEOF) {
			var statement = new Statement();
			statement.parseStatement(parser, lexer, self, tree,
				self.definitions,
				self.variables,
				self.types,
				self.functions,
				tree.imports);
			self.statements.push(statement);
		}

		self.rbrace = lexer.consumeOperator("}");
		if (self.rbrace == (Operator)0) {
			parser.error(lexer.here(), " expected '}' after block\n");
		}

		lexer.endRegion(self.region);
		return self;
	}

	func bindBlock(Block self, Parser parser) {
		var i = 0;
		while (i < self.statements.size) {
			var statement = self.statements.get(i);
			statement.bindStatement(parser);
			i = i + 1;
		}
	}

	func typeCheckBlock(Block self, Parser parser) {
		var i = 0;
		while (i < self.statements.size) {
			var statement = self.statements.get(i);
			statement.typeCheckStatement(parser);
			i = i + 1;
		}
	}

	func findDefinitionInBlock(Block self, str name) -> Definition {
		var definition = findDefinition(self.definitions, name);

		if (definition != (Definition)0) {
			return definition;
		}

		if (self.outer != (Block)0) {
			return self.outer.findDefinitionInBlock(name);
		}

		return self.tree.findDefinitionInTree(name);
	}
}

func createBlock(Block outer) -> Block {
	var block = new Block();

	block.definitions = createArray<Definition>();
	block.types = createArray<TypeObj>();
	block.functions = createArray<Function>();
	block.variables = createArray<Variable>();

	block.outer = outer;
	block.depth = outer.depth;

	return block;
}

func findFunctionInBlock(Block block, str name) -> Function {
	var function = findFunction(block.functions, name);

	if (function == (Function)0 && block.outer != (Block)0) {
		return findFunctionInBlock(block.outer, name);
	}

	return function;
}

func getBlockFunction(Block block) -> Function {
	if (block.function != (Function)0) {
	return block.function;
	}

	return getBlockFunction(block.outer);
}
