import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "position.lumina"
import "operator.lumina"
import "statement.lumina"
import "type.lumina"
import "function.lumina"
import "variable.lumina"
import "name.lumina"
import "whitespace.lumina"
import "definition.lumina"


type Block {
	Region region;

	Operator lbrace;
	Array<Statement> statements;

	Array<Definition> definitions;
	Array<TypeObj> types;
	Array<FunctionDefinition> functions;
	Array<Variable> variables;
	Operator rbrace;
	int depth;

	Block outer;
	FunctionDefinition function;

	func parse(Block self, Parser parser, Lexer lexer) -> Block {
		self.region = lexer.startRegion();

		self.lbrace = lexer.consumeOperator("{");
		if (self.lbrace == (Operator)0) {
			parser.error(self.region.start, " expected '{' before block\n");
		}

		while (!isOperator(lexer.current.operator, "}") && !lexer.current.isEOF) {
			var statement = new Statement();
			statement.parse(parser, lexer);
			self.statements.push(statement);
		}

		self.rbrace = lexer.consumeOperator("}");
		if (self.rbrace == (Operator)0) {
			parser.error(lexer.here(), " expected '}' after block\n");
		}

		lexer.endRegion(self.region);
		return self;
	}
}

func findFunctionInBlock(Block block, str name) -> FunctionDefinition {
	var function = findFunction(block.functions, name);

	if (function == (FunctionDefinition)0 && block.outer != (Block)0) {
		return findFunctionInBlock(block.outer, name);
	}

	return function;
}

func getBlockFunction(Block block) -> FunctionDefinition {
	if (block.function != (FunctionDefinition)0) {
	return block.function;
	}

	return getBlockFunction(block.outer);
}
