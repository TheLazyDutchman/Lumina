import "../std/string.lumina"
import "../std/io.lumina"
import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "identifier.lumina"
import "name.lumina" 
import "function.lumina"
import "operator.lumina"
import "operation.lumina"
import "position.lumina"
import "whitespace.lumina"


type Property {
	str name;
	int nameId;
	PropertyDefinition definition;
	str typeName;

	TypeObj propertyType;
	int offset;
}

type Generic {
	str name;
	TypeObj typeObj;

	GenericDefinition definition;
}

type TypeObj {
	str name;
	int nameId;
	TypeDefinition definition;
	int size;
	int objectSize;

	Array<Property> properties;
	Array<FunctionDefinition> methods;
	Array<Generic> generics;

	TypeObj listOf;
	TypeObj listType;

	Array<TypeObj> variants;
	bool isGeneric;

	int depth;
	int position;
}

type PropertyDefinition {
	Region region;

	Identifier propertyType;
	Name name;
	Operator semicolon;

	func parse(PropertyDefinition self, Parser parser, Lexer lexer) -> PropertyDefinition {
		self.region = lexer.startRegion();

		self.propertyType = new Identifier();
		self.propertyType.parse(parser, lexer);

		self.name = lexer.consumeIdentifier();
		if (self.name == (Name)0) {
			parser.error(lexer.here(), " expected property name\n");
		}

		self.semicolon = lexer.consumeOperator(";");
		if (self.semicolon == (Operator)0) {
			parser.error(lexer.here(), " expected ';' after property\n");
		}

		lexer.endRegion(self.region);
		return self;
	}
}

type TypeDefinition {
	Region region;
	Name keyword;
	Identifier name;
	int size;

	Operator lbrace;

	Array<PropertyDefinition> properties;
	Array<FunctionDefinition> methods;

	Operator rbrace;

	TypeDefinition listOf;
	TypeDefinition arrayType;

	func parse(TypeDefinition self, Parser parser, Lexer lexer) -> TypeDefinition {
		self.region = lexer.startRegion();

		self.keyword = lexer.consumeKeyword(KEYWORD_type);

		self.name = new Identifier();
		self.name.parse(parser, lexer);

		self.lbrace = lexer.consumeOperator("{");
		if (self.lbrace == (Operator)0) {
			parser.error(lexer.here(), " expected '{' before type properties\n");
		}

		self.properties = createArray<PropertyDefinition>();
		self.methods = createArray<FunctionDefinition>();

		while (!isOperator(lexer.current.operator, "}") && !lexer.current.isEOF) {
			if (isKeyword(lexer.current.name, KEYWORD_func)) {
				var method = new FunctionDefinition();
				method.parse(parser, lexer);
				self.methods.push(method);
			} else {
				var property = new PropertyDefinition();
				property.parse(parser, lexer);
				self.properties.push(property);
			}
		}

		self.rbrace = lexer.consumeOperator("}");
		if (self.rbrace == (Operator)0) {
			parser.error(lexer.here(), " expected '}' after type definition\n");
		}

		lexer.endRegion(self.region);
		return self;
	}
}

func findProperty(Array<Property> list, str name) -> Property {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (Property)0;
}

func createPropertyFromString(str name, TypeObj propertyType, int offset) -> Property {
	var property = new Property();

	property.name = name;
	property.typeName = propertyType.name;

	property.offset = offset;
	property.propertyType = propertyType;

	return property;
}

func createTypeFromString(str name, int size) -> TypeObj {
	var typeObj = new TypeObj();

	typeObj.name = name;
	typeObj.size = size;
	typeObj.objectSize = size;

	typeObj.generics = createArray<Generic>();
	typeObj.properties = createArray<Property>();

	typeObj.variants = createArray<TypeObj>();
	typeObj.variants.push(typeObj);

	return typeObj;
}

func createListType(Array<TypeObj> typeArray, str name, TypeObj typeObj) -> TypeObj {
	if (typeObj.listOf != (TypeObj)0) {
		return typeObj.listOf;
	}

	var listType = createTypeFromString(name, 8);
	listType.objectSize = typeObj.size;
	listType.listType = typeObj;
	listType.isGeneric = typeObj.isGeneric;

	typeObj.listOf = listType;

	if (typeArray != (Array<TypeObj>)0) {
		typeArray.push(listType);
	}

	return listType;
}

func findType(Array<TypeObj> list, str name) -> TypeObj {
	var i = 0;
	while (i < list.size) {
		var item = list.get(i);
		if (item.name != (str)0 && streq(item.name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (TypeObj)0;
}

func printType(TypeObj typeObj) {
	if (typeObj == (TypeObj)0) {
		print("type is null");
		return;
	}

	if (typeObj.generics.size != 0) {
		print(typeObj.name);
		print("<");
		var i = 0;
		while (i < typeObj.generics.size) {
			if (i != 0) {
				print(",");
			}
			printType(typeObj.generics.list[i].typeObj);
			i = i + 1;
		}
		print(">");
		return;
	}

	if (typeObj.listType != (TypeObj)0 && typeObj.name == (str)0) {
		printType(typeObj.listType);
		print("[]");
		return;
	}

	if (typeObj.name == (str)0) {
		print("type name is null");
		return;
	}

	print(typeObj.name);
}

func printTypeArray(Array<TypeObj> list) {
	var i = 0;
	print("[");
	while (i < list.size) {
		if (i != 0) {
			print(",");
		}
		printType(list.list[i]);
		i = i + 1;
	}
	print("]");
}
