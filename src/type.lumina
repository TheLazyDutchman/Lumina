import "../std/string.lumina"
import "../std/io.lumina"
import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "definition.lumina"
import "identifier.lumina"
import "index.lumina"
import "name.lumina" 
import "function.lumina"
import "operator.lumina"
import "operation.lumina"
import "position.lumina"
import "whitespace.lumina"
import "block.lumina"
import "variable.lumina"


type Property {
	Region region;

	Identifier propertyType;
	Name name;
	Operator semicolon;

	int offset;
	int nameId;
	TypeObj typeObj;

	func parseProperty(Property self, Parser parser, Lexer lexer, Block block, TypeObj typeObj) -> Property {
		self.typeObj = typeObj;
		self.region = lexer.startRegion();

		self.propertyType = new Identifier();
		self.propertyType.parseIdentifier(parser, lexer, block);

		self.name = lexer.consumeIdentifier();
		if (self.name == (Name)0) {
			parser.error(lexer.here(), " expected property name\n");
		}

		self.semicolon = lexer.consumeOperator(";");
		if (self.semicolon == (Operator)0) {
			parser.error(lexer.here(), " expected ';' after property\n");
		}

		lexer.endRegion(self.region);
		return self;
	}
	
	func bindProperty(Property self, Parser parser) {
		if (self.typeObj.findProperty(self.name.name) != self) {
			parser.error(self.region.start, " a property with this name already exists\n");
		}

		if (self.typeObj.findMethod(self.name.name) != (Function)0) {
			parser.error(self.region.start, " a method with this name already exists\n");
		}

		self.propertyType.bindIdentifier(parser, false);
	}

	func typeCheckProperty(Property self, Parser parser) {
		var typeObj = self.propertyType.typeCheckIdentifier(parser);
		if (!typeObj.checkType(parser.Type, parser)) {
			parser.error(self.region.start, " expected property type to be a type\n");
		}
	}

	func cloneProperty(Property self) -> Property {
		var clone = new Property();

		clone.typeObj = self.typeObj;

		return clone;
	}
}

type TypeObj {
	Region region;
	Name keyword;
	IdentifierDefinition name;
	int size;
	int objectSize;

	Operator lbrace;

	Array<Property> properties;
	Array<Function> methods;

	Operator rbrace;

	TypeObj listOf;
	TypeObj listType;

	Array<TypeObj> variants;

	bool isGeneric;

	Block block;
	int nameId;

	Array<TypeObj> generics;

	bool isChecked;

	func parseType(TypeObj self, Parser parser, SyntaxTree tree, Lexer lexer, Block block) -> TypeObj {
		self.block = createBlock(block);
		self.isChecked = false;

		self.region = lexer.startRegion();

		self.keyword = lexer.consumeKeyword(KEYWORD_type);

		self.name = new IdentifierDefinition();
		self.name.parseIdentifierDefinition(parser, lexer);

		if (self.name.generics != (GenericDefinitionArray)0) {
			self.generics = createArray<TypeObj>();
			self.name.generics.addTypes(self.generics, self.block.definitions);
			self.block.types.extend(self.generics);
		}

		self.lbrace = lexer.consumeOperator("{");
		if (self.lbrace == (Operator)0) {
			parser.error(lexer.here(), " expected '{' before type properties\n");
		}

		self.properties = createArray<Property>();
		self.methods = createArray<Function>();

		while (!isOperator(lexer.current.operator, "}") && !lexer.current.isEOF) {
			if (isKeyword(lexer.current.name, KEYWORD_func)) {
				var method = new Function();
				method.generics = self.generics;
				method.parseFunction(parser, tree, lexer, self.block);
				self.methods.push(method);
				self.block.functions.push(method);
				self.block.definitions.push(createDefinitionFromFunction(method));
			} else {
				var property = new Property();
				property.parseProperty(parser, lexer, self.block, self);
				self.properties.push(property);
			}
		}

		self.rbrace = lexer.consumeOperator("}");
		if (self.rbrace == (Operator)0) {
			parser.error(lexer.here(), " expected '}' after type definition\n");
		}

		self.variants = createArray<TypeObj>();
		self.variants.push(self);

		lexer.endRegion(self.region);
		return self;
	}

	func bindType(TypeObj self, Parser parser) {
		var definition = self.block.findDefinitionInBlock(self.name.name);

		if (definition.typeObj != self) {
			parser.error(self.region.start, " a type with this name already exists\n");
			print("[NOTE] the other is defined here: ");
			printPosition(definition.typeObj.region.start);
			print("\n");
		}

		if (definition.variable != (Variable)0) {
			parser.error(self.region.start, " a variable with this name already exists\n");
			print("[NOTE] the other is defined here: ");
			printPosition(definition.variable.region.start);
			print("\n");
		}

		if (definition.function != (Function)0) {
			parser.error(self.region.start, " a function with this name already exists\n");
			print("[NOTE] the other is defined here: ");
			printPosition(definition.function.region.start);
			print("\n");
		}

		var i = 0;
		while (i < self.properties.size) {
			var property = self.properties.get(i);
			property.bindProperty(parser);
			i = i + 1;
		}

		i = 0;
		while (i < self.methods.size) {
			var method = self.methods.get(i);
			if (self.findMethod(method.name.name) != method) {
				parser.error(method.region.start, " a method with this name already exists\n");
			}

			if (self.findProperty(method.name.name) != (Property)0) {
				parser.error(method.region.start, " a property with this name already exists\n");
			}

			method.bindFunction(parser);
			i = i + 1;
		}
	}

	func typeCheckType(TypeObj self, Parser parser) {
		self.isChecked = true;
		var i = 0;
		while (i < self.properties.size) {
			var property = self.properties.get(i);
			property.typeCheckProperty(parser);
			i = i + 1;
		}

		i = 0;
		while (i < self.methods.size) {
			var method = self.methods.get(i);
			method.typeCheckFunction(parser);
			i = i + 1;
		}
	}

	func getVariantType(TypeObj self, Array<TypeObj> generics) -> TypeObj {
		if (self.generics == (Array<TypeObj>)0) {
			return self;
		}

		if (self.generics.size != generics.size) {
			return (TypeObj)0;
		}

		var i = 0;
		while (i < self.variants.size) {
			var variant = self.variants.get(i);
			if (checkGenerics(variant.generics, generics)) {
				return variant;
			}

			i = i + 1;
		}

		return self.createVariantType(generics);
	}

	func createVariantType(TypeObj self, Array<TypeObj> generics) -> TypeObj {
		var newType = self.cloneType();

		var i = 0;
		while (i < self.properties.size) {
			var property = newType.properties.get(i);
			property.typeObj = property.typeObj.applyGenerics(self.generics, generics);
			i = i + 1;
		}
		
		i = 0;
		while (i < self.methods.size) {
			newType.methods.push(self.methods.get(i).getVariantFunction(generics));
			newType.block.functions.push(newType.methods.get(i));
			newType.block.definitions.push(createDefinitionFromFunction(newType.methods.get(i)));
			i = i + 1;
		}

		newType.generics = generics;

		return newType;
	}

	func cloneType(TypeObj self) -> TypeObj {
		var clone = new TypeObj();
		self.variants.push(clone);

		clone.name = self.name;
		clone.block = createBlock(self.block.outer);

		clone.properties = createArray<Property>();
		var i = 0;
		while (i < self.properties.size) {
			clone.properties.push(self.properties.get(i).cloneProperty());
			i = i + 1;
		}

		clone.methods = createArray<Function>();
		clone.variants = self.variants;

		return clone;
	}

	func applyGenerics(TypeObj self, Array<TypeObj> generics, Array<TypeObj> newTypes) -> TypeObj {
		var i = 0;
		while (i < generics.size) {
			if (self == generics.get(i)) {
				return newTypes.get(i);
			}
			i = i + 1;
		}

		if (self.listType != (TypeObj)0) {
			return createListType((str)0, self.listType.applyGenerics(generics, newTypes));
		}

		if (self.generics != (Array<TypeObj>)0) {
			var genericTypes = createArray<TypeObj>();
			var i = 0;
			while (i < self.generics.size) {
				var j = 0;
				while (j < generics.size) {
					if (self.generics.get(i) == generics.get(j)) {
						genericTypes.push(newTypes.get(j));
					}
					j = j + 1;
				}
				i = i + 1;
			}

			return self.getVariantType(genericTypes);
		}

		return self;
	}

	func checkType(TypeObj self, TypeObj expected, Parser parser) -> bool {
		return self == expected || self == (TypeObj)0 || expected == (TypeObj)0 || expected == parser.any;
	}

	func findProperty(TypeObj self, str name) -> Property {
		var i = 0;
		while (i < self.properties.size) {
			if (streq(self.properties.get(i).name.name, name)) {
				return self.properties.get(i);
			}
			i = i + 1;
		}
		return (Property)0;
	}

	func findMethod(TypeObj self, str name) -> Function {
		var i = 0;
		while (i < self.methods.size) {
			if (streq(self.methods.get(i).name.name, name)) {
				return self.methods.get(i);
			}
			i = i + 1;
		}
		return (Function)0;
	}

	func printType(TypeObj self) {
		if (self == (TypeObj)0) {
			print("Type is null");
			return;
		}

		if (self.name == (IdentifierDefinition)0) {
			if (self.listType != (TypeObj)0) {
				self.listType.printType();
				print("[]");
			}
		} else {
			print(self.name.name);
		}

		if (self.generics != (Array<TypeObj>)0) {
			print("<");

			var i = 0;
			while (i < self.generics.size) {
				if (i > 0) {
					print(",");
				}

				self.generics.get(i).printType();
				i = i + 1;
			}

			print(">");
		}
	}
}

func checkGenerics(Array<TypeObj> original, Array<TypeObj> expected) -> bool {
	var i = 0;
	while (i < original.size) {
		if (original.get(i) != expected.get(i)) {
			return false;
		}
		i = i + 1;
	}

	return true;
}

func createPropertyFromString(str name, TypeObj propertyType, int offset) -> Property {
	var property = new Property();

	property.name = createNameFromString(name);
	property.propertyType = createIdentifierFromDefinition(propertyType.name);

	property.offset = offset;

	return property;
}

func createTypeFromString(str name, int size) -> TypeObj {
	var typeObj = new TypeObj();

	if (name != (str)0) {
		typeObj.name = createIdentifierDefinitionFromString(name);
	}

	typeObj.isChecked = true;

	typeObj.size = size;
	typeObj.objectSize = size;

	typeObj.properties = createArray<Property>();

	typeObj.variants = createArray<TypeObj>();
	typeObj.variants.push(typeObj);

	return typeObj;
}

func createListType(str name, TypeObj typeObj) -> TypeObj {
	if (typeObj.listOf != (TypeObj)0) {
		return typeObj.listOf;
	}

	var listType = createTypeFromString(name, 8);
	listType.objectSize = typeObj.size;
	listType.listType = typeObj;
	listType.isGeneric = typeObj.isGeneric;

	listType.isChecked = true;

	typeObj.listOf = listType;

	typeObj.block.outer.types.push(listType);

	return listType;
}

func findType(Array<TypeObj> list, str name) -> TypeObj {
	var i = 0;
	while (i < list.size) {
		var item = list.get(i);
		if (item.name.name != (str)0 && streq(item.name.name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (TypeObj)0;
}
