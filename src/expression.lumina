import "../std/io.lumina"
import "../std/collections.lumina"

import "compiler.lumina"
import "parser.lumina"
import "lexer.lumina"
import "block.lumina"
import "type.lumina"
import "position.lumina"
import "operator.lumina"
import "and.lumina"


type AndPart {
	Operator and;
	Or value;
}

type Expression {
	Region region;

	Or value;
	Array<AndPart> parts;

	TypeObj typeObj;

	func parseExpression(Expression self, Parser parser, Lexer lexer, Block block) -> Expression {
		self.region = lexer.startRegion();

		self.value = new Or();
		self.value.parseOr(parser, lexer, block);

		self.parts = createArray<AndPart>();

		while (isOperator(lexer.current.operator, "&&")) {
			var part = new AndPart();
			part.and = lexer.consumeOperator("&&");

			part.value = new Or();
			part.value.parseOr(parser, lexer, block);

			self.parts.push(part);
		}

		lexer.endRegion(self.region);

		return self;
	}

	func bindExpression(Expression self, Parser parser) {
		self.value.bindOr(parser);

		var i = 0;
		while (i < self.parts.size) {
			var part = self.parts.get(i);
			part.value.bindOr(parser);
			i = i + 1;
		}
	}

	func typeCheckExpression(Expression self, Parser parser) -> TypeObj {
		if (self.typeObj != (TypeObj)0) {
			return self.typeObj;
		}

		var valueType = self.value.typeCheckOr(parser);

		if (self.parts.size == 0) {
			self.typeObj = valueType;
			return valueType;
		}

		if (!valueType.checkType(parser.bool, parser)) {
			parser.error(self.value.region.start, " expected 'bool' in '&&' operation\n");
		}

		var i = 0;
		while (i < self.parts.size) {
			var part = self.parts.get(i);
			valueType = part.value.typeCheckOr(parser);

			if (!valueType.checkType(parser.bool, parser)) {
				parser.error(part.value.region.start, " expected 'bool' in '&&' operation\n");
			}
			i = i + 1;
		}

		self.typeObj = parser.bool;
		return parser.bool;
	}

	func writeExpression(Expression self, Compiler compiler, bool getPointer) -> Register {
		var valueRegister = self.value.writeOr(compiler, getPointer);

		var i = 0;
		while (i < self.parts.size) {
			print("can't write and yet\n");
			i = i + 1;
		}

		return valueRegister;
	}

	func getTypeExpression(Expression self, Parser parser) -> TypeObj {
		return self.value.getTypeOr(parser);
	}
}
