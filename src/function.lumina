import "../std/string.lumina"
import "../std/io.lumina"
import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "identifier.lumina"
import "position.lumina"
import "name.lumina"
import "operation.lumina"
import "expression.lumina"
import "operator.lumina"
import "type.lumina"
import "variable.lumina"
import "definition.lumina"
import "whitespace.lumina"
import "block.lumina"


type Parameter {
	Region region;
	
	Identifier parameterType;
	Name name;
	Operator comma;

	TypeObj typeObj;
	Variable variable;

	func parseParameter(Parameter self, Parser parser, Lexer lexer, Block block, Array<Variable> variables, Array<Definition> definitions) -> Parameter {
		self.region = lexer.startRegion();
		
		self.parameterType = new Identifier();
		self.parameterType.parseIdentifier(parser, lexer, block);

		self.name = lexer.consumeIdentifier();
		if (self.name == (Name)0) {
			parser.error(lexer.here(), " expected parameter name\n");
		}

		self.comma = lexer.consumeOperator(",");

		lexer.endRegion(self.region);

		self.variable = createVariableFromString(self.parameterType.name, block.depth + 1, variables.size, (TypeObj)0);
		variables.push(self.variable);
		definitions.push(createDefinitionFromVariable(self.variable));

		return self;
	}

	func bindParameter(Parameter self, Parser parser) {
		self.parameterType.bindIdentifier(parser, false);
	}

	func typeCheckParameter(Parameter self, Parser parser) {
		var typeObj = self.parameterType.typeCheckIdentifier(parser);
		self.typeObj = self.parameterType.definition.typeObj;
		self.variable.variableType = self.typeObj;

		if (!typeObj.checkType(parser.Type, parser)) {
			parser.error(self.parameterType.region.start, " expected parameter type to be a type\n");
		}
	}

	func cloneParameter(Parameter self) -> Parameter {
		var clone = new Parameter();

		clone.typeObj = self.typeObj;
		clone.variable = self.variable;

		return clone;
	}
}

type ReturnType {
	Region region;

	Operator rarrow;
	Identifier returnType;

	TypeObj typeObj;

	func parseReturnType(ReturnType self, Parser parser, Lexer lexer, Block block) -> ReturnType {
		self.region = lexer.startRegion();

		self.rarrow = lexer.consumeOperator("->");

		self.returnType = new Identifier();
		self.returnType.parseIdentifier(parser, lexer, block);

		lexer.endRegion(self.region);

		return self;
	}

	func bindReturnType(ReturnType self, Parser parser) {
		self.returnType.bindIdentifier(parser, false);
	}

	func typeCheckReturnType(ReturnType self, Parser parser) {
		var typeObj = self.returnType.typeCheckIdentifier(parser);
		self.typeObj = self.returnType.definition.typeObj;

		if (!typeObj.checkType(parser.Type, parser)) {
			parser.error(self.returnType.region.start, " expected type for return type\n");
		}
	}

	func cloneReturnType(ReturnType self) -> ReturnType {
		var clone = new ReturnType();

		clone.typeObj = self.typeObj;

		return clone;
	}
}

type Function {
	Region region;

	Name keyword;

	IdentifierDefinition name;

	Operator lparen;
	Array<Parameter> parameters;
	Operator rparen;

	ReturnType returnType;

	Block block;
	Block outerBlock;

	Array<Function> variants;

	bool isCalled;

	Array<TypeObj> generics;

	bool isChecked;

	func parseFunction(Function self, Parser parser, SyntaxTree tree, Lexer lexer, Block block) -> Function {
		self.outerBlock = createBlock(block);
		self.isChecked = false;

		self.region = lexer.startRegion();

		self.keyword = lexer.consumeKeyword(KEYWORD_func);
		
		self.name = new IdentifierDefinition();
		self.name.parseIdentifierDefinition(parser, lexer);

		if (self.name.generics != (GenericDefinitionArray)0) {
			self.generics = createArray<TypeObj>();
			self.name.generics.addTypes(self.generics, self.outerBlock.definitions);
			self.outerBlock.types.extend(self.generics);
		}

		self.lparen = lexer.consumeOperator("(");
		if (self.lparen == (Operator)0) {
			parser.error(lexer.here(), " expected '(' after function name\n");
		}

		self.block = createBlock(self.outerBlock);
		self.block.depth = self.block.depth + 1;
		self.block.function = self;

		self.parameters = createArray<Parameter>();
		while (!isOperator(lexer.current.operator, ")") && !lexer.current.isEOF) {
			var parameter = new Parameter();
			parameter.parseParameter(parser, lexer, self.outerBlock, self.block.variables, self.block.definitions);

			self.parameters.push(parameter);
		}

		self.rparen = lexer.consumeOperator(")");
		if (self.rparen == (Operator)0) {
			parser.error(lexer.here(), " expected ')' after function parameters\n");
		}

		if (isOperator(lexer.current.operator, "->")) {
			self.returnType = new ReturnType();
			self.returnType.parseReturnType(parser, lexer, self.outerBlock);
		}

		self.block.parseBlock(parser, lexer, tree);

		if (self.returnType != (ReturnType)0 && !self.block.hasReturned) {
			parser.error(self.block.region.end, " not all paths return a value\n");
		}

		self.variants = createArray<Function>();
		self.variants.push(self);

		lexer.endRegion(self.region);

		return self;
	}

	func bindFunction(Function self, Parser parser) {
		var definition = self.outerBlock.findDefinitionInBlock(self.name.name);
		if (definition.function != self) {
			parser.error(self.region.start, " a function with this name already exists\n");
			print("[NOTE] the other is defined here: ");
			printPosition(definition.function.region.start);
			print("\n");
		}

		if (definition.variable != (Variable)0) {
			parser.error(self.region.start, " a variable with this name already exists\n");
			print("[NOTE] the other is defined here: ");
			printPosition(definition.variable.region.start);
			print("\n");
		}

		if (definition.typeObj != (TypeObj)0) {
			parser.error(self.region.start, " a type with this name already exists\n");
			print("[NOTE] the other is defined here: ");
			printPosition(definition.typeObj.region.start);
			print("\n");
		}

		var i = 0;
		while (i < self.parameters.size) {
			var parameter = self.parameters.get(i);
			parameter.bindParameter(parser);

			if (findParameter(self.parameters, parameter.name.name) != parameter) {
				parser.error(parameter.region.start, " there already is a parameter with this name\n");
			}

			i = i + 1;
		}

		if (self.returnType != (ReturnType)0) {
			self.returnType.bindReturnType(parser);
		}

		self.block.bindBlock(parser);
	}

	func typeCheckFunction(Function self, Parser parser) {
		self.isChecked = true;

		var i = 0;
		while (i < self.parameters.size) {
			var parameter = self.parameters.get(i);
			parameter.typeCheckParameter(parser);
			i = i + 1;
		}

		if (self.returnType != (ReturnType)0) {
			self.returnType.typeCheckReturnType(parser);
		}

		self.block.typeCheckBlock(parser);
	}

	func getVariantFunction(Function self, Array<TypeObj> generics) -> Function {
		if (self.generics == (Array<TypeObj>)0) {
			return self;
		}

		if (self.generics.size != generics.size) {
			return (Function)0;
		}

		var i = 0;
		while (i < self.variants.size) {
			var variant = self.variants.get(i);
			if (checkGenerics(variant.generics, generics)) {
				return variant;
			}

			i = i + 1;
		}

		return self.createVariantFunction(generics);
	}

	func createVariantFunction(Function self, Array<TypeObj> generics) -> Function {
		var newFunction = self.cloneFunction();

		var i = 0;
		while (i < self.parameters.size) {
			var parameter = newFunction.parameters.get(i);
			parameter.typeObj = parameter.typeObj.applyGenerics(self.generics, generics);
			i = i + 1;
		}

		if (newFunction.returnType != (ReturnType)0) {
			newFunction.returnType.typeObj = newFunction.returnType.typeObj.applyGenerics(self.generics, generics);
		}

		newFunction.generics = generics;

		return newFunction;
	}

	func cloneFunction(Function self) -> Function {
		var clone = new Function();
		self.variants.push(clone);

		clone.name = self.name;
		clone.parameters = createArray<Parameter>();

		var i = 0;
		while (i < self.parameters.size) {
			clone.parameters.push(self.parameters.get(i).cloneParameter());
			i = i + 1;
		}

		if (self.returnType != (ReturnType)0) {
			clone.returnType = self.returnType.cloneReturnType();
		}

		clone.variants = self.variants;

		return clone;
	}

	func printFunction(Function self) {
		print(self.name.name);

		if (self.generics != (Array<TypeObj>)0) {
			print("<");
			
			var i = 0;
			while (i < self.generics.size) {
				if (i > 0) {
					print(", ");
				}

				self.generics.get(i).printType();
				i = i + 1;
			}

			print(">");
		}

		print("(");

		var i = 0;
		while (i < self.parameters.size) {
			if (i > 0) {
				print(",");
			}

			self.parameters.get(i).typeObj.printType();
			i = i + 1;
		}

		print(")");
	}
}

type Return {
	Region region;

	Name keyword;
	Expression expression;
	Operator semicolon;

	Block block;

	func parseReturn(Return self, Parser parser, Lexer lexer, Block block) -> Return {
		self.block = block;
		self.region = lexer.startRegion();

		self.keyword = lexer.consumeKeyword(KEYWORD_return);

		if (block.function == (Function)0) {
			parser.error(self.region.start, " did not expect return outside of function\n");
		}

		if (!isOperator(lexer.current.operator, ";")) {
			self.expression = new Expression();
			self.expression.parseExpression(parser, lexer, block);
		}

		self.semicolon = lexer.consumeOperator(";");
		if (self.semicolon == (Operator)0) {
			parser.error(lexer.here(), " expected ';' after 'return' statement\n");
		}

		lexer.endRegion(self.region);
		return self;
	}

	func bindReturn(Return self, Parser parser) {
		if (self.expression != (Expression)0) {
			self.expression.bindExpression(parser);
		}
	}

	func typeCheckReturn(Return self, Parser parser) {
		var returnType = self.block.function.returnType;
		if (self.expression == (Expression)0) {
			if (returnType != (ReturnType)0) {
				parser.error(self.region.start, " expected return value\n");
			}
			return;
		}

		var typeObj = self.expression.typeCheckExpression(parser);
		if (returnType == (ReturnType)0) {
			parser.error(self.region.start, " did not expect return value from a null function\n");
			return;
		}

		if (!typeObj.checkType(returnType.typeObj, parser)) {
			parser.error(self.region.start, " expected type '");
			returnType.typeObj.printType();
			print("' in return, got '");
			typeObj.printType();
			print("' instead\n");
		}
	}
}

func createReturnTypeFromString(TypeObj typeObj) -> ReturnType {
	var returnType = new ReturnType();

	returnType.typeObj = typeObj;

	return returnType;
}

func createFunctionFromString(str value, Array<Parameter> parameters, ReturnType returnType) -> Function {
	var function = new Function();

	function.name = createIdentifierDefinitionFromString(value);
	function.parameters = parameters;
	function.returnType = returnType;

	function.isChecked = true;

	function.variants = createArray<Function>();
	function.variants.push(function);

	return function;
}

func findFunction(Array<Function> list, str name) -> Function {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name.name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (Function)0;
}

func findParameter(Array<Parameter> list, str name) -> Parameter {
	var i = 0;
	while (i < list.size) {
		if (streq(list.get(i).name.name, name)) {
			return list.get(i);
		}
		i = i + 1;
	}
	return (Parameter)0;
}

func createParameterFromString(TypeObj typeObj, str name) -> Parameter {
	var parameter = new Parameter();

	parameter.name = createNameFromString(name);
	parameter.typeObj = typeObj;

	return parameter;
}
