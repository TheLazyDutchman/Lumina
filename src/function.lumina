import "../std/string.lumina"
import "../std/io.lumina"
import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "identifier.lumina"
import "position.lumina"
import "name.lumina"
import "operation.lumina"
import "expression.lumina"
import "operator.lumina"
import "type.lumina"
import "variable.lumina"
import "whitespace.lumina"
import "block.lumina"


type Parameter {
	Region region;
	
	Identifier parameterType;
	Name name;
	Operator comma;

	TypeObj typeObj;

	func parseParameter(Parameter self, Parser parser, Lexer lexer) -> Parameter {
		self.region = lexer.startRegion();
		
		self.parameterType = new Identifier();
		self.parameterType.parseIdentifier(parser, lexer);

		self.name = lexer.consumeIdentifier();
		if (self.name == (Name)0) {
			parser.error(lexer.here(), " expected parameter name\n");
		}

		self.comma = lexer.consumeOperator(",");

		lexer.endRegion(self.region);
		return self;
	}
}

type ReturnType {
	Region region;

	Operator rarrow;
	Identifier returnType;

	TypeObj typeObj;

	func parseReturnType(ReturnType self, Parser parser, Lexer lexer) -> ReturnType {
		self.region = lexer.startRegion();

		self.rarrow = lexer.consumeOperator("->");

		self.returnType = new Identifier();
		self.returnType.parseIdentifier(parser, lexer);

		lexer.endRegion(self.region);

		return self;
	}
}

type Function {
	Region region;

	Name keyword;

	Identifier name;

	Operator lparen;
	Array<Parameter> parameters;
	Operator rparen;

	ReturnType returnType;

	Block block;

	Array<Function> variants;

	bool isCalled;

	int numGenerics;

	func parseFunction(Function self, Parser parser, SyntaxTree tree, Lexer lexer) -> Function {
		self.region = lexer.startRegion();

		self.keyword = lexer.consumeKeyword(KEYWORD_func);
		
		self.name = new Identifier();
		self.name.parseIdentifier(parser, lexer);

		if (self.name.generics != (GenericArray)0) {
			self.numGenerics = self.name.generics.generics.size + 1;
		}

		self.lparen = lexer.consumeOperator("(");
		if (self.lparen == (Operator)0) {
			parser.error(lexer.here(), " expected '(' after function name\n");
		}

		self.parameters = createArray<Parameter>();
		while (!isOperator(lexer.current.operator, ")") && !lexer.current.isEOF) {
			var parameter = new Parameter();
			parameter.parseParameter(parser, lexer);

			self.parameters.push(parameter);
		}

		self.rparen = (Operator)0; // otherwise I get a segfault (this can be any operation)
		self.rparen = lexer.consumeOperator(")");
		if (self.rparen == (Operator)0) {
			parser.error(lexer.here(), " expected ')' after function parameters\n");
		}

		if (isOperator(lexer.current.operator, "->")) {
			self.returnType = new ReturnType();
			self.returnType.parseReturnType(parser, lexer);
		}

		self.block = new Block();
		self.block.parseBlock(parser, lexer, tree);

		return self;
	}
}

type Return {
	Region region;

	Name keyword;
	Expression expression;
	Operator semicolon;

	func parseReturn(Return self, Parser parser, Lexer lexer) -> Return {
		self.region = lexer.startRegion();

		self.keyword = lexer.consumeKeyword(KEYWORD_return);

		if (!isOperator(lexer.current.operator, ";")) {
			self.expression = new Expression();
			self.expression.parseExpression(parser, lexer);
		}

		self.semicolon = lexer.consumeOperator(";");
		if (self.semicolon == (Operator)0) {
			parser.error(lexer.here(), " expected ';' after 'return' statement\n");
		}

		lexer.endRegion(self.region);
		return self;
	}
}

func createReturnTypeFromString(TypeObj typeObj) -> ReturnType {
	var returnType = new ReturnType();

	returnType.typeObj = typeObj;

	return returnType;
}

func createFunctionFromString(str value, Array<Parameter> parameters, ReturnType returnType) -> Function {
	var function = new Function();

	function.name = createIdentifierFromString(value);
	function.parameters = parameters;
	function.returnType = returnType;

	function.variants = createArray<Function>();

	return function;
}

func findFunction(Array<Function> list, str name) -> Function {
	var i = 0;
	while (i < list.size) {
		if (streq(list.list[i].name.name, name)) {
			return list.list[i];
		}
		i = i + 1;
	}
	return (Function)0;
}
