import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "position.lumina"
import "expression.lumina"
import "index.lumina"
import "unary.lumina"
import "operator.lumina"
import "block.lumina"


type ArgumentPart {
	Operator comma;
	Expression value;
}

type ArgumentArray {
	Expression value;
	Array<ArgumentPart> parts;

	func parseArgumentArray(ArgumentArray self, Parser parser, Lexer lexer, Block block) -> ArgumentArray {
		if (isOperator(lexer.current.operator, ")")) {
			return self;
		}

		self.value = new Expression();
		self.value.parseExpression(parser, lexer, block);

		self.parts = createArray<ArgumentPart>();

		while (isOperator(lexer.current.operator, ",")) {
			var part = new ArgumentPart();
			part.comma = lexer.consumeOperator(",");

			part.value = new Expression();
			part.value.parseExpression(parser, lexer, block);

			self.parts.push(part);
		}

		return self;
	}

	func bindArguments(ArgumentArray self, Parser parser) {
		self.value.bindExpression(parser);

		var i = 0;
		while (i < self.parts.size) {
			var part = self.parts.get(i);
			part.value.bindExpression(parser);
			i = i + 1;
		}
	}
}

type Call {
	Region region;

	Unary value;
	Operator lparen;
	ArgumentArray arguments;
	Operator rparen;


	func parseCall(Call self, Parser parser, Lexer lexer, Block block) -> Call {
		self.region = lexer.startRegion();

		self.value = new Unary();
		self.value.parseUnary(parser, lexer, block);

		self.lparen = lexer.consumeOperator("(");
		if (self.lparen != (Operator)0) {
			self.arguments = new ArgumentArray();
			self.arguments.parseArgumentArray(parser, lexer, block);

			self.rparen = lexer.consumeOperator(")");
			if (self.rparen == (Operator)0) {
				parser.error(lexer.here(), " expected ')' after function arguments\n");
			}
		}

		lexer.endRegion(self.region);

		return self;
	}

	func bindCall(Call self, Parser parser) {
		self.value.bindUnary(parser);

		if (self.arguments != (ArgumentArray)0) {
			self.arguments.bindArguments(parser);
		}
	}
}
