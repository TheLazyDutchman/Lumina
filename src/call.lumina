import "../std/collections.lumina"
import "../std/io.lumina"

import "compiler.lumina"
import "parser.lumina"
import "lexer.lumina"
import "function.lumina"
import "type.lumina"
import "position.lumina"
import "expression.lumina"
import "index.lumina"
import "value.lumina"
import "operator.lumina"
import "block.lumina"


type ArgumentPart {
	Operator comma;
	Expression value;
}

type ArgumentArray {
	Region region;

	Expression value;
	Array<ArgumentPart> parts;

	func parseArgumentArray(ArgumentArray self, Parser parser, Lexer lexer, Block block) -> ArgumentArray {
		self.region = lexer.startRegion();

		if (isOperator(lexer.current.operator, ")")) {
			return self;
		}

		self.value = new Expression();
		self.value.parseExpression(parser, lexer, block);

		self.parts = createArray<ArgumentPart>();

		while (isOperator(lexer.current.operator, ",")) {
			var part = new ArgumentPart();
			part.comma = lexer.consumeOperator(",");

			part.value = new Expression();
			part.value.parseExpression(parser, lexer, block);

			self.parts.push(part);
		}

		lexer.endRegion(self.region);
		return self;
	}

	func bindArguments(ArgumentArray self, Parser parser) {
		self.value.bindExpression(parser);

		var i = 0;
		while (i < self.parts.size) {
			var part = self.parts.get(i);
			part.value.bindExpression(parser);
			i = i + 1;
		}
	}

	func typeCheckArguments(ArgumentArray self, Function function, Parser parser, TypeObj objectType) {
		var argumentTypes = createArray<TypeObj>();

		if (objectType != (TypeObj)0) {
			argumentTypes.push(objectType);
		}

		if (self.value != (Expression)0) {
			argumentTypes.push(self.value.typeCheckExpression(parser));

			var i = 0;
			while (i < self.parts.size) {
				var part = self.parts.get(i);
				argumentTypes.push(part.value.typeCheckExpression(parser));
				i = i + 1;
			}
		}

		if (function == (Function)0) {
			return;
		} else {
			if (argumentTypes.size != function.parameters.size) {
				parser.error(self.region.start, " expected ");
				printi(function.parameters.size);
				print(" arguments, got ");
				printi(argumentTypes.size);
				print(" instead\n");
				return;
			}
		}

		var i = 0;
		while (i < argumentTypes.size) {
			var typeObj = argumentTypes.get(i);
			var expected = function.parameters.get(i).typeObj;
			if (!typeObj.checkType(expected, parser)) {
				parser.error(self.region.start, " incorrect argument type at index ");
				printi(i);
				print(", expected: ");
				expected.printType();
				print(", got: ");
				typeObj.printType();
				print("\n");
			}
			i = i + 1;
		}
	}
}

type Call {
	Region region;

	Value value;
	Operator lparen;
	ArgumentArray arguments;
	Operator rparen;


	func parseCall(Call self, Parser parser, Lexer lexer, Block block) -> Call {
		self.region = lexer.startRegion();

		self.value = new Value();
		self.value.parseValue(parser, lexer, block);

		self.lparen = lexer.consumeOperator("(");
		if (self.lparen != (Operator)0) {
			self.arguments = new ArgumentArray();
			self.arguments.parseArgumentArray(parser, lexer, block);

			self.rparen = lexer.consumeOperator(")");
			if (self.rparen == (Operator)0) {
				parser.error(lexer.here(), " expected ')' after function arguments\n");
			}
		}

		lexer.endRegion(self.region);

		return self;
	}

	func bindCall(Call self, Parser parser, bool isProperty) {
		self.value.bindValue(parser, isProperty);

		if (self.arguments != (ArgumentArray)0) {
			self.arguments.bindArguments(parser);
		}
	}

	func typeCheckCall(Call self, Parser parser, TypeObj objectType) -> TypeObj {
		var valueType = self.value.typeCheckValue(parser);

		if (self.lparen == (Operator)0) {
			return valueType;
		}

		var function = self.value.identifier.definition.function;
		if (function == (Function)0 && objectType != (TypeObj)0) {
			function = objectType.findMethod(self.value.identifier.name);
		}

		if (function == (Function)0) {
			parser.error(self.region.start, " expected identifier to be a function\n");
		}

		if (!function.isChecked) {
			function.typeCheckFunction(parser);
		}

		self.arguments.typeCheckArguments(function, parser, objectType);

		return function.returnType.typeObj;
	}

	func writeCall(Call self, Compiler compiler, bool getPointer) -> Register {
		if (self.lparen == (Operator)0) {
			return self.value.writeValue(compiler, getPointer);
		}

		var function = self.value.identifier.definition.function;
		if (function == (Function)0) {
			print("function not found\n");
			return (Register)0;
		}

		if (self.arguments.value != (Expression)0) {
			compiler.writePush(self.arguments.value.writeExpression(compiler, false));

			var i = 0;
			while (i < self.arguments.parts.size) {
				var part = self.arguments.parts.get(i).value;
				compiler.writePush(part.writeExpression(compiler, false));
				i = i + 1;
			}
		}

		return function.writeFunctionCall(compiler);
	}

	func getTypeCall(Call self, Parser parser) -> TypeObj {
		var typeObj = self.value.getTypeValue(parser);

		if (self.lparen != (Operator)0) {
			parser.error(self.lparen.position, " do not yet support getting type from function\n");
		}

		return typeObj;
	}
}
