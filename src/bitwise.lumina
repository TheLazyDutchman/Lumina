import "parser.lumina"
import "lexer.lumina"
import "type.lumina"
import "position.lumina"
import "unary.lumina"
import "operator.lumina"
import "block.lumina"


type Bitwise {
	Region region;

	Unary left;
	Operator comparator;
	Unary right;


	func parseBitwise(Bitwise self, Parser parser, Lexer lexer, Block block) -> Bitwise {
		self.region = lexer.startRegion();

		self.left = new Unary();
		self.left.parseUnary(parser, lexer, block);

		self.comparator = lexer.consumePrecedence(PREC_bitwise);
		if (self.comparator != (Operator)0) {
			self.right = new Unary();
			self.right.parseUnary(parser, lexer, block);
		}

		lexer.endRegion(self.region);

		return self;
	}

	func bindBitwise(Bitwise self, Parser parser) {
		self.left.bindUnary(parser);

		if (self.right != (Unary)0) {
			self.right.bindUnary(parser);
		}
	}

	func typeCheckBitwise(Bitwise self, Parser parser) -> TypeObj {
		var leftType = self.left.typeCheckUnary(parser);

		if (self.right == (Unary)0) {
			return leftType;
		}

		if (!leftType.checkType(parser.int, parser)) {
			parser.error(self.region.start, " expected left hand side of bitwise operation to be of type 'int'\n");
		}

		var rightType = self.right.typeCheckUnary(parser);

		if (!rightType.checkType(parser.int, parser)) {
			parser.error(self.right.region.start, " expected right hand side of bitwise operation to be of type 'int'\n");
		}

		return parser.int;
	}
}
