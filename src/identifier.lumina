import "../std/io.lumina"
import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "index.lumina"
import "name.lumina"
import "operator.lumina"
import "position.lumina"
import "definition.lumina"


type GenericPart {
	Operator comma;
	Index value;
}

type GenericArray {
	Region region;

	Operator left;

	Index value;
	Array<GenericPart> parts;

	Operator right;

	func parse(GenericArray self, Parser parser, Lexer lexer, Position returnPosition) -> bool {
		self.region = lexer.startRegion();

		self.left = lexer.consumeOperator("<");

		self.value = new Index();
		self.value.parse(parser, lexer);

		var hadComma = false;
		self.parts = createArray<GenericPart>();

		while (isOperator(lexer.current.operator, ",")) {
			hadComma = true;

			var part = new GenericPart();
			part.comma = lexer.consumeOperator(",");

			part.value = new Index();
			part.value.parse(parser, lexer);

			self.parts.push(part);
		}

		self.right = lexer.consumeOperator(">");
		if (self.right == (Operator)0) {
			if (!hadComma) {
				lexer.returnTo(returnPosition);
				return false;
			}
			parser.error(lexer.here(), " expected '>' after generics\n");
		}

		return true;
	}
}

type Identifier {
	Region region;
	str name;
	Name definition;

	GenericArray generics;

	Definition value;

	func parse(Identifier self, Parser parser, Lexer lexer) -> Identifier {
		self.region = lexer.startRegion();

		self.definition = lexer.consumeIdentifier();
		
		if (isOperator(lexer.current.operator, "<")) {
			self.generics = new GenericArray();
			if (!self.generics.parse(parser, lexer, lexer.here())) {
				self.generics = (GenericArray)0;
			}
		}

		lexer.endRegion(self.region);
		return self;
	}
}

func createIdentifierFromName(Name name) -> Identifier {
	if (isIdentifier(name) != true) {
		printPosition(name.region.start);
		print(" expected an identifier\n");
		return (Identifier)0;
	}

	var identifier = new Identifier();

	identifier.name = name.name;
	identifier.definition = name;
	identifier.value = (Definition)0;

	return identifier;
}
