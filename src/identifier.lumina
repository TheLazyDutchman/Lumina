import "../std/io.lumina"
import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "block.lumina"
import "index.lumina"
import "name.lumina"
import "variable.lumina"
import "operator.lumina"
import "position.lumina"
import "definition.lumina"


type GenericPart {
	Operator comma;
	Index value;
}

type TypeListPart {
	Operator lbracket;
	Operator rbracket;
}

type GenericArray {
	Region region;

	Operator left;

	Index value;
	Array<GenericPart> generics;

	Operator right;

	func parseGenericArray(GenericArray self, Parser parser, Lexer lexer, Block block, Position returnPosition) -> bool {
		self.region = lexer.startRegion();

		self.left = lexer.consumeOperator("<");

		self.value = new Index();
		self.value.parseIndex(parser, lexer, block);

		var hadComma = false;
		self.generics = createArray<GenericPart>();

		while (isOperator(lexer.current.operator, ",")) {
			hadComma = true;

			var part = new GenericPart();
			part.comma = lexer.consumeOperator(",");

			part.value = new Index();
			part.value.parseIndex(parser, lexer, block);

			self.generics.push(part);
		}

		self.right = lexer.consumeOperator(">");
		if (self.right == (Operator)0) {
			if (!hadComma) {
				lexer.returnTo(returnPosition);
				return false;
			}
			parser.error(lexer.here(), " expected '>' after generics\n");
		}

		return true;
	}

	func bindGenericArray(GenericArray self, Parser parser) {
		self.value.bindIndex(parser);

		var i = 0;
		while (i < self.generics.size) {
			var part = self.generics.get(i);
			part.value.bindIndex(parser);
			i = i + 1;
		}
	}
}

type Identifier {
	Region region;
	str name;
	Name value;

	GenericArray generics;
	Array<TypeListPart> lists;

	Definition definition;
	Block block;

	func parseIdentifier(Identifier self, Parser parser, Lexer lexer, Block block) -> Identifier {
		self.block = block;
		self.region = lexer.startRegion();

		self.value = lexer.consumeIdentifier();
		if (self.value == (Name)0) {
			parser.error(lexer.here(), " expected identifier\n");
		}
		self.name = self.value.name;
		
		if (isOperator(lexer.current.operator, "<")) {
			self.generics = new GenericArray();
			if (!self.generics.parseGenericArray(parser, lexer, block, lexer.here())) {
				self.generics = (GenericArray)0;
			}
		}

		self.lists = createArray<TypeListPart>();
		var endLists = false;
		while (!endLists && isOperator(lexer.current.operator, "[")) {
			var returnPosition = lexer.here();
			var listPart = new TypeListPart();
			listPart.lbracket = lexer.consumeOperator("[");
			listPart.rbracket = lexer.consumeOperator("]");

			if (listPart.rbracket == (Operator)0) {
				if (isOperator(lexer.current.operator, "[")) {
					parser.error(lexer.here(), " did not expect consecutive '[' operators\n");
				} else {
					lexer.returnTo(returnPosition);
				}
				endLists = true;
			}

			self.lists.push(listPart);
		}

		lexer.endRegion(self.region);
		return self;
	}

	func bindIdentifier(Identifier self, Parser parser) {
		self.definition = self.block.findDefinitionInBlock(self.name);

		if (self.definition == (Definition)0) {
			parser.error(self.region.start, " can not find name: ");
			print(self.name);
			print("\n");
		}

		if (self.generics != (GenericArray)0) {
			if (self.definition.variable != (Variable)0) {
				parser.error(self.generics.region.start, " can not get generic of variable\n");
			}

			self.generics.bindGenericArray(parser);
		}
	}
}

func createIdentifierFromString(str value) -> Identifier {
	var identifier = new Identifier();
	identifier.name = value;
	return identifier;
}
