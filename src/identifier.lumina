import "../std/io.lumina"
import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "index.lumina"
import "name.lumina"
import "operator.lumina"
import "position.lumina"
import "definition.lumina"


type GenericPart {
	Operator comma;
	Index value;
}

type TypeListPart {
	Operator lbracket;
	Operator rbracket;
}

type GenericArray {
	Region region;

	Operator left;

	Index value;
	Array<GenericPart> generics;

	Operator right;

	func parseGenericArray(GenericArray self, Parser parser, Lexer lexer, Position returnPosition) -> bool {
		self.region = lexer.startRegion();

		self.left = lexer.consumeOperator("<");

		self.value = new Index();
		self.value.parseIndex(parser, lexer);

		var hadComma = false;
		self.generics = createArray<GenericPart>();

		while (isOperator(lexer.current.operator, ",")) {
			hadComma = true;

			var part = new GenericPart();
			part.comma = lexer.consumeOperator(",");

			part.value = new Index();
			part.value.parseIndex(parser, lexer);

			self.generics.push(part);
		}

		self.right = lexer.consumeOperator(">");
		if (self.right == (Operator)0) {
			if (!hadComma) {
				lexer.returnTo(returnPosition);
				return false;
			}
			parser.error(lexer.here(), " expected '>' after generics\n");
		}

		return true;
	}
}

type Identifier {
	Region region;
	str name;
	Name definition;

	GenericArray generics;
	Array<TypeListPart> lists;

	Definition value;

	func parseIdentifier(Identifier self, Parser parser, Lexer lexer) -> Identifier {
		self.region = lexer.startRegion();

		self.definition = lexer.consumeIdentifier();
		
		if (isOperator(lexer.current.operator, "<")) {
			self.generics = new GenericArray();
			if (!self.generics.parseGenericArray(parser, lexer, lexer.here())) {
				self.generics = (GenericArray)0;
			}
		}

		self.lists = createArray<TypeListPart>();
		var endLists = false;
		while (!endLists && isOperator(lexer.current.operator, "[")) {
			var returnPosition = lexer.here();
			var listPart = new TypeListPart();
			listPart.lbracket = lexer.consumeOperator("[");
			listPart.rbracket = lexer.consumeOperator("]");

			if (listPart.rbracket == (Operator)0) {
				if (isOperator(lexer.current.operator, "[")) {
					parser.error(lexer.here(), " did not expect consecutive '[' operators\n");
				} else {
					lexer.returnTo(returnPosition);
				}
				endLists = true;
			}

			self.lists.push(listPart);
		}

		lexer.endRegion(self.region);
		return self;
	}
}

func createIdentifierFromString(str value) -> Identifier {
	var identifier = new Identifier();
	identifier.name = value;
	return identifier;
}
