import "../std/io.lumina"
import "../std/collections.lumina"

import "parser.lumina"
import "lexer.lumina"
import "block.lumina"
import "index.lumina"
import "name.lumina"
import "variable.lumina"
import "type.lumina"
import "operator.lumina"
import "position.lumina"
import "definition.lumina"


type GenericPart {
	Operator comma;
	Index value;
}

type GenericDefinitionPart {
	Operator comma;
	Name value;
}

type TypeListPart {
	Operator lbracket;
	Operator rbracket;
}

type GenericArray {
	Region region;

	Operator left;

	Index value;
	Array<GenericPart> generics;

	Operator right;

	func parseGenericArray(GenericArray self, Parser parser, Lexer lexer, Block block, Position returnPosition) -> bool {
		self.region = lexer.startRegion();

		self.left = lexer.consumeOperator("<");

		self.value = new Index();
		self.value.parseIndex(parser, lexer, block);

		var hadComma = false;
		self.generics = createArray<GenericPart>();

		while (isOperator(lexer.current.operator, ",")) {
			hadComma = true;

			var part = new GenericPart();
			part.comma = lexer.consumeOperator(",");

			part.value = new Index();
			part.value.parseIndex(parser, lexer, block);

			self.generics.push(part);
		}

		self.right = lexer.consumeOperator(">");
		if (self.right == (Operator)0) {
			if (!hadComma) {
				lexer.returnTo(returnPosition);
				return false;
			}
			parser.error(lexer.here(), " expected '>' after generics\n");
		}

		lexer.endRegion(self.region);
		return true;
	}

	func bindGenericArray(GenericArray self, Parser parser) {
		self.value.bindIndex(parser);

		var i = 0;
		while (i < self.generics.size) {
			var part = self.generics.get(i);
			part.value.bindIndex(parser);
			i = i + 1;
		}
	}
}

type GenericDefinitionArray {
	Region region;

	Operator left;

	Name value;
	Array<GenericDefinitionPart> parts;

	Operator right;

	func parseGenericDefinitionArray(GenericDefinitionArray self, Parser parser, Lexer lexer) {
		self.region = lexer.startRegion();
		
		self.left = lexer.consumeOperator("<");

		self.value = lexer.consumeIdentifier();
		if (self.value == (Name)0) {
			parser.error(lexer.here(), " expected generic name\n");
		}

		self.parts = createArray<GenericDefinitionPart>();

		while (isOperator(lexer.current.operator, ",")) {
			var part = new GenericDefinitionPart();
			part.comma = lexer.consumeOperator(",");

			part.value = lexer.consumeIdentifier();
			self.parts.push(part);
		}

		self.right = lexer.consumeOperator(">");
		if (self.right == (Operator)0) {
			parser.error(lexer.here(), " expected '>' after generics definition\n");
		}

		lexer.endRegion(self.region);
	}

	func addTypes(GenericDefinitionArray self, Array<TypeObj> types, Array<Definition> definitions) {
		var typeObj = createTypeFromString(self.value.name, 8);
		types.push(typeObj);
		definitions.push(createDefinitionFromType(typeObj));


		var i = 0;
		while (i < self.parts.size) {
			var part = self.parts.get(i);
			typeObj = createTypeFromString(part.value.name, 8);
			types.push(typeObj);
			definitions.push(createDefinitionFromType(typeObj));
			i = i + 1;
		}
	}

	func printGenericDefinition(GenericDefinitionArray self) {
		print("<");
		print(self.value.name);

		var i = 0;
		while (i < self.parts.size) {
			var part = self.parts.get(i);

			print(",");
			print(part.value.name);
			i = i + 1;
		}

		print(">");
	}
}

type Identifier {
	Region region;
	str name;
	Name value;

	GenericArray generics;
	Array<TypeListPart> lists;

	Definition definition;
	Block block;

	func parseIdentifier(Identifier self, Parser parser, Lexer lexer, Block block) -> Identifier {
		self.block = block;
		self.region = lexer.startRegion();

		self.value = lexer.consumeIdentifier();
		if (self.value == (Name)0) {
			parser.error(lexer.here(), " expected identifier\n");
		}
		self.name = self.value.name;
		
		if (isOperator(lexer.current.operator, "<")) {
			self.generics = new GenericArray();
			if (!self.generics.parseGenericArray(parser, lexer, block, lexer.here())) {
				self.generics = (GenericArray)0;
			}
		}

		self.lists = createArray<TypeListPart>();
		var endLists = false;
		while (!endLists && isOperator(lexer.current.operator, "[")) {
			var returnPosition = lexer.here();
			var listPart = new TypeListPart();
			listPart.lbracket = lexer.consumeOperator("[");
			listPart.rbracket = lexer.consumeOperator("]");

			if (listPart.rbracket == (Operator)0) {
				if (isOperator(lexer.current.operator, "[")) {
					parser.error(lexer.here(), " did not expect consecutive '[' operators\n");
				} else {
					lexer.returnTo(returnPosition);
				}
				endLists = true;
			}

			self.lists.push(listPart);
		}

		lexer.endRegion(self.region);
		return self;
	}

	func bindIdentifier(Identifier self, Parser parser, bool isProperty) {
		self.definition = self.block.findDefinitionInBlock(self.name);

		if (self.definition == (Definition)0 && !isProperty) {
			parser.error(self.region.start, " can not find name: ");
			print(self.name);
			print("\n");
		}

		if (self.generics != (GenericArray)0) {
			if (self.definition.variable != (Variable)0) {
				parser.error(self.generics.region.start, " can not get generic of variable\n");
			}

			self.generics.bindGenericArray(parser);
		}

		if (self.definition.variable != (Variable)0 && self.definition.variable.region.end.index > self.region.start.index) {
			parser.error(self.region.start, " can not use variable before definition\n");
		}
	}

	func typeCheckIdentifier(Identifier self, Parser parser) -> TypeObj {
		if (self.definition.typeObj != (TypeObj)0) {
			return parser.Type;
		}

		if (self.definition.variable != (Variable)0) {
			return self.definition.variable.variableType;
		}

		return (TypeObj)0;
	}
}

type IdentifierDefinition {
	Region region;
	str name;
	Name value;

	GenericDefinitionArray generics;

	func parseIdentifierDefinition(IdentifierDefinition self, Parser parser, Lexer lexer) {
		self.region = lexer.startRegion();

		self.value = lexer.consumeIdentifier();
		if (self.value == (Name)0) {
			parser.error(lexer.here(), " expected identifier\n");
		}
		self.name = self.value.name;

		if (isOperator(lexer.current.operator, "<")) {
			self.generics = new GenericDefinitionArray();
			self.generics.parseGenericDefinitionArray(parser, lexer);
		}

		lexer.endRegion(self.region);
	}
}

func createIdentifierFromString(str value) -> Identifier {
	var identifier = new Identifier();
	identifier.name = value;
	return identifier;
}

func createIdentifierDefinitionFromString(str value) -> IdentifierDefinition {
	var identifier = new IdentifierDefinition();
	identifier.name = value;
	return identifier;
}

func createIdentifierFromDefinition(IdentifierDefinition value) -> Identifier {
	var identifier = new Identifier();
	identifier.name = value.name;

	//TODO: deal with generics
	return identifier;
}
